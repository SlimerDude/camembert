[
 {
  "name": "find_items", 
  "doc": "Return a list of all found items(dictionaries) for modules, classes, functions\n\nModule item keys: type, name, doc, file, line\nClass item keys: type, name, doc, file, line, module\nFunction/Method item keys: type, name, doc, file, line, class, module", 
  "module": "docinfo", 
  "file": "/home/tcolar/DEV/projects/perso/camembert/plugins/python/python/docinfo.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "doc": "JSON (JavaScript Object Notation) <http://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\n:mod:`json` exposes an API familiar to users of the standard library\n:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained\nversion of the :mod:`json` library contained in Python 2.6, but maintains\ncompatibility with Python 2.4 and Python 2.5 and (currently) has\nsignificant performance advantages, even without using the optional C\nextension for speedups.\n\nEncoding basic Python object hierarchies::\n\n    >>> import json\n    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n    '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n    >>> print(json.dumps(\"\\\"foo\\bar\"))\n    \"\\\"foo\\bar\"\n    >>> print(json.dumps('\\u1234'))\n    \"\\u1234\"\n    >>> print(json.dumps('\\\\'))\n    \"\\\\\"\n    >>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n    {\"a\": 0, \"b\": 0, \"c\": 0}\n    >>> from io import StringIO\n    >>> io = StringIO()\n    >>> json.dump(['streaming API'], io)\n    >>> io.getvalue()\n    '[\"streaming API\"]'\n\nCompact encoding::\n\n    >>> import json\n    >>> from collections import OrderedDict\n    >>> mydict = OrderedDict([('4', 5), ('6', 7)])\n    >>> json.dumps([1,2,3,mydict], separators=(',', ':'))\n    '[1,2,3,{\"4\":5,\"6\":7}]'\n\nPretty printing::\n\n    >>> import json\n    >>> s = json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)\n    >>> print('\\n'.join([l.rstrip() for l in  s.splitlines()]))\n    {\n        \"4\": 5,\n        \"6\": 7\n    }\n\nDecoding JSON::\n\n    >>> import json\n    >>> obj = ['foo', {'bar': ['baz', None, 1.0, 2]}]\n    >>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]') == obj\n    True\n    >>> json.loads('\"\\\\\"foo\\\\bar\"') == '\"foo\\x08ar'\n    True\n    >>> from io import StringIO\n    >>> io = StringIO('[\"streaming API\"]')\n    >>> json.load(io)[0] == 'streaming API'\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import json\n    >>> def as_complex(dct):\n    ...     if '__complex__' in dct:\n    ...         return complex(dct['real'], dct['imag'])\n    ...     return dct\n    ...\n    >>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> json.loads('1.1', parse_float=Decimal) == Decimal('1.1')\n    True\n\nSpecializing JSON object encoding::\n\n    >>> import json\n    >>> def encode_complex(obj):\n    ...     if isinstance(obj, complex):\n    ...         return [obj.real, obj.imag]\n    ...     raise TypeError(repr(o) + \" is not JSON serializable\")\n    ...\n    >>> json.dumps(2 + 1j, default=encode_complex)\n    '[2.0, 1.0]'\n    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n    '[2.0, 1.0]'\n    >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n    '[2.0, 1.0]'\n\n\nUsing json.tool from the shell to validate and pretty-print::\n\n    $ echo '{\"json\":\"obj\"}' | python -m json.tool\n    {\n        \"json\": \"obj\"\n    }\n    $ echo '{ 1.2:3.4}' | python -m json.tool\n    Expecting property name: line 1 column 2 (char 2)", 
  "line": 0, 
  "type": "module", 
  "name": "json", 
  "file": "/usr/lib/python3.2/json/__init__.py"
 }, 
 {
  "doc": "Utilities to support packages.", 
  "line": 0, 
  "type": "module", 
  "name": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py"
 }, 
 {
  "doc": "subprocess - Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.  This module\nintends to replace several other, older modules and functions, like:\n\nos.system\nos.spawn*\n\nInformation about how the subprocess module can be used to replace these\nmodules and functions can be found below.\n\n\n\nUsing the subprocess module\n===========================\nThis module defines one class called Popen:\n\nclass Popen(args, bufsize=0, executable=None,\n            stdin=None, stdout=None, stderr=None,\n            preexec_fn=None, close_fds=True, shell=False,\n            cwd=None, env=None, universal_newlines=False,\n            startupinfo=None, creationflags=0,\n            restore_signals=True, start_new_session=False, pass_fds=()):\n\n\nArguments are:\n\nargs should be a string, or a sequence of program arguments.  The\nprogram to execute is normally the first item in the args sequence or\nstring, but can be explicitly set by using the executable argument.\n\nOn POSIX, with shell=False (default): In this case, the Popen class\nuses os.execvp() to execute the child program.  args should normally\nbe a sequence.  A string will be treated as a sequence with the string\nas the only item (the program to execute).\n\nOn POSIX, with shell=True: If args is a string, it specifies the\ncommand string to execute through the shell.  If args is a sequence,\nthe first item specifies the command string, and any additional items\nwill be treated as additional shell arguments.\n\nOn Windows: the Popen class uses CreateProcess() to execute the child\nprogram, which operates on strings.  If args is a sequence, it will be\nconverted to a string using the list2cmdline method.  Please note that\nnot all MS Windows applications interpret the command line the same\nway: The list2cmdline is designed for applications using the same\nrules as the MS C runtime.\n\nbufsize, if given, has the same meaning as the corresponding argument\nto the built-in open() function: 0 means unbuffered, 1 means line\nbuffered, any other positive value means use a buffer of\n(approximately) that size.  A negative bufsize means to use the system\ndefault, which usually means fully buffered.  The default value for\nbufsize is 0 (unbuffered).\n\nstdin, stdout and stderr specify the executed programs' standard\ninput, standard output and standard error file handles, respectively.\nValid values are PIPE, an existing file descriptor (a positive\ninteger), an existing file object, and None.  PIPE indicates that a\nnew pipe to the child should be created.  With None, no redirection\nwill occur; the child's file handles will be inherited from the\nparent.  Additionally, stderr can be STDOUT, which indicates that the\nstderr data from the applications should be captured into the same\nfile handle as for stdout.\n\nOn POSIX, if preexec_fn is set to a callable object, this object will be\ncalled in the child process just before the child is executed.  The use\nof preexec_fn is not thread safe, using it in the presence of threads\ncould lead to a deadlock in the child process before the new executable\nis executed.\n\nIf close_fds is true, all file descriptors except 0, 1 and 2 will be\nclosed before the child process is executed.  The default for close_fds\nvaries by platform:  Always true on POSIX.  True when stdin/stdout/stderr\nare None on Windows, false otherwise.\n\npass_fds is an optional sequence of file descriptors to keep open between the\nparent and child.  Providing any pass_fds implicitly sets close_fds to true.\n\nif shell is true, the specified command will be executed through the\nshell.\n\nIf cwd is not None, the current directory will be changed to cwd\nbefore the child is executed.\n\nOn POSIX, if restore_signals is True all signals that Python sets to\nSIG_IGN are restored to SIG_DFL in the child process before the exec.\nCurrently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals.  This\nparameter does nothing on Windows.\n\nOn POSIX, if start_new_session is True, the setsid() system call will be made\nin the child process prior to executing the command.\n\nIf env is not None, it defines the environment variables for the new\nprocess.\n\nIf universal_newlines is true, the file objects stdout and stderr are\nopened as a text files, but lines may be terminated by any of '\\n',\nthe Unix end-of-line convention, '\\r', the old Macintosh convention or\n'\\r\\n', the Windows convention.  All of these external representations\nare seen as '\\n' by the Python program.  Note: This feature is only\navailable if Python is built with universal newline support (the\ndefault).  Also, the newlines attribute of the file objects stdout,\nstdin and stderr are not updated by the communicate() method.\n\nThe startupinfo and creationflags, if given, will be passed to the\nunderlying CreateProcess() function.  They can specify things such as\nappearance of the main window and priority for the new process.\n(Windows only)\n\n\nThis module also defines some shortcut functions:\n\ncall(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> retcode = subprocess.call([\"ls\", \"-l\"])\n\ncheck_call(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete.  If the\n    exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> subprocess.check_call([\"ls\", \"-l\"])\n    0\n\ngetstatusoutput(cmd):\n    Return (status, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple\n    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the\n    returned output will contain output or error messages. A trailing newline\n    is stripped from the output. The exit status for the command can be\n    interpreted according to the rules for the C function wait().  Example:\n\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (256, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (256, 'sh: /bin/junk: not found')\n\ngetoutput(cmd):\n    Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n\ncheck_output(*popenargs, **kwargs):\n    Run command with arguments and return its output as a byte string.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> output = subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n\n\nExceptions\n----------\nExceptions raised in the child process, before the new program has\nstarted to execute, will be re-raised in the parent.  Additionally,\nthe exception object will have one extra attribute called\n'child_traceback', which is a string containing traceback information\nfrom the childs point of view.\n\nThe most common exception raised is OSError.  This occurs, for\nexample, when trying to execute a non-existent file.  Applications\nshould prepare for OSErrors.\n\nA ValueError will be raised if Popen is called with invalid arguments.\n\ncheck_call() and check_output() will raise CalledProcessError, if the\ncalled process returns a non-zero return code.\n\n\nSecurity\n--------\nUnlike some other popen functions, this implementation will never call\n/bin/sh implicitly.  This means that all characters, including shell\nmetacharacters, can safely be passed to child processes.\n\n\nPopen objects\n=============\nInstances of the Popen class have the following methods:\n\npoll()\n    Check if child process has terminated.  Returns returncode\n    attribute.\n\nwait()\n    Wait for child process to terminate.  Returns returncode attribute.\n\ncommunicate(input=None)\n    Interact with process: Send data to stdin.  Read data from stdout\n    and stderr, until end-of-file is reached.  Wait for process to\n    terminate.  The optional input argument should be a string to be\n    sent to the child process, or None, if no data should be sent to\n    the child.\n\n    communicate() returns a tuple (stdout, stderr).\n\n    Note: The data read is buffered in memory, so do not use this\n    method if the data size is large or unlimited.\n\nThe following attributes are also available:\n\nstdin\n    If the stdin argument is PIPE, this attribute is a file object\n    that provides input to the child process.  Otherwise, it is None.\n\nstdout\n    If the stdout argument is PIPE, this attribute is a file object\n    that provides output from the child process.  Otherwise, it is\n    None.\n\nstderr\n    If the stderr argument is PIPE, this attribute is file object that\n    provides error output from the child process.  Otherwise, it is\n    None.\n\npid\n    The process ID of the child process.\n\nreturncode\n    The child return code.  A None value indicates that the process\n    hasn't terminated yet.  A negative value -N indicates that the\n    child was terminated by signal N (POSIX only).\n\n\nReplacing older functions with the subprocess module\n====================================================\nIn this section, \"a ==> b\" means that b can be used as a replacement\nfor a.\n\nNote: All functions in this section fail (more or less) silently if\nthe executed program cannot be found; this module raises an OSError\nexception.\n\nIn the following examples, we assume that the subprocess module is\nimported with \"from subprocess import *\".\n\n\nReplacing /bin/sh shell backquote\n---------------------------------\noutput=`mycmd myarg`\n==>\noutput = Popen([\"mycmd\", \"myarg\"], stdout=PIPE).communicate()[0]\n\n\nReplacing shell pipe line\n-------------------------\noutput=`dmesg | grep hda`\n==>\np1 = Popen([\"dmesg\"], stdout=PIPE)\np2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\n\n\nReplacing os.system()\n---------------------\nsts = os.system(\"mycmd\" + \" myarg\")\n==>\np = Popen(\"mycmd\" + \" myarg\", shell=True)\npid, sts = os.waitpid(p.pid, 0)\n\nNote:\n\n* Calling the program through the shell is usually not required.\n\n* It's easier to look at the returncode attribute than the\n  exitstatus.\n\nA more real-world example would look like this:\n\ntry:\n    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n    if retcode < 0:\n        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n    else:\n        print(\"Child returned\", retcode, file=sys.stderr)\nexcept OSError as e:\n    print(\"Execution failed:\", e, file=sys.stderr)\n\n\nReplacing os.spawn*\n-------------------\nP_NOWAIT example:\n\npid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\npid = Popen([\"/bin/mycmd\", \"myarg\"]).pid\n\n\nP_WAIT example:\n\nretcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\nretcode = call([\"/bin/mycmd\", \"myarg\"])\n\n\nVector example:\n\nos.spawnvp(os.P_NOWAIT, path, args)\n==>\nPopen([path] + args[1:])\n\n\nEnvironment example:\n\nos.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n==>\nPopen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})", 
  "line": 0, 
  "type": "module", 
  "name": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "Visitor", 
  "doc": "Modules AST visitor. Builds a list of items (modules, classes, functions)", 
  "module": "docinfo_ast", 
  "file": "/home/tcolar/DEV/projects/perso/camembert/plugins/python/python/docinfo_ast.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "ast\n~~~\n\nThe `ast` module helps Python applications to process trees of the Python\nabstract syntax grammar.  The abstract syntax itself might change with\neach Python release; this module helps to find out programmatically what\nthe current grammar looks like and allows modifications of it.\n\nAn abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as\na flag to the `compile()` builtin function or by using the `parse()`\nfunction from this module.  The result will be a tree of objects whose\nclasses all inherit from `ast.AST`.\n\nA modified abstract syntax tree can be compiled into a Python code object\nusing the built-in `compile()` function.\n\nAdditionally various helper functions are provided that make working with\nthe trees simpler.  The main intention of the helper functions and this\nmodule in general is to provide an easy to use interface for libraries\nthat work tightly with the python syntax (template engines for example).\n\n\n:copyright: Copyright 2008 by Armin Ronacher.\n:license: Python License.", 
  "line": 0, 
  "type": "module", 
  "name": "ast", 
  "file": "/usr/lib/python3.2/ast.py"
 }, 
 {
  "name": "find_items", 
  "doc": "Return a list of all found items(dictionaries) for modules, classes, functions\n\nModule item keys: type, name, doc, file, line\nClass item keys: type, name, doc, file, line, module\nFunction/Method item keys: type, name, doc, file, line, class, module", 
  "module": "docinfo_ast", 
  "file": "/home/tcolar/DEV/projects/perso/camembert/plugins/python/python/docinfo_ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "doc": "JSON (JavaScript Object Notation) <http://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\n:mod:`json` exposes an API familiar to users of the standard library\n:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained\nversion of the :mod:`json` library contained in Python 2.6, but maintains\ncompatibility with Python 2.4 and Python 2.5 and (currently) has\nsignificant performance advantages, even without using the optional C\nextension for speedups.\n\nEncoding basic Python object hierarchies::\n\n    >>> import json\n    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n    '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n    >>> print(json.dumps(\"\\\"foo\\bar\"))\n    \"\\\"foo\\bar\"\n    >>> print(json.dumps('\\u1234'))\n    \"\\u1234\"\n    >>> print(json.dumps('\\\\'))\n    \"\\\\\"\n    >>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n    {\"a\": 0, \"b\": 0, \"c\": 0}\n    >>> from io import StringIO\n    >>> io = StringIO()\n    >>> json.dump(['streaming API'], io)\n    >>> io.getvalue()\n    '[\"streaming API\"]'\n\nCompact encoding::\n\n    >>> import json\n    >>> from collections import OrderedDict\n    >>> mydict = OrderedDict([('4', 5), ('6', 7)])\n    >>> json.dumps([1,2,3,mydict], separators=(',', ':'))\n    '[1,2,3,{\"4\":5,\"6\":7}]'\n\nPretty printing::\n\n    >>> import json\n    >>> s = json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)\n    >>> print('\\n'.join([l.rstrip() for l in  s.splitlines()]))\n    {\n        \"4\": 5,\n        \"6\": 7\n    }\n\nDecoding JSON::\n\n    >>> import json\n    >>> obj = ['foo', {'bar': ['baz', None, 1.0, 2]}]\n    >>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]') == obj\n    True\n    >>> json.loads('\"\\\\\"foo\\\\bar\"') == '\"foo\\x08ar'\n    True\n    >>> from io import StringIO\n    >>> io = StringIO('[\"streaming API\"]')\n    >>> json.load(io)[0] == 'streaming API'\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import json\n    >>> def as_complex(dct):\n    ...     if '__complex__' in dct:\n    ...         return complex(dct['real'], dct['imag'])\n    ...     return dct\n    ...\n    >>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> json.loads('1.1', parse_float=Decimal) == Decimal('1.1')\n    True\n\nSpecializing JSON object encoding::\n\n    >>> import json\n    >>> def encode_complex(obj):\n    ...     if isinstance(obj, complex):\n    ...         return [obj.real, obj.imag]\n    ...     raise TypeError(repr(o) + \" is not JSON serializable\")\n    ...\n    >>> json.dumps(2 + 1j, default=encode_complex)\n    '[2.0, 1.0]'\n    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n    '[2.0, 1.0]'\n    >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n    '[2.0, 1.0]'\n\n\nUsing json.tool from the shell to validate and pretty-print::\n\n    $ echo '{\"json\":\"obj\"}' | python -m json.tool\n    {\n        \"json\": \"obj\"\n    }\n    $ echo '{ 1.2:3.4}' | python -m json.tool\n    Expecting property name: line 1 column 2 (char 2)", 
  "line": 0, 
  "type": "module", 
  "name": "json", 
  "file": "/usr/lib/python3.2/json/__init__.py"
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Utilities to support packages.", 
  "line": 0, 
  "type": "module", 
  "name": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "_Feature", 
  "doc": null, 
  "module": "__future__", 
  "file": "/usr/lib/python3.2/__future__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ABCMeta", 
  "doc": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).", 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ByteString", 
  "doc": "This unifies bytes and bytearray.\n\nXXX Should add all their methods.", 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Callable", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Container", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Hashable", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ItemsView", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Iterable", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Iterator", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "KeysView", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Mapping", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MappingView", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MutableMapping", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MutableSequence", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MutableSet", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Sequence", 
  "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.", 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Set", 
  "doc": "A set is a finite, iterable container.\n\nThis class provides concrete generic implementations of all\nmethods except for __contains__, __iter__ and __len__.\n\nTo override the comparisons (presumably for speed, as the\nsemantics are fixed), all you have to do is redefine __le__ and\nthen the other operations will automatically follow suit.", 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Sized", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ValuesView", 
  "doc": null, 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "abstractmethod", 
  "doc": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...", 
  "module": "_abcoll", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bytearray_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "bytes_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_itemiterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_items", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_keyiterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_keys", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_proxy", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_valueiterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dict_values", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "list_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "list_reverseiterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "range_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "set_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "str_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "tuple_iterator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "zip_iterator", 
  "doc": "zip(iter1 [,iter2 [...]]) --> zip object\n\nReturn a zip object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BlockingIOError", 
  "doc": "Exception raised when I/O would block on a non-blocking I/O stream.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedIOBase", 
  "doc": "Base class for buffered IO objects.\n\nThe main difference with RawIOBase is that the read() method\nsupports omitting the size argument, and does not have a default\nimplementation that defers to readinto().\n\nIn addition, read(), readinto() and write() may raise\nBlockingIOError if the underlying raw stream is in non-blocking\nmode and not ready; unlike their raw counterparts, they will never\nreturn None.\n\nA typical implementation should not inherit from a RawIOBase\nimplementation, but wrap one.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedRWPair", 
  "doc": "A buffered reader and writer object together.\n\nA buffered reader object and buffered writer object put together to\nform a sequential IO object that can read and write. This is typically\nused with a socket or two-way pipe.\n\nreader and writer are RawIOBase objects that are readable and\nwriteable respectively. If the buffer_size is omitted it defaults to\nDEFAULT_BUFFER_SIZE.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedRandom", 
  "doc": "A buffered interface to random access streams.\n\nThe constructor creates a reader and writer for a seekable stream,\nraw, given in the first argument. If the buffer_size is omitted it\ndefaults to DEFAULT_BUFFER_SIZE.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedReader", 
  "doc": "BufferedReader(raw[, buffer_size])\n\nA buffer for a readable, sequential BaseRawIO object.\n\nThe constructor creates a BufferedReader for the given readable raw\nstream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE\nis used.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedWriter", 
  "doc": "A buffer for a writeable sequential RawIO object.\n\nThe constructor creates a BufferedWriter for the given writeable raw\nstream. If the buffer_size is not given, it defaults to\nDEFAULT_BUFFER_SIZE.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BytesIO", 
  "doc": "Buffered I/O implementation using an in-memory bytes buffer.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocDescriptor", 
  "doc": "Helper for builtins.open.__doc__\n    ", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FileIO", 
  "doc": "file(name: str[, mode: str]) -> file IO object\n\nOpen a file.  The mode can be 'r', 'w' or 'a' for reading (default),\nwriting or appending.  The file will be created if it doesn't exist\nwhen opened for writing or appending; it will be truncated when\nopened for writing.  Add a '+' to the mode to allow simultaneous\nreading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IOBase", 
  "doc": "The abstract base class for all I/O classes, acting on streams of\nbytes. There is no public constructor.\n\nThis class provides dummy implementations for many methods that\nderived classes can override selectively; the default implementations\nrepresent a file that cannot be read, written or seeked.\n\nEven though IOBase does not declare read, readinto, or write because\ntheir signatures will vary, implementations and clients should\nconsider those methods part of the interface. Also, implementations\nmay raise UnsupportedOperation when operations they do not support are\ncalled.\n\nThe basic type used for binary data read from or written to a file is\nbytes. bytearrays are accepted too, and in some cases (such as\nreadinto) needed. Text I/O classes work with str data.\n\nNote that calling any method (even inquiries) on a closed stream is\nundefined. Implementations may raise IOError in this case.\n\nIOBase (and its subclasses) support the iterator protocol, meaning\nthat an IOBase object can be iterated over yielding the lines in a\nstream.\n\nIOBase also supports the :keyword:`with` statement. In this example,\nfp is closed after the suite of the with statement is complete:\n\nwith open('spam.txt', 'r') as fp:\n    fp.write('Spam and eggs!')", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IncrementalNewlineDecoder", 
  "doc": "Codec used when reading a file in universal newlines mode.  It wraps\nanother incremental decoder, translating \\r\\n and \\r into \\n.  It also\nrecords the types of newlines encountered.  When used with\ntranslate=False, it ensures that the newline sequence is returned in\none piece.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Lock", 
  "doc": "allocate_lock() -> lock object\n(allocate() is an obsolete synonym)\n\nCreate a new lock object.  See help(LockType) for information about locks.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "OpenWrapper", 
  "doc": "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True)\n\nOpen file and return a stream.  Raise IOError upon failure.\n\n    file is either a text or byte string giving the name (and the path\n    if the file isn't in the current working directory) of the file to\n    be opened or an integer file descriptor of the file to be\n    wrapped. (If a file descriptor is given, it is closed when the\n    returned I/O object is closed, unless closefd is set to False.)\n\n    mode is an optional string that specifies the mode in which the file\n    is opened. It defaults to 'r' which means open for reading in text\n    mode.  Other common values are 'w' for writing (truncating the file if\n    it already exists), and 'a' for appending (which on some Unix systems,\n    means that all writes append to the end of the file regardless of the\n    current seek position). In text mode, if encoding is not specified the\n    encoding used is platform dependent. (For reading and writing raw\n    bytes use binary mode and leave encoding unspecified.) The available\n    modes are:\n\n    ========= ===============================================================\n    Character Meaning\n    --------- ---------------------------------------------------------------\n    'r'       open for reading (default)\n    'w'       open for writing, truncating the file first\n    'a'       open for writing, appending to the end of the file if it exists\n    'b'       binary mode\n    't'       text mode (default)\n    '+'       open a disk file for updating (reading and writing)\n    'U'       universal newline mode (for backwards compatibility; unneeded\n              for new code)\n    ========= ===============================================================\n\n    The default mode is 'rt' (open for reading text). For binary random\n    access, the mode 'w+b' opens and truncates the file to 0 bytes, while\n    'r+b' opens the file without truncation.\n\n    Python distinguishes between files opened in binary and text modes,\n    even when the underlying operating system doesn't. Files opened in\n    binary mode (appending 'b' to the mode argument) return contents as\n    bytes objects without any decoding. In text mode (the default, or when\n    't' is appended to the mode argument), the contents of the file are\n    returned as strings, the bytes having been first decoded using a\n    platform-dependent encoding or using the specified encoding if given.\n\n    buffering is an optional integer used to set the buffering policy.\n    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select\n    line buffering (only usable in text mode), and an integer > 1 to indicate\n    the size of a fixed-size chunk buffer.  When no buffering argument is\n    given, the default buffering policy works as follows:\n\n    * Binary files are buffered in fixed-size chunks; the size of the buffer\n      is chosen using a heuristic trying to determine the underlying device's\n      \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n      On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n    * \"Interactive\" text files (files for which isatty() returns True)\n      use line buffering.  Other text files use the policy described above\n      for binary files.\n\n    encoding is the str name of the encoding used to decode or encode the\n    file. This should only be used in text mode. The default encoding is\n    platform dependent, but any encoding supported by Python can be\n    passed.  See the codecs module for the list of supported encodings.\n\n    errors is an optional string that specifies how encoding errors are to\n    be handled---this argument should not be used in binary mode. Pass\n    'strict' to raise a ValueError exception if there is an encoding error\n    (the default of None has the same effect), or pass 'ignore' to ignore\n    errors. (Note that ignoring encoding errors can lead to data loss.)\n    See the documentation for codecs.register for a list of the permitted\n    encoding error strings.\n\n    newline is a string controlling how universal newlines works (it only\n    applies to text mode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works\n    as follows:\n\n    * On input, if newline is None, universal newlines mode is\n      enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n      these are translated into '\\n' before being returned to the\n      caller. If it is '', universal newline mode is enabled, but line\n      endings are returned to the caller untranslated. If it has any of\n      the other legal values, input lines are only terminated by the given\n      string, and the line ending is returned to the caller untranslated.\n\n    * On output, if newline is None, any '\\n' characters written are\n      translated to the system default line separator, os.linesep. If\n      newline is '', no translation takes place. If newline is any of the\n      other legal values, any '\\n' characters written are translated to\n      the given string.\n\n    closedfd is a bool. If closefd is False, the underlying file descriptor will\n    be kept open when the file is closed. This does not work when a file name is\n    given and must be True in that case.\n\n    open() returns a file object whose type depends on the mode, and\n    through which the standard file operations such as reading and writing\n    are performed. When open() is used to open a file in a text mode ('w',\n    'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\n    a file in a binary mode, the returned class varies: in read binary\n    mode, it returns a BufferedReader; in write binary and append binary\n    modes, it returns a BufferedWriter, and in read/write mode, it returns\n    a BufferedRandom.\n\n    It is also possible to use a string or bytearray as a file for both\n    reading and writing. For strings StringIO can be used like a file\n    opened in a text mode, and for bytes a BytesIO can be used like a file\n    opened in a binary mode.\n    ", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RawIOBase", 
  "doc": "Base class for raw binary I/O.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextIOBase", 
  "doc": "Base class for text I/O.\n\nThis class provides a character and line based interface to stream\nI/O. There is no readinto method because Python's character strings\nare immutable. There is no public constructor.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextIOWrapper", 
  "doc": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding.\n\nerrors determines the strictness of encoding and decoding (see the\ncodecs.register) and defaults to \"strict\".\n\nnewline can be None, '', '\\n', '\\r', or '\\r\\n'.  It controls the\nhandling of line endings. If it is None, universal newlines is\nenabled.  With this enabled, on input, the lines endings '\\n', '\\r',\nor '\\r\\n' are translated to '\\n' before being returned to the\ncaller. Conversely, on output, '\\n' is translated to the system\ndefault line separator, os.linesep. If newline is any other of its\nlegal values, that newline becomes the newline when the file is read\nand it is returned untranslated. On output, '\\n' is converted to the\nnewline.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnsupportedOperation", 
  "doc": null, 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/io.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_BufferedIOMixin", 
  "doc": "A mixin implementation of BufferedIOBase with an underlying raw stream.\n\nThis passes most requests on to the underlying raw stream.  It\ndoes *not* provide implementations of read(), readinto() or\nwrite().", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Abstract Base Classes (ABCs) according to PEP 3119.", 
  "line": 0, 
  "type": "module", 
  "name": "abc", 
  "file": "/usr/lib/python3.2/abc.py"
 }, 
 {
  "doc": "codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py"
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "open", 
  "doc": "Open file and return a stream.  Raise IOError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), and 'a' for appending (which on some Unix systems,\nmeans that all writes append to the end of the file regardless of the\ncurrent seek position). In text mode, if encoding is not specified the\nencoding used is platform dependent. (For reading and writing raw\nbytes use binary mode and leave encoding unspecified.) The available\nmodes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n'U'       universal newline mode (for backwards compatibility; unneeded\n          for new code)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the str name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register for a list of the permitted\nencoding error strings.\n\nnewline is a string controlling how universal newlines works (it only\napplies to text mode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works\nas follows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '', no translation takes place. If newline is any of the\n  other legal values, any '\\n' characters written are translated to\n  the given string.\n\nclosedfd is a bool. If closefd is False, the underlying file descriptor will\nbe kept open when the file is closed. This does not work when a file name is\ngiven and must be True in that case.\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.", 
  "module": "_pyio", 
  "file": "/usr/lib/python3.2/_pyio.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "LocaleTime", 
  "doc": "Stores and handles locale-specific information related to time.\n\nATTRIBUTES:\n    f_weekday -- full weekday names (7-item list)\n    a_weekday -- abbreviated weekday names (7-item list)\n    f_month -- full month names (13-item list; dummy value in [0], which\n                is added by code)\n    a_month -- abbreviated month names (13-item list, dummy value in\n                [0], which is added by code)\n    am_pm -- AM/PM representation (2-item list)\n    LC_date_time -- format string for date/time representation (string)\n    LC_date -- format string for date representation (string)\n    LC_time -- format string for time representation (string)\n    timezone -- daylight- and non-daylight-savings timezone representation\n                (2-item list of sets)\n    lang -- Language used by instance (2-item tuple)", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TimeRE", 
  "doc": "Handle conversion from format directives to regexes.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_calc_julian_from_U_or_W", 
  "doc": "Calculate the Julian day based on the year, week of the year, and day of\nthe week, with week_start_day representing whether the week of the year\nassumes the week starts on Sunday or Monday (6 or 0).", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getlang", 
  "doc": null, 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strptime", 
  "doc": "Return a 2-tuple consisting of a time struct and an int containing\nthe number of microseconds based on the input string and the\nformat string.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strptime_datetime", 
  "doc": "Return a class cls instance based on the input string and the\nformat string.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strptime_time", 
  "doc": "Return a time struct based on the input string and the\nformat string.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/_strptime.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_thread_allocate_lock", 
  "doc": "allocate_lock() -> lock object\n(allocate() is an obsolete synonym)\n\nCreate a new lock object.  See help(LockType) for information about locks.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Calendar printing functions\n\nNote when comparing these calendars to the ones printed by cal(1): By\ndefault, these calendars have Monday as the first day of the week, and\nSunday as the last (the European convention). Use setfirstweekday() to\nset the first day of the week (0=Monday, 6=Sunday).", 
  "line": 0, 
  "type": "module", 
  "name": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py"
 }, 
 {
  "name": "datetime_date", 
  "doc": "date(year, month, day) --> date object", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "datetime_timedelta", 
  "doc": "Difference between two datetime values.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "datetime_timezone", 
  "doc": "Fixed offset from UTC implementation of tzinfo.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Locale support.\n\nThe module provides low-level access to the C lib's locale APIs\nand adds high level number formatting APIs as well as a locale\naliasing engine to complement these.\n\nThe aliasing engine includes support for many commonly used locale\nnames and maps them to values suitable for passing to the C lib's\nsetlocale() function. It also includes default encodings for all\nsupported locale names.", 
  "line": 0, 
  "type": "module", 
  "name": "locale", 
  "file": "/usr/lib/python3.2/locale.py"
 }, 
 {
  "name": "re_compile", 
  "doc": "Compile a regular expression pattern, returning a pattern object.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "re_escape", 
  "doc": "Escape all non-alphanumeric characters in pattern.", 
  "module": "_strptime", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "RLock", 
  "doc": null, 
  "module": "_threading_local", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_localimpl", 
  "doc": "A class managing thread-local dicts", 
  "module": "_threading_local", 
  "file": "/usr/lib/python3.2/_threading_local.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_patch", 
  "doc": null, 
  "module": "_threading_local", 
  "file": "/usr/lib/python3.2/contextlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "contextmanager", 
  "doc": "@contextmanager decorator.\n\nTypical usage:\n\n    @contextmanager\n    def some_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    with some_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>", 
  "module": "_threading_local", 
  "file": "/usr/lib/python3.2/contextlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "current_thread", 
  "doc": null, 
  "module": "_threading_local", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "local", 
  "doc": null, 
  "module": "_threading_local", 
  "file": "/usr/lib/python3.2/_threading_local.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ref", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "WeakSet", 
  "doc": null, 
  "module": "_weakrefset", 
  "file": "/usr/lib/python3.2/_weakrefset.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_IterationGuard", 
  "doc": null, 
  "module": "_weakrefset", 
  "file": "/usr/lib/python3.2/_weakrefset.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ref", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ABCMeta", 
  "doc": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).", 
  "module": "abc", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "WeakSet", 
  "doc": null, 
  "module": "abc", 
  "file": "/usr/lib/python3.2/_weakrefset.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "abstractclassmethod", 
  "doc": "A decorator indicating abstract classmethods.\n\nSimilar to abstractmethod.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractclassmethod\n        def my_abstract_classmethod(cls, ...):\n            ...", 
  "module": "abc", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "abstractmethod", 
  "doc": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...", 
  "module": "abc", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abstractproperty", 
  "doc": "A decorator indicating abstract properties.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract properties are overridden.\nThe abstract properties can be called using any of the normal\n'super' call mechanisms.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractproperty\n        def my_abstract_property(self):\n            ...\n\nThis defines a read-only property; you can also define a read-write\nabstract property using the 'long' form of property declaration:\n\n    class C(metaclass=ABCMeta):\n        def getx(self): ...\n        def setx(self, value): ...\n        x = abstractproperty(getx, setx)", 
  "module": "abc", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "abstractstaticmethod", 
  "doc": "A decorator indicating abstract staticmethods.\n\nSimilar to abstractmethod.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractstaticmethod\n        def my_abstract_staticmethod(...):\n            ...", 
  "module": "abc", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Aifc_read", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Aifc_write", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Chunk", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/chunk.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_read_float", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_read_long", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_read_short", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_read_string", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_read_ulong", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_read_ushort", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_float", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_long", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_short", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_string", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_ulong", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_ushort", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "open", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "openfp", 
  "doc": null, 
  "module": "aifc", 
  "file": "/usr/lib/python3.2/aifc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "name": "Action", 
  "doc": "Information about how to convert command line strings to Python objects.\n\nAction objects are used by an ArgumentParser to represent the information\nneeded to parse a single argument from one or more strings from the\ncommand line. The keyword arguments to the Action constructor are also\nall attributes of Action instances.\n\nKeyword Arguments:\n\n    - option_strings -- A list of command-line option strings which\n        should be associated with this action.\n\n    - dest -- The name of the attribute to hold the created object(s)\n\n    - nargs -- The number of command-line arguments that should be\n        consumed. By default, one argument will be consumed and a single\n        value will be produced.  Other values include:\n            - N (an integer) consumes N arguments (and produces a list)\n            - '?' consumes zero or one arguments\n            - '*' consumes zero or more arguments (and produces a list)\n            - '+' consumes one or more arguments (and produces a list)\n        Note that the difference between the default and nargs=1 is that\n        with the default, a single value will be produced, while with\n        nargs=1, a list containing a single value will be produced.\n\n    - const -- The value to be produced if the option is specified and the\n        option uses an action that takes no values.\n\n    - default -- The value to be produced if the option is not specified.\n\n    - type -- The type which the command-line arguments should be converted\n        to, should be one of 'string', 'int', 'float', 'complex' or a\n        callable object that accepts a single string argument. If None,\n        'string' is assumed.\n\n    - choices -- A container of values that should be allowed. If not None,\n        after a command-line argument has been converted to the appropriate\n        type, an exception will be raised if it is not a member of this\n        collection.\n\n    - required -- True if the action must always be specified at the\n        command line. This is only meaningful for optional command-line\n        arguments.\n\n    - help -- The help string describing the argument.\n\n    - metavar -- The name to be used for the option's argument with the\n        help string. If None, the 'dest' value will be used as the name.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ArgumentDefaultsHelpFormatter", 
  "doc": "Help message formatter which adds default values to argument help.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ArgumentError", 
  "doc": "An error from creating or using an argument (optional or positional).\n\nThe string value of this exception is the message, augmented with\ninformation about the argument that caused it.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ArgumentParser", 
  "doc": "Object for parsing command line strings into Python objects.\n\nKeyword Arguments:\n    - prog -- The name of the program (default: sys.argv[0])\n    - usage -- A usage message (default: auto-generated from arguments)\n    - description -- A description of what the program does\n    - epilog -- Text following the argument descriptions\n    - parents -- Parsers whose arguments should be copied into this one\n    - formatter_class -- HelpFormatter class for printing help messages\n    - prefix_chars -- Characters that prefix optional arguments\n    - fromfile_prefix_chars -- Characters that prefix files containing\n        additional arguments\n    - argument_default -- The default value for all arguments\n    - conflict_handler -- String indicating how to handle conflicts\n    - add_help -- Add a -h/-help option", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ArgumentTypeError", 
  "doc": "An error from trying to convert a command line string to a type.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FileType", 
  "doc": "Factory for creating file object types\n\nInstances of FileType are typically passed as type= arguments to the\nArgumentParser add_argument() method.\n\nKeyword Arguments:\n    - mode -- A string indicating how the file is to be opened. Accepts the\n        same values as the builtin open() function.\n    - bufsize -- The file's desired buffer size. Accepts the same values as\n        the builtin open() function.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HelpFormatter", 
  "doc": "Formatter for generating usage messages and argument help strings.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Namespace", 
  "doc": "Simple object for storing attributes.\n\nImplements equality by attribute names and values, and provides a simple\nstring representation.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RawDescriptionHelpFormatter", 
  "doc": "Help message formatter which retains any formatting in descriptions.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RawTextHelpFormatter", 
  "doc": "Help message formatter which retains formatting of all help text.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ActionsContainer", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_AppendAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_AppendConstAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_ArgumentGroup", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_AttributeHolder", 
  "doc": "Abstract base class that provides __repr__.\n\nThe __repr__ method returns a string in the format::\n    ClassName(attr=name, attr=name, ...)\nThe attributes are determined either by a class-level attribute,\n'_kwarg_names', or by inspecting the instance __dict__.", 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_CountAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_HelpAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_MutuallyExclusiveGroup", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StoreAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StoreConstAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StoreFalseAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StoreTrueAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_SubParsersAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_VersionAction", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "doc": "Generic (shallow and deep) copying operations.\n\nInterface summary:\n\n        import copy\n\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\n\nFor module specific errors, copy.Error is raised.\n\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\n\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\n\nPython's deep copy operation avoids these problems by:\n\n a) keeping a table of objects already copied during the current\n    copying pass\n\n b) letting user-defined classes override the copying operation or the\n    set of components copied\n\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\n\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods.", 
  "line": 0, 
  "type": "module", 
  "name": "_copy", 
  "file": "/usr/lib/python3.2/copy.py"
 }, 
 {
  "name": "_ensure_value", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_action_name", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/argparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "_os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "_re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "doc": "Text wrapping and filling.", 
  "line": 0, 
  "type": "module", 
  "name": "_textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py"
 }, 
 {
  "name": "ngettext", 
  "doc": null, 
  "module": "argparse", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "AST", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Add", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "And", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Assert", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Assign", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Attribute", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "AugAssign", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "AugLoad", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "AugStore", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BinOp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BitAnd", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BitOr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BitXor", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BoolOp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Break", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Bytes", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Call", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ClassDef", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Compare", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Continue", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Del", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Delete", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Dict", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DictComp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Div", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Ellipsis", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Eq", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ExceptHandler", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Expr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Expression", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ExtSlice", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FloorDiv", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "For", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FunctionDef", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "GeneratorExp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Global", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Gt", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "GtE", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "If", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IfExp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Import", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ImportFrom", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "In", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Index", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Interactive", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Invert", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Is", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IsNot", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LShift", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Lambda", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "List", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ListComp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Load", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Lt", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LtE", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Mod", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Module", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Mult", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Name", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NodeTransformer", 
  "doc": "A :class:`NodeVisitor` subclass that walks the abstract syntax tree and\nallows modification of nodes.\n\nThe `NodeTransformer` will walk the AST and use the return value of the\nvisitor methods to replace or remove the old node.  If the return value of\nthe visitor method is ``None``, the node will be removed from its location,\notherwise it is replaced with the return value.  The return value may be the\noriginal node in which case no replacement takes place.\n\nHere is an example transformer that rewrites all occurrences of name lookups\n(``foo``) to ``data['foo']``::\n\n   class RewriteName(NodeTransformer):\n\n       def visit_Name(self, node):\n           return copy_location(Subscript(\n               value=Name(id='data', ctx=Load()),\n               slice=Index(value=Str(s=node.id)),\n               ctx=node.ctx\n           ), node)\n\nKeep in mind that if the node you're operating on has child nodes you must\neither transform the child nodes yourself or call the :meth:`generic_visit`\nmethod for the node first.\n\nFor nodes that were part of a collection of statements (that applies to all\nstatement nodes), the visitor may also return a list of nodes rather than\njust a single node.\n\nUsually you use the transformer like this::\n\n   node = YourTransformer().visit(node)", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NodeVisitor", 
  "doc": "A node visitor base class that walks the abstract syntax tree and calls a\nvisitor function for every node found.  This function may return a value\nwhich is forwarded by the `visit` method.\n\nThis class is meant to be subclassed, with the subclass adding visitor\nmethods.\n\nPer default the visitor functions for the nodes are ``'visit_'`` +\nclass name of the node.  So a `TryFinally` node visit function would\nbe `visit_TryFinally`.  This behavior can be changed by overriding\nthe `visit` method.  If no visitor function exists for a node\n(return value `None`) the `generic_visit` visitor is used instead.\n\nDon't use the `NodeVisitor` if you want to apply changes to nodes during\ntraversing.  For this a special visitor exists (`NodeTransformer`) that\nallows modifications.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Nonlocal", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Not", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NotEq", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NotIn", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Num", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Or", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Param", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Pass", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Pow", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RShift", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Raise", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Return", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Set", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SetComp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Slice", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Starred", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Store", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Str", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Sub", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Subscript", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Suite", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TryExcept", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TryFinally", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Tuple", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UAdd", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "USub", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnaryOp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "While", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "With", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Yield", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "alias", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "arg", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "arguments", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "boolop", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "cmpop", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "comprehension", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "copy_location", 
  "doc": "Copy source location (`lineno` and `col_offset` attributes) from\n*old_node* to *new_node* if possible, and return *new_node*.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dump", 
  "doc": "Return a formatted dump of the tree in *node*.  This is mainly useful for\ndebugging purposes.  The returned string will show the names and the values\nfor fields.  This makes the code impossible to evaluate, so if evaluation is\nwanted *annotate_fields* must be set to False.  Attributes such as line\nnumbers and column offsets are not dumped by default.  If this is wanted,\n*include_attributes* can be set to True.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "excepthandler", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "expr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "expr_context", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "fix_missing_locations", 
  "doc": "When you compile a node tree with compile(), the compiler expects lineno and\ncol_offset attributes for every node that supports them.  This is rather\ntedious to fill in for generated nodes, so this helper adds these attributes\nrecursively where not already set, by setting them to the values of the\nparent node.  It works recursively starting at *node*.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_docstring", 
  "doc": "Return the docstring for the given node or None if no docstring can\nbe found.  If the node provided does not have docstrings a TypeError\nwill be raised.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "increment_lineno", 
  "doc": "Increment the line number of each node in the tree starting at *node* by *n*.\nThis is useful to \"move code\" to a different location in a file.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iter_child_nodes", 
  "doc": "Yield all direct child nodes of *node*, that is, all fields that are nodes\nand all items of fields that are lists of nodes.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iter_fields", 
  "doc": "Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``\nthat is present on *node*.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "keyword", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "literal_eval", 
  "doc": "Safely evaluate an expression node or a string containing a Python\nexpression.  The string or node provided may only consist of the following\nPython literal structures: strings, bytes, numbers, tuples, lists, dicts,\nsets, booleans, and None.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mod", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "operator", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "parse", 
  "doc": "Parse the source into an AST node.\nEquivalent to compile(source, filename, mode, PyCF_ONLY_AST).", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "slice", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "stmt", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "unaryop", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "walk", 
  "doc": "Recursively yield all descendant nodes in the tree starting at *node*\n(including *node* itself), in no specified order.  This is useful if you\nonly want to modify nodes in place and don't care about the context.", 
  "module": "ast", 
  "file": "/usr/lib/python3.2/ast.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "async_chat", 
  "doc": "This is an abstract class.  You must derive from this class, and add\nthe two methods collect_incoming_data() and found_terminator()", 
  "module": "asynchat", 
  "file": "/usr/lib/python3.2/asynchat.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Basic infrastructure for asynchronous socket service clients and servers.\n\nThere are only two ways to have a program on a single processor do \"more\nthan one thing at a time\".  Multi-threaded programming is the simplest and\nmost popular way to do it, but there is another very different technique,\nthat lets you have nearly all the advantages of multi-threading, without\nactually using multiple threads. it's really only practical if your program\nis largely I/O bound. If your program is CPU bound, then pre-emptive\nscheduled threads are probably what you really need. Network servers are\nrarely CPU-bound, however.\n\nIf your operating system supports the select() system call in its I/O\nlibrary (and nearly all do), then you can use it to juggle multiple\ncommunication channels at once; doing other work while your I/O is taking\nplace in the \"background.\"  Although this strategy can seem strange and\ncomplex, especially at first, it is in many ways easier to understand and\ncontrol than multi-threaded programming. The module documented here solves\nmany of the difficult problems for you, making the task of building\nsophisticated high-performance network servers and clients a snap.", 
  "line": 0, 
  "type": "module", 
  "name": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py"
 }, 
 {
  "name": "buffer", 
  "doc": null, 
  "module": "asynchat", 
  "file": "/usr/lib/python3.2/asynchat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "deque", 
  "doc": "deque(iterable[, maxlen]) --> deque object\n\nBuild an ordered collection with optimized access from its endpoints.", 
  "module": "asynchat", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "fifo", 
  "doc": null, 
  "module": "asynchat", 
  "file": "/usr/lib/python3.2/asynchat.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "find_prefix_at_end", 
  "doc": null, 
  "module": "asynchat", 
  "file": "/usr/lib/python3.2/asynchat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "simple_producer", 
  "doc": null, 
  "module": "asynchat", 
  "file": "/usr/lib/python3.2/asynchat.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "name": "ExitNow", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_exception", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strerror", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "close_all", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compact_traceback", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dispatcher", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dispatcher_with_send", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module performs file control and I/O control on file \ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.", 
  "line": 0, 
  "type": "module", 
  "name": "fcntl", 
  "file": null
 }, 
 {
  "name": "file_dispatcher", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "file_wrapper", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "loop", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "poll", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "poll2", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "poll3", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "readwrite", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module supports asynchronous I/O on multiple file descriptors.\n\n*** IMPORTANT NOTICE ***\nOn Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors.", 
  "line": 0, 
  "type": "module", 
  "name": "select", 
  "file": null
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "write", 
  "doc": null, 
  "module": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_translate", 
  "doc": null, 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b16decode", 
  "doc": "Decode a Base16 encoded byte string.\n\ns is the byte string to decode.  Optional casefold is a flag\nspecifying whether a lowercase alphabet is acceptable as input.\nFor security purposes, the default is False.\n\nThe decoded byte string is returned.  binascii.Error is raised if\ns were incorrectly padded or if there are non-alphabet characters\npresent in the string.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b16encode", 
  "doc": "Encode a byte string using Base16.\n\ns is the byte string to encode.  The encoded byte string is returned.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b32decode", 
  "doc": "Decode a Base32 encoded byte string.\n\ns is the byte string to decode.  Optional casefold is a flag\nspecifying whether a lowercase alphabet is acceptable as input.\nFor security purposes, the default is False.\n\nRFC 3548 allows for optional mapping of the digit 0 (zero) to the\nletter O (oh), and for optional mapping of the digit 1 (one) to\neither the letter I (eye) or letter L (el).  The optional argument\nmap01 when not None, specifies which letter the digit 1 should be\nmapped to (when map01 is not None, the digit 0 is always mapped to\nthe letter O).  For security purposes the default is None, so that\n0 and 1 are not allowed in the input.\n\nThe decoded byte string is returned.  binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet\ncharacters present in the input.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b32encode", 
  "doc": "Encode a byte string using Base32.\n\ns is the byte string to encode.  The encoded byte string is returned.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b64decode", 
  "doc": "Decode a Base64 encoded byte string.\n\ns is the byte string to decode.  Optional altchars must be a\nstring of length 2 which specifies the alternative alphabet used\ninstead of the '+' and '/' characters.\n\nThe decoded string is returned.  A binascii.Error is raised if s is\nincorrectly padded.\n\nIf validate is False (the default), non-base64-alphabet characters are\ndiscarded prior to the padding check.  If validate is True,\nnon-base64-alphabet characters in the input result in a binascii.Error.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b64encode", 
  "doc": "Encode a byte string using Base64.\n\ns is the byte string to encode.  Optional altchars must be a byte\nstring of length 2 which specifies an alternative alphabet for the\n'+' and '/' characters.  This allows an application to\ne.g. generate url or filesystem safe Base64 strings.\n\nThe encoded byte string is returned.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Conversion between binary data and ASCII", 
  "line": 0, 
  "type": "module", 
  "name": "binascii", 
  "file": null
 }, 
 {
  "name": "decode", 
  "doc": "Decode a file; input and output are binary files.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decodebytes", 
  "doc": "Decode a bytestring of base-64 data into a bytestring.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decodestring", 
  "doc": "Legacy alias of decodebytes().", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "Encode a file; input and output are binary files.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encodebytes", 
  "doc": "Encode a bytestring into a bytestring containing multiple lines\nof base-64 data.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encodestring", 
  "doc": "Legacy alias of encodebytes().", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": "Small main program", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "standard_b64decode", 
  "doc": "Decode a byte string encoded with the standard Base64 alphabet.\n\ns is the byte string to decode.  The decoded byte string is\nreturned.  binascii.Error is raised if the input is incorrectly\npadded or if there are non-alphabet characters present in the\ninput.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "standard_b64encode", 
  "doc": "Encode a byte string using the standard Base64 alphabet.\n\ns is the byte string to encode.  The encoded byte string is returned.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "urlsafe_b64decode", 
  "doc": "Decode a byte string encoded with the standard Base64 alphabet.\n\ns is the byte string to decode.  The decoded byte string is\nreturned.  binascii.Error is raised if the input is incorrectly\npadded or if there are non-alphabet characters present in the\ninput.\n\nThe alphabet uses '-' instead of '+' and '_' instead of '/'.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "urlsafe_b64encode", 
  "doc": "Encode a byte string using a url-safe Base64 alphabet.\n\ns is the byte string to encode.  The encoded byte string is\nreturned.  The alphabet uses '-' instead of '+' and '_' instead of\n'/'.", 
  "module": "base64", 
  "file": "/usr/lib/python3.2/base64.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Bdb", 
  "doc": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.", 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BdbQuit", 
  "doc": "Exception to give up completely.", 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Breakpoint", 
  "doc": "Breakpoint class.\n\nImplements temporary breakpoints, ignore counts, disabling and\n(re)-enabling, and conditionals.\n\nBreakpoints are indexed by number through bpbynumber and by\nthe file,line tuple using bplist.  The former points to a\nsingle instance of class Breakpoint.  The latter points to a\nlist of such instances since there may be more than one\nbreakpoint per line.", 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Tdb", 
  "doc": null, 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "bar", 
  "doc": null, 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "checkfuncname", 
  "doc": "Check whether we should break here because of `b.funcname`.", 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "effective", 
  "doc": "Determine which breakpoint for this file:line is to be acted upon.\n\nCalled only if we know there is a bpt at this\nlocation.  Returns breakpoint that was triggered and a flag\nthat indicates if it is ok to delete a temporary bp.", 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Filename matching with shell patterns.\n\nfnmatch(FILENAME, PATTERN) matches according to the local convention.\nfnmatchcase(FILENAME, PATTERN) always takes case in account.\n\nThe functions operate by translating the pattern into a regular\nexpression.  They cache the compiled regular expressions for speed.\n\nThe function translate(PATTERN) returns a regular expression\ncorresponding to PATTERN.  (It does not compile it.)", 
  "line": 0, 
  "type": "module", 
  "name": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py"
 }, 
 {
  "name": "foo", 
  "doc": null, 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "set_trace", 
  "doc": null, 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BinHex", 
  "doc": null, 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FInfo", 
  "doc": null, 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HexBin", 
  "doc": null, 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Hqxcoderengine", 
  "doc": "Write data to the coder in 3-byte chunks", 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Hqxdecoderengine", 
  "doc": "Read data via the decoder in 4-byte chunks", 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Rlecoderengine", 
  "doc": "Write data to the RLE-coder in suitably large chunks", 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Rledecoderengine", 
  "doc": "Read data via the RLE-coder", 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Conversion between binary data and ASCII", 
  "line": 0, 
  "type": "module", 
  "name": "binascii", 
  "file": null
 }, 
 {
  "name": "binhex", 
  "doc": "binhex(infilename, outfilename): create binhex-encoded copy of a file", 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getfileinfo", 
  "doc": null, 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "hexbin", 
  "doc": "hexbin(infilename, outfilename) - Decode binhexed file", 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "openrsrc", 
  "doc": null, 
  "module": "binhex", 
  "file": "/usr/lib/python3.2/binhex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "bisect", 
  "doc": "Alias for bisect_right().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bisect_left", 
  "doc": "bisect_left(a, x[, lo[, hi]]) -> index\n\nReturn the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e < x, and all e in\na[i:] have e >= x.  So if x already appears in the list, i points just\nbefore the leftmost x already there.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bisect_right", 
  "doc": "bisect_right(a, x[, lo[, hi]]) -> index\n\nReturn the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e <= x, and all e in\na[i:] have e > x.  So if x already appears in the list, i points just\nbeyond the rightmost x already there\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "insort", 
  "doc": "Alias for insort_right().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "insort_left", 
  "doc": "insort_left(a, x[, lo[, hi]])\n\nInsert item x in list a, and keep it sorted assuming a is sorted.\n\nIf x is already in a, insert it to the left of the leftmost x.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "insort_right", 
  "doc": "insort_right(a, x[, lo[, hi]])\n\nInsert item x in list a, and keep it sorted assuming a is sorted.\n\nIf x is already in a, insert it to the right of the rightmost x.\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Profile", 
  "doc": "Profile(custom_timer=None, time_unit=None, subcalls=True, builtins=True)\n\nBuilds a profiler object using the specified timer function.\nThe default timer is a fast built-in one based on real time.\nFor custom timer functions returning integers, time_unit can\nbe a float specifying a scale (i.e. how long each integer unit\nis, in seconds).", 
  "module": "cProfile", 
  "file": "/usr/lib/python3.2/cProfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Fast profiler", 
  "line": 0, 
  "type": "module", 
  "name": "_lsprof", 
  "file": "/usr/lib/python3.2/lib-dynload/_lsprof.cpython-32mu.so"
 }, 
 {
  "name": "label", 
  "doc": null, 
  "module": "cProfile", 
  "file": "/usr/lib/python3.2/cProfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "cProfile", 
  "file": "/usr/lib/python3.2/cProfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "run", 
  "doc": "Run statement under profiler optionally saving results in filename\n\nThis function takes a single argument that can be passed to the\n\"exec\" statement, and an optional file name.  In all cases this\nroutine attempts to \"exec\" its first argument and gather profiling\nstatistics from the execution. If no file name is present, then this\nfunction automatically prints a simple profiling report, sorted by the\nstandard name string (file/line/function-name) that is presented in\neach line.", 
  "module": "cProfile", 
  "file": "/usr/lib/python3.2/cProfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "runctx", 
  "doc": "Run statement under profiler, supplying your own globals and locals,\noptionally saving results in filename.\n\nstatement and filename have the same semantics as profile.run", 
  "module": "cProfile", 
  "file": "/usr/lib/python3.2/cProfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Calendar", 
  "doc": "Base calendar class. This class doesn't do any formatting. It simply\nprovides data to subclasses.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HTMLCalendar", 
  "doc": "This calendar returns complete HTML pages.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IllegalMonthError", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IllegalWeekdayError", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LocaleHTMLCalendar", 
  "doc": "This class can be passed a locale name in the constructor and will return\nmonth and weekday names in the specified locale. If this locale includes\nan encoding all strings containing month and weekday names will be returned\nas unicode.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LocaleTextCalendar", 
  "doc": "This class can be passed a locale name in the constructor and will return\nmonth and weekday names in the specified locale. If this locale includes\nan encoding all strings containing month and weekday names will be returned\nas unicode.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextCalendar", 
  "doc": "Subclass of Calendar that outputs a calendar as a simple plain text\nsimilar to the UNIX program cal.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Locale support.\n\nThe module provides low-level access to the C lib's locale APIs\nand adds high level number formatting APIs as well as a locale\naliasing engine to complement these.\n\nThe aliasing engine includes support for many commonly used locale\nnames and maps them to values suitable for passing to the C lib's\nsetlocale() function. It also includes default encodings for all\nsupported locale names.", 
  "line": 0, 
  "type": "module", 
  "name": "_locale", 
  "file": "/usr/lib/python3.2/locale.py"
 }, 
 {
  "name": "_localized_day", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_localized_month", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "calendar", 
  "doc": "Returns a year's calendar as a multi-line string.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Fast implementation of the datetime type.", 
  "line": 0, 
  "type": "module", 
  "name": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py"
 }, 
 {
  "name": "different_locale", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": "Inappropriate argument value (of correct type).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "firstweekday", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "Prints multi-column formatting for year calendars", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "formatstring", 
  "doc": "Returns a string formatted from n strings, centered within n columns.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isleap", 
  "doc": "Return True for leap years, False for non-leap years.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "leapdays", 
  "doc": "Return number of leap years in range [y1, y2).\nAssume y1 <= y2.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "month", 
  "doc": "Return a month's calendar string (multi-line).", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "monthcalendar", 
  "doc": "Return a matrix representing a month's calendar.\nEach row represents a week; days outside this month are zero.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "monthrange", 
  "doc": "Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for\nyear, month.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "prcal", 
  "doc": "Print a year's calendar.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "prmonth", 
  "doc": "Print a month's calendar.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "prweek", 
  "doc": "Print a single week (no newline).", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setfirstweekday", 
  "doc": null, 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "timegm", 
  "doc": "Unrelated but handy function to calculate Unix timestamp from GMT.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "week", 
  "doc": "Returns a single week in a string (no newline).", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "weekday", 
  "doc": "Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),\nday (1-31).", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "weekheader", 
  "doc": "Return a header for a week.", 
  "module": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BytesIO", 
  "doc": "BytesIO([buffer]) -> object\n\nCreate a buffered I/O implementation using an in-memory bytes\nbuffer, ready for reading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FeedParser", 
  "doc": "A feed-style parser of email.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/email/feedparser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FieldStorage", 
  "doc": "Store a sequence of fields, reading multipart/form-data.\n\nThis class provides naming, typing, files stored on disk, and\nmore.  At the top level, it is accessible like a dictionary, whose\nkeys are the field names.  (Note: None can occur as a field name.)\nThe items are either a Python list (if there's multiple values) or\nanother FieldStorage or MiniFieldStorage object.  If it's a single\nobject, it has the following attributes:\n\nname: the field name, if specified; otherwise None\n\nfilename: the filename, if specified; otherwise None; this is the\n    client side filename, *not* the file name on which it is\n    stored (that's a temporary file you don't deal with)\n\nvalue: the value as a *string*; for file uploads, this\n    transparently reads the file every time you request the value\n    and returns *bytes*\n\nfile: the file(-like) object from which you can read the data *as\n    bytes* ; None if the data is stored a simple string\n\ntype: the content-type, or None if not specified\n\ntype_options: dictionary of options specified on the content-type\n    line\n\ndisposition: content-disposition, or None if not specified\n\ndisposition_options: dictionary of corresponding options\n\nheaders: a dictionary(-like) object (sometimes email.message.Message or a\n    subclass thereof) containing *all* headers\n\nThe class is subclassable, mostly for the purpose of overriding\nthe make_file() method, which is called internally to come up with\na file open for reading and writing.  This makes it possible to\noverride the default choice of storing all files in a temporary\ndirectory and unlinking them as soon as they have been opened.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MiniFieldStorage", 
  "doc": "Like FieldStorage, for use when no file uploads are possible.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextIOWrapper", 
  "doc": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding.\n\nerrors determines the strictness of encoding and decoding (see the\ncodecs.register) and defaults to \"strict\".\n\nnewline can be None, '', '\\n', '\\r', or '\\r\\n'.  It controls the\nhandling of line endings. If it is None, universal newlines is\nenabled.  With this enabled, on input, the lines endings '\\n', '\\r',\nor '\\r\\n' are translated to '\\n' before being returned to the\ncaller. Conversely, on output, '\\n' is translated to the system\ndefault line seperator, os.linesep. If newline is any other of its\nlegal values, that newline becomes the newline when the file is read\nand it is returned untranslated. On output, '\\n' is converted to the\nnewline.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_parseparam", 
  "doc": null, 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dolog", 
  "doc": "Write a log message to the log file.  See initlog() for docs.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "escape", 
  "doc": "Deprecated API.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "General functions for HTML manipulation.", 
  "line": 0, 
  "type": "module", 
  "name": "html", 
  "file": "/usr/lib/python3.2/html/__init__.py"
 }, 
 {
  "name": "initlog", 
  "doc": "Write a log message, if there is a log file.\n\nEven though this function is called initlog(), you should always\nuse log(); log is a variable that is set either to initlog\n(initially), to dolog (once the log file has been opened), or to\nnolog (when logging is disabled).\n\nThe first argument is a format string; the remaining arguments (if\nany) are arguments to the % operator, so e.g.\n    log(\"%s: %s\", \"a\", \"b\")\nwill write \"a: b\" to the log file, followed by a newline.\n\nIf the global logfp is not None, it should be a file object to\nwhich log data is written.\n\nIf the global logfp is None, the global logfile may be a string\ngiving a filename to open, in append mode.  This file should be\nworld writable!!!  If the file can't be opened, logging is\nsilently disabled (since there is no safe place where we could\nsend an error message).", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Locale support.\n\nThe module provides low-level access to the C lib's locale APIs\nand adds high level number formatting APIs as well as a locale\naliasing engine to complement these.\n\nThe aliasing engine includes support for many commonly used locale\nnames and maps them to values suitable for passing to the C lib's\nsetlocale() function. It also includes default encodings for all\nsupported locale names.", 
  "line": 0, 
  "type": "module", 
  "name": "locale", 
  "file": "/usr/lib/python3.2/locale.py"
 }, 
 {
  "name": "log", 
  "doc": "Write a log message, if there is a log file.\n\nEven though this function is called initlog(), you should always\nuse log(); log is a variable that is set either to initlog\n(initially), to dolog (once the log file has been opened), or to\nnolog (when logging is disabled).\n\nThe first argument is a format string; the remaining arguments (if\nany) are arguments to the % operator, so e.g.\n    log(\"%s: %s\", \"a\", \"b\")\nwill write \"a: b\" to the log file, followed by a newline.\n\nIf the global logfp is not None, it should be a file object to\nwhich log data is written.\n\nIf the global logfp is None, the global logfile may be a string\ngiving a filename to open, in append mode.  This file should be\nworld writable!!!  If the file can't be opened, logging is\nsilently disabled (since there is no safe place where we could\nsend an error message).", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nolog", 
  "doc": "Dummy function, assigned to log when logging is disabled.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "parse", 
  "doc": "Parse a query in the environment or from a file (default stdin)\n\nArguments, all optional:\n\nfp              : file pointer; default: sys.stdin.buffer\n\nenviron         : environment dictionary; default: os.environ\n\nkeep_blank_values: flag indicating whether blank values in\n    percent-encoded forms should be treated as blank strings.\n    A true value indicates that blanks should be retained as\n    blank strings.  The default false value indicates that\n    blank values are to be ignored and treated as if they were\n    not included.\n\nstrict_parsing: flag indicating what to do with parsing errors.\n    If false (the default), errors are silently ignored.\n    If true, errors raise a ValueError exception.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_header", 
  "doc": "Parse a Content-type like header.\n\nReturn the main content-type and a dictionary of options.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_multipart", 
  "doc": "Parse multipart input.\n\nArguments:\nfp   : input file\npdict: dictionary containing other parameters of content-type header\n\nReturns a dictionary just like parse_qs(): keys are the field names, each\nvalue is a list of values for that field.  This is easy to use but not\nmuch good if you are expecting megabytes to be uploaded -- in that case,\nuse the FieldStorage class instead which is much more flexible.  Note\nthat content-type is the raw, unparsed contents of the content-type\nheader.\n\nXXX This does not parse nested multipart parts -- use FieldStorage for\nthat.\n\nXXX This should really be subsumed by FieldStorage altogether -- no\npoint in having two implementations of the same parsing algorithm.\nAlso, FieldStorage protects itself better against certain DoS attacks\nby limiting the size of the data read in one chunk.  The API here\ndoes not support that kind of protection.  This also affects parse()\nsince it can call parse_multipart().", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_qs", 
  "doc": "Parse a query given as a string argument.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_qsl", 
  "doc": "Parse a query given as a string argument.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_arguments", 
  "doc": null, 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_directory", 
  "doc": "Dump the current directory as HTML.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_environ", 
  "doc": "Dump the shell environment as HTML.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_environ_usage", 
  "doc": "Dump a list of environment variables used by CGI as HTML.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_exception", 
  "doc": null, 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_form", 
  "doc": "Dump the contents of a form as HTML.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Temporary files.\n\nThis module provides generic, low- and high-level interfaces for\ncreating temporary files and directories.  The interfaces listed\nas \"safe\" just below can be used without fear of race conditions.\nThose listed as \"unsafe\" cannot, and are provided for backward\ncompatibility only.\n\nThis module also provides some data items to the user:\n\n  TMP_MAX  - maximum number of names that will be tried before\n             giving up.\n  template - the default prefix for all temporary names.\n             You may change this to control the default prefix.\n  tempdir  - If this is set to a string before the first use of\n             any routine from this module, it will be considered as\n             another candidate location to store temporary files.", 
  "line": 0, 
  "type": "module", 
  "name": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py"
 }, 
 {
  "name": "test", 
  "doc": "Robust test CGI script, usable as main program.\n\nWrite minimal HTTP headers and dump all information provided to\nthe script in HTML form.", 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "urllib", 
  "file": "/usr/lib/python3.2/urllib/__init__.py"
 }, 
 {
  "name": "valid_boundary", 
  "doc": null, 
  "module": "cgi", 
  "file": "/usr/lib/python3.2/cgi.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "warn", 
  "doc": "Issue a warning, or maybe ignore it or raise an exception.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Hook", 
  "doc": "A hook to replace sys.excepthook that shows tracebacks in HTML.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "enable", 
  "doc": "Install an exception handler that formats tracebacks as HTML.\n\nThe optional argument 'display' can be set to 0 to suppress sending the\ntraceback to the browser, and 'logdir' can be set to a directory to cause\ntracebacks to be written to files there.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "grey", 
  "doc": null, 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "handler", 
  "doc": null, 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "html", 
  "doc": "Return a nice HTML document describing a given traceback.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "doc": "Keywords (from \"graminit.c\")\n\nThis file is automatically generated; please don't muck it up!\n\nTo update the symbols in this file, 'cd' to the top directory of\nthe python source tree after building the interpreter and run:\n\n    ./python Lib/keyword.py", 
  "line": 0, 
  "type": "module", 
  "name": "keyword", 
  "file": "/usr/lib/python3.2/keyword.py"
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "lookup", 
  "doc": "Find the value for a given name in the given environment.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Generate Python documentation in HTML or text for interactive use.\n\nIn the Python interpreter, do \"from pydoc import help\" to provide online\nhelp.  Calling help(thing) on a Python object documents the object.\n\nOr, at the shell command line outside of Python:\n\nRun \"pydoc <name>\" to show documentation on something.  <name> may be\nthe name of a function, module, package, or a dotted reference to a\nclass or function within a module or module in a package.  If the\nargument contains a path segment delimiter (e.g. slash on Unix,\nbackslash on Windows) it is treated as the path to a Python source file.\n\nRun \"pydoc -k <keyword>\" to search for a keyword in the synopsis lines\nof all available modules.\n\nRun \"pydoc -p <port>\" to start an HTTP server on the given port on the\nlocal machine.  Port number 0 can be used to get an arbitrary unused port.\n\nRun \"pydoc -b\" to start an HTTP server on an arbitrary unused port and\nopen a Web browser to interactively browse documentation.  The -p option\ncan be used with the -b option to explicitly specify the server port.\n\nFor platforms without a command line, \"pydoc -g\" starts the HTTP server\nand also pops up a little window for controlling it.  This option is\ndeprecated, since the server can now be controlled directly from HTTP\nclients.\n\nRun \"pydoc -w <name>\" to write out the HTML documentation for a module\nto a file named \"<name>.html\".\n\nModule docs for core modules are assumed to be in\n\n    /usr/share/doc/pythonX.Y/html/library\n\nif the pythonX.Y-doc package is installed or in\n\n    http://docs.python.org/X.Y/library/\n\nThis can be overridden by setting the PYTHONDOCS environment variable\nto a different URL or to a local directory containing the Library\nReference Manual pages.", 
  "line": 0, 
  "type": "module", 
  "name": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py"
 }, 
 {
  "name": "reset", 
  "doc": "Return a string that resets the CGI and browser to a known state.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "scanvars", 
  "doc": "Scan one logical line of Python and look up values of variables used.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "small", 
  "doc": null, 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strong", 
  "doc": null, 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Temporary files.\n\nThis module provides generic, low- and high-level interfaces for\ncreating temporary files and directories.  The interfaces listed\nas \"safe\" just below can be used without fear of race conditions.\nThose listed as \"unsafe\" cannot, and are provided for backward\ncompatibility only.\n\nThis module also provides some data items to the user:\n\n  TMP_MAX  - maximum number of names that will be tried before\n             giving up.\n  template - the default prefix for all temporary names.\n             You may change this to control the default prefix.\n  tempdir  - If this is set to a string before the first use of\n             any routine from this module, it will be considered as\n             another candidate location to store temporary files.", 
  "line": 0, 
  "type": "module", 
  "name": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py"
 }, 
 {
  "name": "text", 
  "doc": "Return a plain text document describing a given traceback.", 
  "module": "cgitb", 
  "file": "/usr/lib/python3.2/cgitb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "doc": "Define names for built-in types that aren't directly accessible as a builtin.", 
  "line": 0, 
  "type": "module", 
  "name": "types", 
  "file": "/usr/lib/python3.2/types.py"
 }, 
 {
  "name": "Chunk", 
  "doc": null, 
  "module": "chunk", 
  "file": "/usr/lib/python3.2/chunk.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Cmd", 
  "doc": "A simple framework for writing line-oriented command interpreters.\n\nThese are often useful for test harnesses, administrative tools, and\nprototypes that will later be wrapped in a more sophisticated interface.\n\nA Cmd instance or subclass instance is a line-oriented interpreter\nframework.  There is no good reason to instantiate Cmd itself; rather,\nit's useful as a superclass of an interpreter class you define yourself\nin order to inherit Cmd's methods and encapsulate action methods.", 
  "module": "cmd", 
  "file": "/usr/lib/python3.2/cmd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "A collection of string constants.\n\nPublic module variables:\n\nwhitespace -- a string containing all ASCII whitespace\nascii_lowercase -- a string containing all ASCII lowercase letters\nascii_uppercase -- a string containing all ASCII uppercase letters\nascii_letters -- a string containing all ASCII letters\ndigits -- a string containing all ASCII decimal digits\nhexdigits -- a string containing all ASCII hexadecimal digits\noctdigits -- a string containing all ASCII octal digits\npunctuation -- a string containing all ASCII punctuation characters\nprintable -- a string containing all ASCII characters considered printable", 
  "line": 0, 
  "type": "module", 
  "name": "string", 
  "file": "/usr/lib/python3.2/string.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "CommandCompiler", 
  "doc": "Instances of this class have __call__ methods identical in\nsignature to compile_command; the difference is that if the\ninstance compiles program text containing a __future__ statement,\nthe instance 'remembers' and compiles all subsequent program texts\nwith the statement in force.", 
  "module": "code", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InteractiveConsole", 
  "doc": "Closely emulate the behavior of the interactive Python interpreter.\n\nThis class builds on InteractiveInterpreter and adds prompting\nusing the familiar sys.ps1 and sys.ps2, and input buffering.", 
  "module": "code", 
  "file": "/usr/lib/python3.2/code.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InteractiveInterpreter", 
  "doc": "Base class for InteractiveConsole.\n\nThis class deals with parsing and interpreter state (the user's\nnamespace); it doesn't deal with input buffering or prompting or\ninput file naming (the filename is always passed in explicitly).", 
  "module": "code", 
  "file": "/usr/lib/python3.2/code.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "compile_command", 
  "doc": "Compile a command and determine whether it is incomplete.\n\nArguments:\n\nsource -- the source string; may contain \\n characters\nfilename -- optional filename from which source was read; default\n            \"<input>\"\nsymbol -- optional grammar start symbol; \"single\" (default) or \"eval\"\n\nReturn value / exceptions raised:\n\n- Return a code object if the command is complete and valid\n- Return None if the command is incomplete\n- Raise SyntaxError, ValueError or OverflowError if the command is a\n  syntax error (OverflowError and ValueError can be produced by\n  malformed literals).", 
  "module": "code", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "interact", 
  "doc": "Closely emulate the interactive Python interpreter.\n\nThis is a backwards compatible interface to the InteractiveConsole\nclass.  When readfunc is not specified, it attempts to import the\nreadline module to enable GNU readline if it is available.\n\nArguments (all optional, all default to None):\n\nbanner -- passed to InteractiveConsole.interact()\nreadfunc -- if not None, replaces InteractiveConsole.raw_input()\nlocal -- passed to InteractiveInterpreter.__init__()", 
  "module": "code", 
  "file": "/usr/lib/python3.2/code.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "name": "BufferedIncrementalDecoder", 
  "doc": "This subclass of IncrementalDecoder can be used as the baseclass for an\nincremental decoder if the decoder must be able to handle incomplete\nbyte sequences.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedIncrementalEncoder", 
  "doc": "This subclass of IncrementalEncoder can be used as the baseclass for an\nincremental encoder if the encoder must keep some of the output in a\nbuffer between calls to encode().", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Codec", 
  "doc": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "CodecInfo", 
  "doc": null, 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "EncodedFile", 
  "doc": "Return a wrapped version of file which provides transparent\nencoding translation.\n\nStrings written to the wrapped file are interpreted according\nto the given data_encoding and then written to the original\nfile as string using file_encoding. The intermediate encoding\nwill usually be Unicode but depends on the specified codecs.\n\nStrings are read from the file using file_encoding and then\npassed back to the caller as string using data_encoding.\n\nIf file_encoding is not given, it defaults to data_encoding.\n\nerrors may be given to define the error handling. It defaults\nto 'strict' which causes ValueErrors to be raised in case an\nencoding error occurs.\n\nThe returned wrapped file object provides two extra attributes\n.data_encoding and .file_encoding which reflect the given\nparameters of the same name. The attributes can be used for\nintrospection by Python programs.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IncrementalDecoder", 
  "doc": "An IncrementalDecoder decodes an input in multiple steps. The input can\nbe passed piece by piece to the decode() method. The IncrementalDecoder\nremembers the state of the decoding process between calls to decode().", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IncrementalEncoder", 
  "doc": "An IncrementalEncoder encodes an input in multiple steps. The input can\nbe passed piece by piece to the encode() method. The IncrementalEncoder\nremembers the state of the encoding process between calls to encode().", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StreamReader", 
  "doc": null, 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StreamReaderWriter", 
  "doc": "StreamReaderWriter instances allow wrapping streams which\nwork in both read and write modes.\n\nThe design is such that one can use the factory functions\nreturned by the codec.lookup() function to construct the\ninstance.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StreamRecoder", 
  "doc": "StreamRecoder instances provide a frontend - backend\nview of encoding data.\n\nThey use the complete set of APIs returned by the\ncodecs.lookup() function to implement their task.\n\nData written to the stream is first decoded into an\nintermediate format (which is dependent on the given codec\ncombination) and then written to the stream using an instance\nof the provided Writer class.\n\nIn the other direction, data is read from the stream using a\nReader instance and then return encoded data to the caller.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StreamWriter", 
  "doc": null, 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ascii_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ascii_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "backslashreplace_errors", 
  "doc": "Implements the 'backslashreplace' error handling, which replaces an unencodable character with a backslashed escape sequence.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "charmap_build", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "charmap_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "charmap_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decode", 
  "doc": "decode(obj, [encoding[,errors]]) -> object\n\nDecodes obj using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na ValueError. Other possible values are 'ignore' and 'replace'\nas well as any other name registered with codecs.register_error that is\nable to handle ValueErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "encode(obj, [encoding[,errors]]) -> object\n\nEncodes obj using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na ValueError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle ValueErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "escape_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "escape_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getdecoder", 
  "doc": "Lookup up the codec for the given encoding and return\nits decoder function.\n\nRaises a LookupError in case the encoding cannot be found.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getencoder", 
  "doc": "Lookup up the codec for the given encoding and return\nits encoder function.\n\nRaises a LookupError in case the encoding cannot be found.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getincrementaldecoder", 
  "doc": "Lookup up the codec for the given encoding and return\nits IncrementalDecoder class or factory function.\n\nRaises a LookupError in case the encoding cannot be found\nor the codecs doesn't provide an incremental decoder.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getincrementalencoder", 
  "doc": "Lookup up the codec for the given encoding and return\nits IncrementalEncoder class or factory function.\n\nRaises a LookupError in case the encoding cannot be found\nor the codecs doesn't provide an incremental encoder.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getreader", 
  "doc": "Lookup up the codec for the given encoding and return\nits StreamReader class or factory function.\n\nRaises a LookupError in case the encoding cannot be found.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getwriter", 
  "doc": "Lookup up the codec for the given encoding and return\nits StreamWriter class or factory function.\n\nRaises a LookupError in case the encoding cannot be found.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ignore_errors", 
  "doc": "Implements the 'ignore' error handling, which ignores malformed data and continues.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iterdecode", 
  "doc": "Decoding iterator.\n\nDecodes the input strings from the iterator using a IncrementalDecoder.\n\nerrors and kwargs are passed through to the IncrementalDecoder\nconstructor.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iterencode", 
  "doc": "Encoding iterator.\n\nEncodes the input strings from the iterator using a IncrementalEncoder.\n\nerrors and kwargs are passed through to the IncrementalEncoder\nconstructor.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "latin_1_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "latin_1_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lookup", 
  "doc": "lookup(encoding) -> CodecInfo\n\nLooks up a codec tuple in the Python codec registry and returns\na CodecInfo object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lookup_error", 
  "doc": "lookup_error(errors) -> handler\n\nReturn the error handler for the specified error handling name\nor raise a LookupError, if no handler exists under this name.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "make_encoding_map", 
  "doc": "Creates an encoding map from a decoding map.\n\nIf a target mapping in the decoding map occurs multiple\ntimes, then that target is mapped to None (undefined mapping),\ncausing an exception when encountered by the charmap codec\nduring translation.\n\nOne example where this happens is cp875.py which decodes\nmultiple character to \u001a.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "make_identity_dict", 
  "doc": "make_identity_dict(rng) -> dict\n\nReturn a dictionary where elements of the rng sequence are\nmapped to themselves.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": "Open an encoded file using the given mode and return\na wrapped version providing transparent encoding/decoding.\n\nNote: The wrapped version will only accept the object format\ndefined by the codecs, i.e. Unicode objects for most builtin\ncodecs. Output is also codec dependent and will usually be\nUnicode as well.\n\nFiles are always opened in binary mode, even if no binary mode\nwas specified. This is done to avoid data loss due to encodings\nusing 8-bit values. The default file mode is 'rb' meaning to\nopen the file in binary read mode.\n\nencoding specifies the encoding which is to be used for the\nfile.\n\nerrors may be given to define the error handling. It defaults\nto 'strict' which causes ValueErrors to be raised in case an\nencoding error occurs.\n\nbuffering has the same meaning as for the builtin open() API.\nIt defaults to line buffered.\n\nThe returned wrapped file object provides an extra attribute\n.encoding which allows querying the used encoding. This\nattribute is only available if an encoding was specified as\nparameter.", 
  "module": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "raw_unicode_escape_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "raw_unicode_escape_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "readbuffer_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register", 
  "doc": "register(search_function)\n\nRegister a codec search function. Search functions are expected to take\none argument, the encoding name in all lower case letters, and return\na tuple of functions (encoder, decoder, stream_reader, stream_writer)\n(or a CodecInfo object).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_error", 
  "doc": "register_error(errors, handler)\n\nRegister the specified error handler under the name\nerrors. handler must be a callable object, that\nwill be called with an exception instance containing\ninformation about the location of the encoding/decoding\nerror and must return a (replacement, new position) tuple.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace_errors", 
  "doc": "Implements the 'replace' error handling, which replaces malformed data with a replacement marker.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strict_errors", 
  "doc": "Implements the 'strict' error handling, which raises a UnicodeError on coding errors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "unicode_escape_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_escape_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_internal_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_internal_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_be_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_be_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_ex_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_le_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_16_le_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_be_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_be_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_ex_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_le_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_32_le_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_7_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_7_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_8_decode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utf_8_encode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "xmlcharrefreplace_errors", 
  "doc": "Implements the 'xmlcharrefreplace' error handling, which replaces an unencodable character with the appropriate XML character reference.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "CommandCompiler", 
  "doc": "Instances of this class have __call__ methods identical in\nsignature to compile_command; the difference is that if the\ninstance compiles program text containing a __future__ statement,\nthe instance 'remembers' and compiles all subsequent program texts\nwith the statement in force.", 
  "module": "codeop", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Compile", 
  "doc": "Instances of this class behave much like the built-in compile\nfunction, but if one is used to compile text containing a future\nstatement, it \"remembers\" and compiles all subsequent program texts\nwith the statement in force.", 
  "module": "codeop", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Record of phased-in incompatible language changes.\n\nEach line is of the form:\n\n    FeatureName = \"_Feature(\" OptionalRelease \",\" MandatoryRelease \",\"\n                              CompilerFlag \")\"\n\nwhere, normally, OptionalRelease < MandatoryRelease, and both are 5-tuples\nof the same form as sys.version_info:\n\n    (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int\n     PY_MINOR_VERSION, # the 1; an int\n     PY_MICRO_VERSION, # the 0; an int\n     PY_RELEASE_LEVEL, # \"alpha\", \"beta\", \"candidate\" or \"final\"; string\n     PY_RELEASE_SERIAL # the 3; an int\n    )\n\nOptionalRelease records the first release in which\n\n    from __future__ import FeatureName\n\nwas accepted.\n\nIn the case of MandatoryReleases that have not yet occurred,\nMandatoryRelease predicts the release in which the feature will become part\nof the language.\n\nElse MandatoryRelease records when the feature became part of the language;\nin releases at or after that, modules no longer need\n\n    from __future__ import FeatureName\n\nto use the feature in question, but may continue to use such imports.\n\nMandatoryRelease may also be None, meaning that a planned feature got\ndropped.\n\nInstances of class _Feature have two corresponding methods,\n.getOptionalRelease() and .getMandatoryRelease().\n\nCompilerFlag is the (bitfield) flag that should be passed in the fourth\nargument to the builtin function compile() to enable the feature in\ndynamically compiled code.  This flag is stored in the .compiler_flag\nattribute on _Future instances.  These values must match the appropriate\n#defines of CO_xxx flags in Include/compile.h.\n\nNo feature line is ever to be deleted from this file.", 
  "line": 0, 
  "type": "module", 
  "name": "__future__", 
  "file": "/usr/lib/python3.2/__future__.py"
 }, 
 {
  "name": "_compile", 
  "doc": null, 
  "module": "codeop", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_maybe_compile", 
  "doc": null, 
  "module": "codeop", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compile_command", 
  "doc": "Compile a command and determine whether it is incomplete.\n\nArguments:\n\nsource -- the source string; may contain \\n characters\nfilename -- optional filename from which source was read; default\n            \"<input>\"\nsymbol -- optional grammar start symbol; \"single\" (default) or \"eval\"\n\nReturn value / exceptions raised:\n\n- Return a code object if the command is complete and valid\n- Return None if the command is incomplete\n- Raise SyntaxError, ValueError or OverflowError if the command is a\n  syntax error (OverflowError and ValueError can be produced by\n  malformed literals).", 
  "module": "codeop", 
  "file": "/usr/lib/python3.2/codeop.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ByteString", 
  "doc": "This unifies bytes and bytearray.\n\nXXX Should add all their methods.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Callable", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Container", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Counter", 
  "doc": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.\n\n>>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n\n>>> c.most_common(3)                # three most common elements\n[('a', 5), ('b', 4), ('c', 3)]\n>>> sorted(c)                       # list all unique elements\n['a', 'b', 'c', 'd', 'e']\n>>> ''.join(sorted(c.elements()))   # list elements with repetitions\n'aaaaabbbbcccdde'\n>>> sum(c.values())                 # total of all counts\n15\n\n>>> c['a']                          # count of letter 'a'\n5\n>>> for elem in 'shazam':           # update counts from an iterable\n...     c[elem] += 1                # by adding 1 to each element's count\n>>> c['a']                          # now there are seven 'a'\n7\n>>> del c['b']                      # remove all 'b'\n>>> c['b']                          # now there are zero 'b'\n0\n\n>>> d = Counter('simsalabim')       # make another counter\n>>> c.update(d)                     # add in the second counter\n>>> c['a']                          # now there are nine 'a'\n9\n\n>>> c.clear()                       # empty the counter\n>>> c\nCounter()\n\nNote:  If a count is set to zero or reduced to zero, it will remain\nin the counter until the entry is deleted or the counter is cleared:\n\n>>> c = Counter('aaabbc')\n>>> c['b'] -= 2                     # reduce the count of 'b' by two\n>>> c.most_common()                 # 'b' is still in, but its count is zero\n[('a', 3), ('c', 1), ('b', 0)]", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Hashable", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ItemsView", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Iterable", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Iterator", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "KeysView", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Mapping", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MappingView", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MutableMapping", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MutableSequence", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MutableSet", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OrderedDict", 
  "doc": "Dictionary that remembers insertion order", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Sequence", 
  "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Set", 
  "doc": "A set is a finite, iterable container.\n\nThis class provides concrete generic implementations of all\nmethods except for __contains__, __iter__ and __len__.\n\nTo override the comparisons (presumably for speed, as the\nsemantics are fixed), all you have to do is redefine __le__ and\nthen the other operations will automatically follow suit.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Sized", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UserDict", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UserList", 
  "doc": "A more or less complete user-defined wrapper around list objects.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UserString", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ValuesView", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_ChainMap", 
  "doc": "A ChainMap groups multiple dicts (or other mappings) together\nto create a single, updateable view.\n\nThe underlying mappings are stored in a list.  That list is public and can\naccessed or updated using the *maps* attribute.  There is no other state.\n\nLookups search the underlying mappings successively until a key is found.\nIn contrast, writes, updates, and deletions only operate on the first\nmapping.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Link", 
  "doc": null, 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nDON'T USE THIS MODULE DIRECTLY!  The classes here should be imported\nvia collections; they are defined here only to alleviate certain\nbootstrapping issues.  Unit tests are in test_collections.", 
  "line": 0, 
  "type": "module", 
  "name": "_abcoll", 
  "file": "/usr/lib/python3.2/_abcoll.py"
 }, 
 {
  "name": "_chain", 
  "doc": "chain(*iterables) --> chain object\n\nReturn a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_count_elements", 
  "doc": "_count_elements(mapping, iterable) -> None\n\nCount elements in the iterable, updating the mappping", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!", 
  "line": 0, 
  "type": "module", 
  "name": "_heapq", 
  "file": "/usr/lib/python3.2/heapq.py"
 }, 
 {
  "name": "_iskeyword", 
  "doc": "x.__contains__(y) <==> y in x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_itemgetter", 
  "doc": "itemgetter(item, ...) --> itemgetter object\n\nReturn a callable object that fetches the given item(s) from its operand.\nAfter, f=itemgetter(2), the call f(r) returns r[2].\nAfter, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_proxy", 
  "doc": "proxy(object[, callback]) -- create a proxy object that weakly\nreferences 'object'.  'callback', if given, is called with a\nreference to the proxy when 'object' is about to be finalized.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_recursive_repr", 
  "doc": "Decorator to make a repr function return fillvalue for a recursive call", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/reprlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_repeat", 
  "doc": "repeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_starmap", 
  "doc": "starmap(function, sequence) --> starmap object\n\nReturn an iterator whose values are returned from the function evaluated\nwith a argument tuple taken from the given sequence.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "name": "defaultdict", 
  "doc": "defaultdict(default_factory) --> dict with default factory\n\nThe default factory is called without arguments to produce\na new value when a key is not present, in __getitem__ only.\nA defaultdict compares equal to a dict with the same items.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "deque", 
  "doc": "deque(iterable[, maxlen]) --> deque object\n\nBuild an ordered collection with optimized access from its endpoints.", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "collections", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_v", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "hls_to_rgb", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "hsv_to_rgb", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rgb_to_hls", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rgb_to_hsv", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rgb_to_yiq", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "yiq_to_rgb", 
  "doc": null, 
  "module": "colorsys", 
  "file": "/usr/lib/python3.2/colorsys.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compile_dir", 
  "doc": "Byte-compile all modules in the given directory tree.\n\nArguments (only dir is required):\n\ndir:       the directory to byte-compile\nmaxlevels: maximum recursion level (default 10)\nddir:      the directory that will be prepended to the path to the\n           file as it is compiled into each byte-code file.\nforce:     if True, force compilation, even if timestamps are up-to-date\nquiet:     if True, be quiet during compilation\nlegacy:    if True, produce legacy pyc paths instead of PEP 3147 paths\noptimize:  optimization level or -1 for level of the interpreter", 
  "module": "compileall", 
  "file": "/usr/lib/python3.2/compileall.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compile_file", 
  "doc": "Byte-compile one file.\n\nArguments (only fullname is required):\n\nfullname:  the file to byte-compile\nddir:      if given, the directory name compiled in to the\n           byte-code file.\nforce:     if True, force compilation, even if timestamps are up-to-date\nquiet:     if True, be quiet during compilation\nlegacy:    if True, produce legacy pyc paths instead of PEP 3147 paths\noptimize:  optimization level or -1 for level of the interpreter", 
  "module": "compileall", 
  "file": "/usr/lib/python3.2/compileall.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compile_path", 
  "doc": "Byte-compile all module on sys.path.\n\nArguments (all optional):\n\nskip_curdir: if true, skip current directory (default True)\nmaxlevels:   max recursion level (default 0)\nforce: as for compile_dir() (default False)\nquiet: as for compile_dir() (default False)\nlegacy: as for compile_dir() (default False)\noptimize: as for compile_dir() (default -1)", 
  "module": "compileall", 
  "file": "/usr/lib/python3.2/compileall.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "main", 
  "doc": "Script main program.", 
  "module": "compileall", 
  "file": "/usr/lib/python3.2/compileall.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Routine to \"compile\" a .py file to a .pyc (or .pyo) file.\n\nThis module has intimate knowledge of the format of .pyc files.", 
  "line": 0, 
  "type": "module", 
  "name": "py_compile", 
  "file": "/usr/lib/python3.2/py_compile.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "ContextDecorator", 
  "doc": "A base class or mixin that enables context managers to work as decorators.", 
  "module": "contextlib", 
  "file": "/usr/lib/python3.2/contextlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_GeneratorContextManager", 
  "doc": "Helper for @contextmanager decorator.", 
  "module": "contextlib", 
  "file": "/usr/lib/python3.2/contextlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "closing", 
  "doc": "Context to automatically close something at the end of a block.\n\nCode like this:\n\n    with closing(<module>.open(<arguments>)) as f:\n        <block>\n\nis equivalent to this:\n\n    f = <module>.open(<arguments>)\n    try:\n        <block>\n    finally:\n        f.close()", 
  "module": "contextlib", 
  "file": "/usr/lib/python3.2/contextlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "contextmanager", 
  "doc": "@contextmanager decorator.\n\nTypical usage:\n\n    @contextmanager\n    def some_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    with some_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>", 
  "module": "contextlib", 
  "file": "/usr/lib/python3.2/contextlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "warn", 
  "doc": "Issue a warning, or maybe ignore it or raise an exception.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "wraps", 
  "doc": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().", 
  "module": "contextlib", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_EmptyClass", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_copy_immutable", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_copy_with_constructor", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_copy_with_copy_method", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_deepcopy_atomic", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_deepcopy_dict", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_deepcopy_list", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_deepcopy_method", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_deepcopy_tuple", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_keep_alive", 
  "doc": "Keeps a reference to the object x in the memo.\n\nBecause we remember objects by their id, we have\nto assure that possibly temporary objects are kept\nalive by referencing them.\nWe store a reference at the id of the memo, which should\nnormally not be used unless someone tries to deepcopy\nthe memo itself...", 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_reconstruct", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "copy", 
  "doc": "Shallow copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.", 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "deepcopy", 
  "doc": "Deep copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.", 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "copy", 
  "file": "/usr/lib/python3.2/copy.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "t", 
  "doc": "set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Weak reference support for Python.\n\nThis module is an implementation of PEP 205:\n\nhttp://www.python.org/dev/peps/pep-0205/", 
  "line": 0, 
  "type": "module", 
  "name": "weakref", 
  "file": "/usr/lib/python3.2/weakref.py"
 }, 
 {
  "name": "Dialect", 
  "doc": "Describe a CSV dialect.\n\nThis must be subclassed (see csv.excel).  Valid attributes are:\ndelimiter, quotechar, escapechar, doublequote, skipinitialspace,\nlineterminator, quoting.", 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DictReader", 
  "doc": null, 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DictWriter", 
  "doc": null, 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "csv", 
  "file": "/usr/lib/python3.2/lib-dynload/_csv.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Sniffer", 
  "doc": "\"Sniffs\" the format of a CSV file (i.e. delimiter, quotechar)\nReturns a Dialect object.", 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Dialect", 
  "doc": "CSV dialect\n\nThe Dialect type records CSV parsing and generation options.", 
  "module": "csv", 
  "file": "/usr/lib/python3.2/lib-dynload/_csv.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "excel", 
  "doc": "Describe the usual properties of Excel-generated CSV files.", 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "excel_tab", 
  "doc": "Describe the usual properties of Excel-generated TAB-delimited files.", 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "field_size_limit", 
  "doc": "Sets an upper limit on parsed fields.\n    csv.field_size_limit([limit])\n\nReturns old limit. If limit is not given, no new limit is set and\nthe old limit is returned", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_dialect", 
  "doc": "Return the dialect instance associated with name.\ndialect = csv.get_dialect(name)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "list_dialects", 
  "doc": "Return a list of all know dialect names.\nnames = csv.list_dialects()", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "reader", 
  "doc": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)\n\nThe \"iterable\" argument can be any object that returns a line\nof input for each iteration, such as a file object or a list.  The\noptional \"dialect\" parameter is discussed below.  The function\nalso accepts optional keyword arguments which override settings\nprovided by the dialect.\n\nThe returned object is an iterator.  Each iteration returns a row\nof the CSV file (which can span multiple input lines):", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_dialect", 
  "doc": "Create a mapping from a string name to a dialect class.\ndialect = csv.register_dialect(name, dialect)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unix_dialect", 
  "doc": "Describe the usual properties of Unix-generated CSV files.", 
  "module": "csv", 
  "file": "/usr/lib/python3.2/csv.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "unregister_dialect", 
  "doc": "Delete the name/dialect mapping associated with a string name.\ncsv.unregister_dialect(name)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "writer", 
  "doc": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)\n\n    [or]\n\n    csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    csv_writer.writerows(rows)\n\nThe \"fileobj\" argument can be any object that supports the file API.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ARRAY", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ArgumentError", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Array", 
  "doc": "XXX to be provided", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BigEndianStructure", 
  "doc": "Structure with big endian byte order", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/_endian.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "CDLL", 
  "doc": "An instance of this class represents a loaded dll/shared\nlibrary, exporting functions using the standard C calling\nconvention (named 'cdecl' on Windows).\n\nThe exported functions can be accessed as attributes, or by\nindexing with the function name.  Examples:\n\n<obj>.qsort -> callable object\n<obj>['qsort'] -> callable object\n\nCalling the functions releases the Python GIL during the call and\nreacquires it afterwards.", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "CFUNCTYPE", 
  "doc": "CFUNCTYPE(restype, *argtypes,\n             use_errno=False, use_last_error=False) -> function prototype.\n\nrestype: the result type\nargtypes: a sequence specifying the argument types\n\nThe function prototype can be called in different ways to create a\ncallable object:\n\nprototype(integer address) -> foreign function\nprototype(callable) -> create and return a C callable function from callable\nprototype(integer index, method name[, paramflags]) -> foreign function calling a COM method\nprototype((ordinal number, dll object)[, paramflags]) -> foreign function exported by ordinal\nprototype((function name, dll object)[, paramflags]) -> foreign function exported by name", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "LibraryLoader", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LittleEndianStructure", 
  "doc": "Structure base class", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "POINTER", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "PYFUNCTYPE", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "PyDLL", 
  "doc": "This class represents the Python library itself.  It allows to\naccess Python API functions.  The GIL is not released, and\nPython exceptions are handled correctly.", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SetPointerType", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Structure", 
  "doc": "Structure base class", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Union", 
  "doc": "Union base class", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_CFuncPtr", 
  "doc": "Function Pointer", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Pointer", 
  "doc": "XXX to be provided", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_SimpleCData", 
  "doc": "XXX to be provided", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_calcsize", 
  "doc": "calcsize(fmt) -> integer\n\nReturn size in bytes of the struct described by the format string fmt.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_check_size", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dlopen", 
  "doc": "dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_endian", 
  "file": "/usr/lib/python3.2/ctypes/_endian.py"
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "_os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "_reset_cache", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "name": "addressof", 
  "doc": "addressof(C instance) -> integer\nReturn the address of the C instance internal buffer", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "alignment", 
  "doc": "alignment(C type) -> integer\nalignment(C instance) -> integer\nReturn the alignment requirements of a C instance", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "byref", 
  "doc": "byref(C instance[, offset=0]) -> byref-object\nReturn a pointer lookalike to a C instance, only usable\nas function argument", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "c_bool", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_buffer", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "c_byte", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_char", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_char_p", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_double", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_float", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_int", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_int16", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_int32", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_int64", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_int8", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_long", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_longdouble", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_longlong", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_short", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_size_t", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_ssize_t", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_ubyte", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_uint", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_uint16", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_uint32", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_uint64", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_uint8", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_ulong", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_ulonglong", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_ushort", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_void_p", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_voidp", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_wchar", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "c_wchar_p", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "cast", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "create_string_buffer", 
  "doc": "create_string_buffer(aBytes) -> character array\ncreate_string_buffer(anInteger) -> character array\ncreate_string_buffer(aString, anInteger) -> character array", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "create_unicode_buffer", 
  "doc": "create_unicode_buffer(aString) -> character array\ncreate_unicode_buffer(anInteger) -> character array\ncreate_unicode_buffer(aString, anInteger) -> character array", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_errno", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pointer", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "py_object", 
  "doc": null, 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "resize", 
  "doc": "Resize the memory buffer of a ctypes instance", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_errno", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sizeof", 
  "doc": "sizeof(C type) -> integer\nsizeof(C instance) -> integer\nReturn the size in bytes of a C instance", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "string_at", 
  "doc": "string_at(addr[, size]) -> string\n\nReturn the string at addr.", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "util", 
  "file": "/usr/lib/python3.2/ctypes/util.py"
 }, 
 {
  "name": "wstring_at", 
  "doc": "wstring_at(addr[, size]) -> string\n\nReturn the string at addr.", 
  "module": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "_os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "name": "baudrate", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "beep", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "can_change_color", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cbreak", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "color_content", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "color_pair", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "curs_set", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "def_prog_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "def_shell_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "delay_output", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "doupdate", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "echo", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "erasechar", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "curses", 
  "file": "/usr/lib/python3.2/lib-dynload/_curses.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "filter", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "flash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "flushinp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmouse", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsyx", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "halfdelay", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_colors", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_ic", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_il", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_key", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "init_color", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "init_pair", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "initscr", 
  "doc": null, 
  "module": "curses", 
  "file": "/usr/lib/python3.2/curses/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "intrflush", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "is_term_resized", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isendwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "keyname", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "killchar", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "longname", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "meta", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mouseinterval", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mousemask", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "napms", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "newpad", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "newwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nl", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nocbreak", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "noecho", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nonl", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "noqiflush", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "noraw", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pair_content", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pair_number", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "putp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "qiflush", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "raw", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reset_prog_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reset_shell_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resetty", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resize_term", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resizeterm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "savetty", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setsyx", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setupterm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "start_color", 
  "doc": null, 
  "module": "curses", 
  "file": "/usr/lib/python3.2/curses/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "termattrs", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "termname", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tigetflag", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tigetnum", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tigetstr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tparm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "typeahead", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unctrl", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ungetch", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ungetmouse", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "use_default_colors", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "use_env", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "wrapper", 
  "doc": "Wrapper function that initializes curses and calls another function,\nrestoring normal keyboard/screen behavior on error.\nThe callable object 'func' is then passed the main window 'stdscr'\nas its first argument, followed by any other arguments passed to\nwrapper().", 
  "module": "curses", 
  "file": "/usr/lib/python3.2/curses/wrapper.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "date", 
  "doc": "date(year, month, day) --> date object", 
  "module": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "datetime", 
  "doc": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints or longs.", 
  "module": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "time", 
  "doc": "time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --> a time object\n\nAll arguments are optional. tzinfo may be None, or an instance of\na tzinfo subclass. The remaining arguments may be ints or longs.", 
  "module": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "timedelta", 
  "doc": "Difference between two datetime values.", 
  "module": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "timezone", 
  "doc": "Fixed offset from UTC implementation of tzinfo.", 
  "module": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "tzinfo", 
  "doc": "Abstract base class for time zone info objects.", 
  "module": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "open", 
  "doc": "Open or create database at path given by *file*.\n\nOptional argument *flag* can be 'r' (default) for read-only access, 'w'\nfor read-write access of an existing database, 'c' for read-write access\nto a new or existing database, and 'n' for read-write access to a new\ndatabase.\n\nNote: 'r' and 'w' fail if the database doesn't exist; 'c' creates it\nonly if it doesn't exist; and 'n' always creates a new database.", 
  "module": "dbm", 
  "file": "/usr/lib/python3.2/dbm/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "whichdb", 
  "doc": "Guess which db package to use to open a db file.\n\nReturn values:\n\n- None if the database file can't be read;\n- empty string if the file can be read but can't be recognized\n- the name of the dbm submodule (e.g. \"ndbm\" or \"gnu\") if recognized.\n\nImporting the given module may still fail, and opening the\ndatabase using that module may still fail.", 
  "module": "dbm", 
  "file": "/usr/lib/python3.2/dbm/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Clamped", 
  "doc": "Exponent of a 0 changed to fit bounds.\n\nThis occurs and signals clamped if the exponent of a result has been\naltered in order to fit the constraints of a specific concrete\nrepresentation.  This may occur when the exponent of a zero result would\nbe outside the bounds of a representation, or when a large normal\nnumber would have an encoded exponent that cannot be represented.  In\nthis latter case, the exponent is reduced to fit and the corresponding\nnumber of zero digits are appended to the coefficient (\"fold-down\").", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Context", 
  "doc": "Contains the context for a Decimal instance.\n\nContains:\nprec - precision (for use in rounding, division, square roots..)\nrounding - rounding type (how you round)\ntraps - If traps[exception] = 1, then the exception is\n                raised when it is caused.  Otherwise, a value is\n                substituted in.\nflags  - When an exception is caused, flags[exception] is set.\n         (Whether or not the trap_enabler is set)\n         Should be reset by user of Decimal instance.\nEmin -   Minimum exponent\nEmax -   Maximum exponent\ncapitals -      If 1, 1*10^1 is printed as 1E+1.\n                If 0, printed as 1e1\nclamp -  If 1, change exponents if too high (Default 0)", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ConversionSyntax", 
  "doc": "Trying to convert badly formed string.\n\nThis occurs and signals invalid-operation if an string is being\nconverted to a number and it does not conform to the numeric string\nsyntax.  The result is [0,qNaN].", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Decimal", 
  "doc": "Floating point class for decimal arithmetic.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DecimalException", 
  "doc": "Base exception class.\n\nUsed exceptions derive from this.\nIf an exception derives from another exception besides this (such as\nUnderflow (Inexact, Rounded, Subnormal) that indicates that it is only\ncalled if the others are present.  This isn't actually used for\nanything, though.\n\nhandle  -- Called when context._raise_error is called and the\n           trap_enabler is not set.  First argument is self, second is the\n           context.  More arguments can be given, those being after\n           the explanation in _raise_error (For example,\n           context._raise_error(NewError, '(-x)!', self._sign) would\n           call NewError().handle(context, self._sign).)\n\nTo define a new exception, it should be sufficient to have it derive\nfrom DecimalException.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DecimalTuple", 
  "doc": "DecimalTuple(sign, digits, exponent)", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DivisionByZero", 
  "doc": "Division by 0.\n\nThis occurs and signals division-by-zero if division of a finite number\nby zero was attempted (during a divide-integer or divide operation, or a\npower operation with negative right-hand operand), and the dividend was\nnot zero.\n\nThe result of the operation is [sign,inf], where sign is the exclusive\nor of the signs of the operands for divide, or is 1 for an odd power of\n-0, for power.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DivisionImpossible", 
  "doc": "Cannot perform the division adequately.\n\nThis occurs and signals invalid-operation if the integer result of a\ndivide-integer or remainder operation had too many digits (would be\nlonger than precision).  The result is [0,qNaN].", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DivisionUndefined", 
  "doc": "Undefined result of division.\n\nThis occurs and signals invalid-operation if division by zero was\nattempted (during a divide-integer, divide, or remainder operation), and\nthe dividend is also zero.  The result is [0,qNaN].", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Inexact", 
  "doc": "Had to round, losing information.\n\nThis occurs and signals inexact whenever the result of an operation is\nnot exact (that is, it needed to be rounded and any discarded digits\nwere non-zero), or if an overflow or underflow condition occurs.  The\nresult in all cases is unchanged.\n\nThe inexact signal may be tested (or trapped) to determine if a given\noperation (or sequence of operations) was inexact.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InvalidContext", 
  "doc": "Invalid context.  Unknown rounding, for example.\n\nThis occurs and signals invalid-operation if an invalid context was\ndetected during an operation.  This can occur if contexts are not checked\non creation and either the precision exceeds the capability of the\nunderlying concrete representation or an unknown or unsupported rounding\nwas specified.  These aspects of the context need only be checked when\nthe values are required to be used.  The result is [0,qNaN].", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InvalidOperation", 
  "doc": "An invalid operation was performed.\n\nVarious bad things cause this:\n\nSomething creates a signaling NaN\n-INF + INF\n0 * (+-)INF\n(+-)INF / (+-)INF\nx % 0\n(+-)INF % x\nx._rescale( non-integer )\nsqrt(-x) , x > 0\n0 ** 0\nx ** (non-integer)\nx ** (+-)INF\nAn operand is invalid\n\nThe result of the operation after these is a quiet positive NaN,\nexcept when the cause is a signaling NaN, in which case the result is\nalso a quiet NaN, but with the original sign, and an optional\ndiagnostic information.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Overflow", 
  "doc": "Numerical overflow.\n\nThis occurs and signals overflow if the adjusted exponent of a result\n(from a conversion or from an operation that is not an attempt to divide\nby zero), after rounding, would be greater than the largest value that\ncan be handled by the implementation (the value Emax).\n\nThe result depends on the rounding mode:\n\nFor round-half-up and round-half-even (and for round-half-down and\nround-up, if implemented), the result of the operation is [sign,inf],\nwhere sign is the sign of the intermediate result.  For round-down, the\nresult is the largest finite number that can be represented in the\ncurrent precision, with the sign of the intermediate result.  For\nround-ceiling, the result is the same as for round-down if the sign of\nthe intermediate result is 1, or is [0,inf] otherwise.  For round-floor,\nthe result is the same as for round-down if the sign of the intermediate\nresult is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded\nwill also be raised.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Rounded", 
  "doc": "Number got rounded (not  necessarily changed during rounding).\n\nThis occurs and signals rounded whenever the result of an operation is\nrounded (that is, some zero or non-zero digits were discarded from the\ncoefficient), or if an overflow or underflow condition occurs.  The\nresult in all cases is unchanged.\n\nThe rounded signal may be tested (or trapped) to determine if a given\noperation (or sequence of operations) caused a loss of precision.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Subnormal", 
  "doc": "Exponent < Emin before rounding.\n\nThis occurs and signals subnormal whenever the result of a conversion or\noperation is subnormal (that is, its adjusted exponent is less than\nEmin, before any rounding).  The result in all cases is unchanged.\n\nThe subnormal signal may be tested (or trapped) to determine if a given\nor operation (or sequence of operations) yielded a subnormal result.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Underflow", 
  "doc": "Numerical underflow with result rounded to 0.\n\nThis occurs and signals underflow if a result is inexact and the\nadjusted exponent of the result would be smaller (more negative) than\nthe smallest value that can be handled by the implementation (the value\nEmin).  That is, the result is both inexact and subnormal.\n\nThe result after an underflow will be a subnormal number rounded, if\nnecessary, so that its exponent is not less than Etiny.  This may result\nin 0 with the sign of the intermediate result and an exponent of Etiny.\n\nIn all cases, Inexact, Rounded, and Subnormal will also be raised.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_ContextManager", 
  "doc": "Context manager class to support localcontext().\n\nSets a copy of the supplied context in __enter__() and restores\nthe previous decimal context in __exit__()", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Log10Memoize", 
  "doc": "Class to compute, store, and allow retrieval of, digits of the\nconstant log(10) = 2.302585....  This constant is needed by\nDecimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_WorkRep", 
  "doc": null, 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_all_zeros", 
  "doc": "match(string[, pos[, endpos]]) --> match object or None.\nMatches zero or more characters at the beginning of the string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_convert_for_comparison", 
  "doc": "Given a Decimal instance self and a Python object other, return\na pair (s, o) of Decimal instances such that \"s op o\" is\nequivalent to \"self op other\" for any of the 6 comparison\noperators \"op\".", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_convert_other", 
  "doc": "Convert other to Decimal.\n\nVerifies that it's ok to use in an implicit construction.\nIf allow_float is true, allow conversion from float;  this\nis used in the comparison methods (__eq__ and friends).", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Generic (shallow and deep) copying operations.\n\nInterface summary:\n\n        import copy\n\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\n\nFor module specific errors, copy.Error is raised.\n\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\n\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\n\nPython's deep copy operation avoids these problems by:\n\n a) keeping a table of objects already copied during the current\n    copying pass\n\n b) letting user-defined classes override the copying operation or the\n    set of components copied\n\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\n\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods.", 
  "line": 0, 
  "type": "module", 
  "name": "_copy", 
  "file": "/usr/lib/python3.2/copy.py"
 }, 
 {
  "name": "_dec_from_triple", 
  "doc": "Create a decimal instance directly, without any validation,\nnormalization (e.g. removal of leading zeros) or argument\nconversion.\n\nThis function is for *internal use only*.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dexp", 
  "doc": "Compute an approximation to exp(c*10**e), with p decimal places of\nprecision.\n\nReturns integers d, f such that:\n\n  10**(p-1) <= d <= 10**p, and\n  (d-1)*10**f < exp(c*10**e) < (d+1)*10**f\n\nIn other words, d*10**f is an approximation to exp(c*10**e) with p\ndigits of precision, and with an error in d of at most 1.  This is\nalmost, but not quite, the same as the error being < 1ulp: when d\n= 10**(p-1) the error could be up to 10 ulp.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_div_nearest", 
  "doc": "Closest integer to a/b, a and b positive integers; rounds to even\nin the case of a tie.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dlog", 
  "doc": "Given integers c, e and p with c > 0, compute an integer\napproximation to 10**p * log(c*10**e), with an absolute error of\nat most 1.  Assumes that c*10**e is not exactly 1.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dlog10", 
  "doc": "Given integers c, e and p with c > 0, p >= 0, compute an integer\napproximation to 10**p * log10(c*10**e), with an absolute error of\nat most 1.  Assumes that c*10**e is not exactly 1.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dpower", 
  "doc": "Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and\ny = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:\n\n  10**(p-1) <= c <= 10**p, and\n  (c-1)*10**e < x**y < (c+1)*10**e\n\nin other words, c*10**e is an approximation to x**y with p digits\nof precision, and with an error in c of at most 1.  (This is\nalmost, but not quite, the same as the error being < 1ulp: when c\n== 10**(p-1) we can only guarantee error < 10ulp.)\n\nWe assume that: x is positive and not equal to 1, and y is nonzero.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_exact_half", 
  "doc": "match(string[, pos[, endpos]]) --> match object or None.\nMatches zero or more characters at the beginning of the string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_align", 
  "doc": "Given an unpadded, non-aligned numeric string 'body' and sign\nstring 'sign', add padding and alignment conforming to the given\nformat specifier dictionary 'spec' (as produced by\nparse_format_specifier).", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_number", 
  "doc": "Format a number, given the following data:\n\nis_negative: true if the number is negative, else false\nintpart: string of digits that must appear before the decimal point\nfracpart: string of digits that must come after the point\nexp: exponent, as an integer\nspec: dictionary resulting from parsing the format specifier\n\nThis function uses the information in spec to:\n  insert separators (decimal separator and thousands separators)\n  format the sign\n  format the exponent\n  add trailing '%' for the '%' type\n  zero-pad if necessary\n  fill and align if necessary", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_sign", 
  "doc": "Determine sign character.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_group_lengths", 
  "doc": "Convert a localeconv-style grouping into a (possibly infinite)\niterable of integers representing group lengths.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_iexp", 
  "doc": "Given integers x and M, M > 0, such that x/M is small in absolute\nvalue, compute an integer approximation to M*exp(x/M).  For 0 <=\nx/M <= 2.4, the absolute error in the result is bounded by 60 (and\nis usually much smaller).", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ilog", 
  "doc": "Integer approximation to M*log(x/M), with absolute error boundable\nin terms only of x/M.\n\nGiven positive integers x and M, return an integer approximation to\nM * log(x/M).  For L = 8 and 0.1 <= x/M <= 10 the difference\nbetween the approximation and the exact result is at most 22.  For\nL = 8 and 1.0 <= x/M <= 10.0 the difference is at most 15.  In\nboth cases these are upper bounds on the error; it will usually be\nmuch smaller.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_insert_thousands_sep", 
  "doc": "Insert thousands separators into a digit string.\n\nspec is a dictionary whose keys should include 'thousands_sep' and\n'grouping'; typically it's the result of parsing the format\nspecifier using _parse_format_specifier.\n\nThe min_width keyword argument gives the minimum length of the\nresult, which will be padded on the left with zeros if necessary.\n\nIf necessary, the zero padding adds an extra '0' on the left to\navoid a leading thousands separator.  For example, inserting\ncommas every three digits in '123456', with min_width=8, gives\n'0,123,456', even though that has length 9.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Locale support.\n\nThe module provides low-level access to the C lib's locale APIs\nand adds high level number formatting APIs as well as a locale\naliasing engine to complement these.\n\nThe aliasing engine includes support for many commonly used locale\nnames and maps them to values suitable for passing to the C lib's\nsetlocale() function. It also includes default encodings for all\nsupported locale names.", 
  "line": 0, 
  "type": "module", 
  "name": "_locale", 
  "file": "/usr/lib/python3.2/locale.py"
 }, 
 {
  "name": "_log10_digits", 
  "doc": "Given an integer p >= 0, return floor(10**p)*log(10).\n\nFor example, self.getdigits(3) returns 2302.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_log10_lb", 
  "doc": "Compute a lower bound for 100*log10(c) for a positive integer c.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module is always available.  It provides access to the\nmathematical functions defined by the C standard.", 
  "line": 0, 
  "type": "module", 
  "name": "_math", 
  "file": null
 }, 
 {
  "name": "_namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_normalize", 
  "doc": "Normalizes op1, op2 to have the same exp and length of coefficient.\n\nDone during addition.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Abstract Base Classes (ABCs) for numbers, according to PEP 3141.\n\nTODO: Fill out more detailed documentation on the operators.", 
  "line": 0, 
  "type": "module", 
  "name": "_numbers", 
  "file": "/usr/lib/python3.2/numbers.py"
 }, 
 {
  "name": "_parse_format_specifier", 
  "doc": "Parse and validate a format specifier.\n\nTurns a standard numeric format specifier into a dict, with the\nfollowing entries:\n\n  fill: fill character to pad field to minimum width\n  align: alignment type, either '<', '>', '=' or '^'\n  sign: either '+', '-' or ' '\n  minimumwidth: nonnegative integer giving minimum width\n  zeropad: boolean, indicating whether to pad with zeros\n  thousands_sep: string to use as thousands separator, or ''\n  grouping: grouping for thousands separators, in format\n    used by localeconv\n  decimal_point: string to use for decimal point\n  precision: nonnegative integer giving precision, or None\n  type: one of the characters 'eEfFgG%', or None", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parser", 
  "doc": "match(string[, pos[, endpos]]) --> match object or None.\nMatches zero or more characters at the beginning of the string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_rshift_nearest", 
  "doc": "Given an integer x and a nonnegative integer shift, return closest\ninteger to x / 2**shift; use round-to-even in case of a tie.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_sqrt_nearest", 
  "doc": "Closest integer to the square root of the positive integer n.  a is\nan initial approximation to the square root.  Any positive integer\nwill do for a, but the closer a is to the square root of n the\nfaster convergence will be.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcontext", 
  "doc": "Returns this thread's context.\n\nIf this thread does not yet have a context, returns\na new context and sets this thread's context.\nNew contexts are copies of DefaultContext.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "localcontext", 
  "doc": "Return a context manager for a copy of the supplied context\n\nUses a copy of the current context if no context is specified\nThe returned context manager creates a local decimal context\nin a with statement:\n    def sin(x):\n         with localcontext() as ctx:\n             ctx.prec += 2\n             # Rest of sin calculation algorithm\n             # uses a precision 2 greater than normal\n         return +s  # Convert result to normal precision\n\n     def sin(x):\n         with localcontext(ExtendedContext):\n             # Rest of sin calculation algorithm\n             # uses the Extended Context from the\n             # General Decimal Arithmetic Specification\n         return +s  # Convert result to normal context\n\n>>> setcontext(DefaultContext)\n>>> print(getcontext().prec)\n28\n>>> with localcontext():\n...     ctx = getcontext()\n...     ctx.prec += 2\n...     print(ctx.prec)\n...\n30\n>>> with localcontext(ExtendedContext):\n...     print(getcontext().prec)\n...\n9\n>>> print(getcontext().prec)\n28", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setcontext", 
  "doc": "Set this thread's context to context.", 
  "module": "decimal", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Differ", 
  "doc": "Differ is a class for comparing sequences of lines of text, and\nproducing human-readable differences or deltas.  Differ uses\nSequenceMatcher both to compare sequences of lines, and to compare\nsequences of characters within similar (near-matching) lines.\n\nEach line of a Differ delta begins with a two-letter code:\n\n    '- '    line unique to sequence 1\n    '+ '    line unique to sequence 2\n    '  '    line common to both sequences\n    '? '    line not present in either input sequence\n\nLines beginning with '? ' attempt to guide the eye to intraline\ndifferences, and were not present in either input sequence.  These lines\ncan be confusing if the sequences contain tab characters.\n\nNote that Differ makes no claim to produce a *minimal* diff.  To the\ncontrary, minimal diffs are often counter-intuitive, because they synch\nup anywhere possible, sometimes accidental matches 100 pages apart.\nRestricting synch points to contiguous matches preserves some notion of\nlocality, at the occasional cost of producing a longer diff.\n\nExample: Comparing two texts.\n\nFirst we set up the texts, sequences of individual single-line strings\nending with newlines (such sequences can also be obtained from the\n`readlines()` method of file-like objects):\n\n>>> text1 = '''  1. Beautiful is better than ugly.\n...   2. Explicit is better than implicit.\n...   3. Simple is better than complex.\n...   4. Complex is better than complicated.\n... '''.splitlines(1)\n>>> len(text1)\n4\n>>> text1[0][-1]\n'\\n'\n>>> text2 = '''  1. Beautiful is better than ugly.\n...   3.   Simple is better than complex.\n...   4. Complicated is better than complex.\n...   5. Flat is better than nested.\n... '''.splitlines(1)\n\nNext we instantiate a Differ object:\n\n>>> d = Differ()\n\nNote that when instantiating a Differ object we may pass functions to\nfilter out line and character 'junk'.  See Differ.__init__ for details.\n\nFinally, we compare the two:\n\n>>> result = list(d.compare(text1, text2))\n\n'result' is a list of strings, so let's pretty-print it:\n\n>>> from pprint import pprint as _pprint\n>>> _pprint(result)\n['    1. Beautiful is better than ugly.\\n',\n '-   2. Explicit is better than implicit.\\n',\n '-   3. Simple is better than complex.\\n',\n '+   3.   Simple is better than complex.\\n',\n '?     ++\\n',\n '-   4. Complex is better than complicated.\\n',\n '?            ^                     ---- ^\\n',\n '+   4. Complicated is better than complex.\\n',\n '?           ++++ ^                      ^\\n',\n '+   5. Flat is better than nested.\\n']\n\nAs a single multi-line string it looks like this:\n\n>>> print(''.join(result), end=\"\")\n    1. Beautiful is better than ugly.\n-   2. Explicit is better than implicit.\n-   3. Simple is better than complex.\n+   3.   Simple is better than complex.\n?     ++\n-   4. Complex is better than complicated.\n?            ^                     ---- ^\n+   4. Complicated is better than complex.\n?           ++++ ^                      ^\n+   5. Flat is better than nested.\n\nMethods:\n\n__init__(linejunk=None, charjunk=None)\n    Construct a text differencer, with optional filters.\n\ncompare(a, b)\n    Compare two sequences of lines; generate the resulting delta.", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HtmlDiff", 
  "doc": "For producing HTML side by side comparison with change highlights.\n\nThis class can be used to create an HTML table (or a complete HTML file\ncontaining the table) showing a side by side, line by line comparison\nof text with inter-line and intra-line change highlights.  The table can\nbe generated in either full or contextual difference mode.\n\nThe following methods are provided for HTML generation:\n\nmake_table -- generates HTML for a single side by side table\nmake_file -- generates complete HTML file with a single side by side table\n\nSee tools/scripts/diff.py for an example usage of this class.", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IS_CHARACTER_JUNK", 
  "doc": "Return 1 for ignorable character: iff `ch` is a space or tab.\n\nExamples:\n\n>>> IS_CHARACTER_JUNK(' ')\nTrue\n>>> IS_CHARACTER_JUNK('\\t')\nTrue\n>>> IS_CHARACTER_JUNK('\\n')\nFalse\n>>> IS_CHARACTER_JUNK('x')\nFalse", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IS_LINE_JUNK", 
  "doc": "Return 1 for ignorable line: iff `line` is blank or contains a single '#'.\n\nExamples:\n\n>>> IS_LINE_JUNK('\\n')\nTrue\n>>> IS_LINE_JUNK('  #   \\n')\nTrue\n>>> IS_LINE_JUNK('hello\\n')\nFalse", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Match", 
  "doc": "Match(a, b, size)", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SequenceMatcher", 
  "doc": "SequenceMatcher is a flexible class for comparing pairs of sequences of\nany type, so long as the sequence elements are hashable.  The basic\nalgorithm predates, and is a little fancier than, an algorithm\npublished in the late 1980's by Ratcliff and Obershelp under the\nhyperbolic name \"gestalt pattern matching\".  The basic idea is to find\nthe longest contiguous matching subsequence that contains no \"junk\"\nelements (R-O doesn't address junk).  The same idea is then applied\nrecursively to the pieces of the sequences to the left and to the right\nof the matching subsequence.  This does not yield minimal edit\nsequences, but does tend to yield matches that \"look right\" to people.\n\nSequenceMatcher tries to compute a \"human-friendly diff\" between two\nsequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\nlongest *contiguous* & junk-free matching subsequence.  That's what\ncatches peoples' eyes.  The Windows(tm) windiff has another interesting\nnotion, pairing up elements that appear uniquely in each sequence.\nThat, and the method here, appear to yield more intuitive difference\nreports than does diff.  This method appears to be the least vulnerable\nto synching up on blocks of \"junk lines\", though (like blank lines in\nordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\nbecause this is the only method of the 3 that has a *concept* of\n\"junk\" <wink>.\n\nExample, comparing two strings, and considering blanks to be \"junk\":\n\n>>> s = SequenceMatcher(lambda x: x == \" \",\n...                     \"private Thread currentThread;\",\n...                     \"private volatile Thread currentThread;\")\n>>>\n\n.ratio() returns a float in [0, 1], measuring the \"similarity\" of the\nsequences.  As a rule of thumb, a .ratio() value over 0.6 means the\nsequences are close matches:\n\n>>> print(round(s.ratio(), 3))\n0.866\n>>>\n\nIf you're only interested in where the sequences match,\n.get_matching_blocks() is handy:\n\n>>> for block in s.get_matching_blocks():\n...     print(\"a[%d] and b[%d] match for %d elements\" % block)\na[0] and b[0] match for 8 elements\na[8] and b[17] match for 21 elements\na[29] and b[38] match for 0 elements\n\nNote that the last tuple returned by .get_matching_blocks() is always a\ndummy, (len(a), len(b), 0), and this is the only case in which the last\ntuple element (number of elements matched) is 0.\n\nIf you want to know how to change the first sequence into the second,\nuse .get_opcodes():\n\n>>> for opcode in s.get_opcodes():\n...     print(\"%6s a[%d:%d] b[%d:%d]\" % opcode)\n equal a[0:8] b[0:8]\ninsert a[8:8] b[8:17]\n equal a[8:29] b[17:38]\n\nSee the Differ class for a fancy human-friendly file differencer, which\nuses SequenceMatcher both to compare sequences of lines, and to compare\nsequences of characters within similar (near-matching) lines.\n\nSee also function get_close_matches() in this module, which shows how\nsimple code building on SequenceMatcher can be used to do useful work.\n\nTiming:  Basic R-O is cubic time worst case and quadratic time expected\ncase.  SequenceMatcher is quadratic time for the worst case and has\nexpected-case behavior dependent in a complicated way on how many\nelements the sequences have in common; best case time is linear.\n\nMethods:\n\n__init__(isjunk=None, a='', b='')\n    Construct a SequenceMatcher.\n\nset_seqs(a, b)\n    Set the two sequences to be compared.\n\nset_seq1(a)\n    Set the first sequence to be compared.\n\nset_seq2(b)\n    Set the second sequence to be compared.\n\nfind_longest_match(alo, ahi, blo, bhi)\n    Find longest matching block in a[alo:ahi] and b[blo:bhi].\n\nget_matching_blocks()\n    Return list of triples describing matching subsequences.\n\nget_opcodes()\n    Return list of 5-tuples describing how to turn a into b.\n\nratio()\n    Return a measure of the sequences' similarity (float in [0,1]).\n\nquick_ratio()\n    Return an upper bound on .ratio() relatively quickly.\n\nreal_quick_ratio()\n    Return an upper bound on ratio() very quickly.", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_calculate_ratio", 
  "doc": null, 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_count_leading", 
  "doc": "Return number of `ch` characters at the start of `line`.\n\nExample:\n\n>>> _count_leading('   abc', ' ')\n3", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_range_context", 
  "doc": "Convert range to the \"ed\" format", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_range_unified", 
  "doc": "Convert range to the \"ed\" format", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_mdiff", 
  "doc": "Returns generator yielding marked up from/to side by side differences.\n\nArguments:\nfromlines -- list of text lines to compared to tolines\ntolines -- list of text lines to be compared to fromlines\ncontext -- number of context lines to display on each side of difference,\n           if None, all from/to text lines will be generated.\nlinejunk -- passed on to ndiff (see ndiff documentation)\ncharjunk -- passed on to ndiff (see ndiff documentation)\n\nThis function returns an interator which returns a tuple:\n(from line tuple, to line tuple, boolean flag)\n\nfrom/to line tuple -- (line num, line text)\n    line num -- integer or None (to indicate a context separation)\n    line text -- original line text with following markers inserted:\n        '\\0+' -- marks start of added text\n        '\\0-' -- marks start of deleted text\n        '\\0^' -- marks start of changed text\n        '\\1' -- marks end of added/deleted/changed text\n\nboolean flag -- None indicates context separation, True indicates\n    either \"from\" or \"to\" line contains a change, otherwise False.\n\nThis function/iterator was originally developed to generate side by side\nfile difference for making HTML pages (see HtmlDiff class for example\nusage).\n\nNote, this function utilizes the ndiff function to generate the side by\nside difference markup.  Optional ndiff arguments may be passed to this\nfunction and they in turn will be passed to ndiff.", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "context_diff", 
  "doc": "Compare two sequences of lines; generate the delta as a context diff.\n\nContext diffs are a compact way of showing line changes and a few\nlines of context.  The number of context lines is set by 'n' which\ndefaults to three.\n\nBy default, the diff control lines (those with *** or ---) are\ncreated with a trailing newline.  This is helpful so that inputs\ncreated from file.readlines() result in diffs that are suitable for\nfile.writelines() since both the inputs and outputs have trailing\nnewlines.\n\nFor inputs that do not have trailing newlines, set the lineterm\nargument to \"\" so that the output will be uniformly newline free.\n\nThe context diff format normally has a header for filenames and\nmodification times.  Any or all of these may be specified using\nstrings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\nThe modification times are normally expressed in the ISO 8601 format.\nIf not specified, the strings default to blanks.\n\nExample:\n\n>>> print(''.join(context_diff('one\\ntwo\\nthree\\nfour\\n'.splitlines(1),\n...       'zero\\none\\ntree\\nfour\\n'.splitlines(1), 'Original', 'Current')),\n...       end=\"\")\n*** Original\n--- Current\n***************\n*** 1,4 ****\n  one\n! two\n! three\n  four\n--- 1,4 ----\n+ zero\n  one\n! tree\n  four", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_close_matches", 
  "doc": "Use SequenceMatcher to return list of the best \"good enough\" matches.\n\nword is a sequence for which close matches are desired (typically a\nstring).\n\npossibilities is a list of sequences against which to match word\n(typically a list of strings).\n\nOptional arg n (default 3) is the maximum number of close matches to\nreturn.  n must be > 0.\n\nOptional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\nthat don't score at least that similar to word are ignored.\n\nThe best (no more than n) matches among the possibilities are returned\nin a list, sorted by similarity score, most similar first.\n\n>>> get_close_matches(\"appel\", [\"ape\", \"apple\", \"peach\", \"puppy\"])\n['apple', 'ape']\n>>> import keyword as _keyword\n>>> get_close_matches(\"wheel\", _keyword.kwlist)\n['while']\n>>> get_close_matches(\"Apple\", _keyword.kwlist)\n[]\n>>> get_close_matches(\"accept\", _keyword.kwlist)\n['except']", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!", 
  "line": 0, 
  "type": "module", 
  "name": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py"
 }, 
 {
  "name": "ndiff", 
  "doc": "Compare `a` and `b` (lists of strings); return a `Differ`-style delta.\n\nOptional keyword parameters `linejunk` and `charjunk` are for filter\nfunctions (or None):\n\n- linejunk: A function that should accept a single string argument, and\n  return true iff the string is junk.  The default is None, and is\n  recommended; as of Python 2.3, an adaptive notion of \"noise\" lines is\n  used that does a good job on its own.\n\n- charjunk: A function that should accept a string of length 1. The\n  default is module-level function IS_CHARACTER_JUNK, which filters out\n  whitespace characters (a blank or tab; note: bad idea to include newline\n  in this!).\n\nTools/scripts/ndiff.py is a command-line front-end to this function.\n\nExample:\n\n>>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(1),\n...              'ore\\ntree\\nemu\\n'.splitlines(1))\n>>> print(''.join(diff), end=\"\")\n- one\n?  ^\n+ ore\n?  ^\n- two\n- three\n?  -\n+ tree\n+ emu", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "restore", 
  "doc": "Generate one of the two sequences that generated a delta.\n\nGiven a `delta` produced by `Differ.compare()` or `ndiff()`, extract\nlines originating from file 1 or 2 (parameter `which`), stripping off line\nprefixes.\n\nExamples:\n\n>>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(1),\n...              'ore\\ntree\\nemu\\n'.splitlines(1))\n>>> diff = list(diff)\n>>> print(''.join(restore(diff, 1)), end=\"\")\none\ntwo\nthree\n>>> print(''.join(restore(diff, 2)), end=\"\")\nore\ntree\nemu", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unified_diff", 
  "doc": "Compare two sequences of lines; generate the delta as a unified diff.\n\nUnified diffs are a compact way of showing line changes and a few\nlines of context.  The number of context lines is set by 'n' which\ndefaults to three.\n\nBy default, the diff control lines (those with ---, +++, or @@) are\ncreated with a trailing newline.  This is helpful so that inputs\ncreated from file.readlines() result in diffs that are suitable for\nfile.writelines() since both the inputs and outputs have trailing\nnewlines.\n\nFor inputs that do not have trailing newlines, set the lineterm\nargument to \"\" so that the output will be uniformly newline free.\n\nThe unidiff format normally has a header for filenames and modification\ntimes.  Any or all of these may be specified using strings for\n'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\nThe modification times are normally expressed in the ISO 8601 format.\n\nExample:\n\n>>> for line in unified_diff('one two three four'.split(),\n...             'zero one tree four'.split(), 'Original', 'Current',\n...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',\n...             lineterm=''):\n...     print(line)                 # doctest: +NORMALIZE_WHITESPACE\n--- Original        2005-01-26 23:30:50\n+++ Current         2010-04-02 10:20:52\n@@ -1,4 +1,4 @@\n+zero\n one\n-two\n-three\n+tree\n four", 
  "module": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "_disassemble_bytes", 
  "doc": null, 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_disassemble_str", 
  "doc": "Compile the source string, then disassemble the code object.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_code_info", 
  "doc": null, 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": "Simple test program to disassemble a file.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_try_compile", 
  "doc": "Attempts to compile the given source, first as an expression and\nthen as a statement if the first approach fails.\n\nUtility function to accept strings in functions that otherwise\nexpect code objects", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "code_info", 
  "doc": "Formatted details of methods, functions, or code.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dis", 
  "doc": "Disassemble classes, methods, functions, or code.\n\nWith no argument, disassemble the last traceback.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "disassemble", 
  "doc": "Disassemble a code object.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "disco", 
  "doc": "Disassemble a code object.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "distb", 
  "doc": "Disassemble a traceback (default: last traceback).", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findlabels", 
  "doc": "Detect all offsets in a byte code which are jump targets.\n\nReturn the list of offsets.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findlinestarts", 
  "doc": "Find the offsets in a byte code which are start of lines in the source.\n\nGenerate pairs (offset, lineno) as described in Python/compile.c.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pretty_flags", 
  "doc": "Return pretty representation of code flags.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "show_code", 
  "doc": "Print details of methods, functions, or code to stdout.", 
  "module": "dis", 
  "file": "/usr/lib/python3.2/dis.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Define names for built-in types that aren't directly accessible as a builtin.", 
  "line": 0, 
  "type": "module", 
  "name": "types", 
  "file": "/usr/lib/python3.2/types.py"
 }, 
 {
  "name": "DebugRunner", 
  "doc": "Run doc tests but raise an exception as soon as there is a failure.\n\nIf an unexpected exception occurs, an UnexpectedException is raised.\nIt contains the test, the example, and the original exception:\n\n  >>> runner = DebugRunner(verbose=False)\n  >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n  ...                                    {}, 'foo', 'foo.py', 0)\n  >>> try:\n  ...     runner.run(test)\n  ... except UnexpectedException as f:\n  ...     failure = f\n\n  >>> failure.test is test\n  True\n\n  >>> failure.example.want\n  '42\\n'\n\n  >>> exc_info = failure.exc_info\n  >>> raise exc_info[1] # Already has the traceback\n  Traceback (most recent call last):\n  ...\n  KeyError\n\nWe wrap the original exception to give the calling application\naccess to the test and example information.\n\nIf the output doesn't match, then a DocTestFailure is raised:\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 1\n  ...      >>> x\n  ...      2\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> try:\n  ...    runner.run(test)\n  ... except DocTestFailure as f:\n  ...    failure = f\n\nDocTestFailure objects provide access to the test:\n\n  >>> failure.test is test\n  True\n\nAs well as to the example:\n\n  >>> failure.example.want\n  '2\\n'\n\nand the actual output:\n\n  >>> failure.got\n  '1\\n'\n\nIf a failure or error occurs, the globals are left intact:\n\n  >>> del test.globs['__builtins__']\n  >>> test.globs\n  {'x': 1}\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 2\n  ...      >>> raise KeyError\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> runner.run(test)\n  Traceback (most recent call last):\n  ...\n  doctest.UnexpectedException: <DocTest foo from foo.py:0 (2 examples)>\n\n  >>> del test.globs['__builtins__']\n  >>> test.globs\n  {'x': 2}\n\nBut the globals are cleared if there is no error:\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 2\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> runner.run(test)\n  TestResults(failed=0, attempted=1)\n\n  >>> test.globs\n  {}", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocFileCase", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocFileSuite", 
  "doc": "A unittest suite for one or more doctest files.\n\nThe path to each doctest file is given as a string; the\ninterpretation of that string depends on the keyword argument\n\"module_relative\".\n\nA number of options may be provided as keyword arguments:\n\nmodule_relative\n  If \"module_relative\" is True, then the given file paths are\n  interpreted as os-independent module-relative paths.  By\n  default, these paths are relative to the calling module's\n  directory; but if the \"package\" argument is specified, then\n  they are relative to that package.  To ensure os-independence,\n  \"filename\" should use \"/\" characters to separate path\n  segments, and may not be an absolute path (i.e., it may not\n  begin with \"/\").\n\n  If \"module_relative\" is False, then the given file paths are\n  interpreted as os-specific paths.  These paths may be absolute\n  or relative (to the current working directory).\n\npackage\n  A Python package or the name of a Python package whose directory\n  should be used as the base directory for module relative paths.\n  If \"package\" is not specified, then the calling module's\n  directory is used as the base directory for module relative\n  filenames.  It is an error to specify \"package\" if\n  \"module_relative\" is False.\n\nsetUp\n  A set-up function.  This is called before running the\n  tests in each file. The setUp function will be passed a DocTest\n  object.  The setUp function can access the test globals as the\n  globs attribute of the test passed.\n\ntearDown\n  A tear-down function.  This is called after running the\n  tests in each file.  The tearDown function will be passed a DocTest\n  object.  The tearDown function can access the test globals as the\n  globs attribute of the test passed.\n\nglobs\n  A dictionary containing initial global variables for the tests.\n\noptionflags\n  A set of doctest option flags expressed as an integer.\n\nparser\n  A DocTestParser (or subclass) that should be used to extract\n  tests from the files.\n\nencoding\n  An encoding that will be used to convert the files to unicode.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "DocFileTest", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "DocTest", 
  "doc": "A collection of doctest examples that should be run in a single\nnamespace.  Each `DocTest` defines the following attributes:\n\n  - examples: the list of examples.\n\n  - globs: The namespace (aka globals) that the examples should\n    be run in.\n\n  - name: A name identifying the DocTest (typically, the name of\n    the object whose docstring this DocTest was extracted from).\n\n  - filename: The name of the file that this DocTest was extracted\n    from, or `None` if the filename is unknown.\n\n  - lineno: The line number within filename where this DocTest\n    begins, or `None` if the line number is unavailable.  This\n    line number is zero-based, with respect to the beginning of\n    the file.\n\n  - docstring: The string that the examples were extracted from,\n    or `None` if the string is unavailable.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocTestCase", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocTestFailure", 
  "doc": "A DocTest example has failed in debugging mode.\n\nThe exception instance has variables:\n\n- test: the DocTest object being run\n\n- example: the Example object that failed\n\n- got: the actual output", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocTestFinder", 
  "doc": "A class used to extract the DocTests that are relevant to a given\nobject, from its docstring and the docstrings of its contained\nobjects.  Doctests can currently be extracted from the following\nobject types: modules, functions, classes, methods, staticmethods,\nclassmethods, and properties.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocTestParser", 
  "doc": "A class used to parse strings containing doctest examples.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocTestRunner", 
  "doc": "A class used to run DocTest test cases, and accumulate statistics.\nThe `run` method is used to process a single DocTest case.  It\nreturns a tuple `(f, t)`, where `t` is the number of test cases\ntried, and `f` is the number of test cases that failed.\n\n    >>> tests = DocTestFinder().find(_TestClass)\n    >>> runner = DocTestRunner(verbose=False)\n    >>> tests.sort(key = lambda test: test.name)\n    >>> for test in tests:\n    ...     print(test.name, '->', runner.run(test))\n    _TestClass -> TestResults(failed=0, attempted=2)\n    _TestClass.__init__ -> TestResults(failed=0, attempted=2)\n    _TestClass.get -> TestResults(failed=0, attempted=2)\n    _TestClass.square -> TestResults(failed=0, attempted=1)\n\nThe `summarize` method prints a summary of all the test cases that\nhave been run by the runner, and returns an aggregated `(f, t)`\ntuple:\n\n    >>> runner.summarize(verbose=1)\n    4 items passed all tests:\n       2 tests in _TestClass\n       2 tests in _TestClass.__init__\n       2 tests in _TestClass.get\n       1 tests in _TestClass.square\n    7 tests in 4 items.\n    7 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=7)\n\nThe aggregated number of tried examples and failed examples is\nalso available via the `tries` and `failures` attributes:\n\n    >>> runner.tries\n    7\n    >>> runner.failures\n    0\n\nThe comparison between expected outputs and actual outputs is done\nby an `OutputChecker`.  This comparison may be customized with a\nnumber of option flags; see the documentation for `testmod` for\nmore information.  If the option flags are insufficient, then the\ncomparison may also be customized by passing a subclass of\n`OutputChecker` to the constructor.\n\nThe test runner's display output can be controlled in two ways.\nFirst, an output function (`out) can be passed to\n`TestRunner.run`; this function will be called with strings that\nshould be displayed.  It defaults to `sys.stdout.write`.  If\ncapturing the output is not sufficient, then the display output\ncan be also customized by subclassing DocTestRunner, and\noverriding the methods `report_start`, `report_success`,\n`report_unexpected_exception`, and `report_failure`.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DocTestSuite", 
  "doc": "Convert doctest tests for a module to a unittest test suite.\n\nThis converts each documentation string in a module that\ncontains doctest tests to a unittest test case.  If any of the\ntests in a doc string fail, then the test case fails.  An exception\nis raised showing the name of the file containing the test and a\n(sometimes approximate) line number.\n\nThe `module` argument provides the module to be tested.  The argument\ncan be either a module or a module name.\n\nIf no argument is given, the calling module is used.\n\nA number of options may be provided as keyword arguments:\n\nsetUp\n  A set-up function.  This is called before running the\n  tests in each file. The setUp function will be passed a DocTest\n  object.  The setUp function can access the test globals as the\n  globs attribute of the test passed.\n\ntearDown\n  A tear-down function.  This is called after running the\n  tests in each file.  The tearDown function will be passed a DocTest\n  object.  The tearDown function can access the test globals as the\n  globs attribute of the test passed.\n\nglobs\n  A dictionary containing initial global variables for the tests.\n\noptionflags\n   A set of doctest option flags expressed as an integer.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Example", 
  "doc": "A single doctest example, consisting of source code and expected\noutput.  `Example` defines the following attributes:\n\n  - source: A single Python statement, always ending with a newline.\n    The constructor adds a newline if needed.\n\n  - want: The expected output from running the source code (either\n    from stdout, or a traceback in case of exception).  `want` ends\n    with a newline unless it's empty, in which case it's an empty\n    string.  The constructor adds a newline if needed.\n\n  - exc_msg: The exception message generated by the example, if\n    the example is expected to generate an exception; or `None` if\n    it is not expected to generate an exception.  This exception\n    message is compared against the return value of\n    `traceback.format_exception_only()`.  `exc_msg` ends with a\n    newline unless it's `None`.  The constructor adds a newline\n    if needed.\n\n  - lineno: The line number within the DocTest string containing\n    this Example where the Example begins.  This line number is\n    zero-based, with respect to the beginning of the DocTest.\n\n  - indent: The example's indentation in the DocTest string.\n    I.e., the number of space characters that preceed the\n    example's first prompt.\n\n  - options: A dictionary mapping from option flags to True or\n    False, which is used to override default options for this\n    example.  Any option flags not contained in this dictionary\n    are left at their default value (as specified by the\n    DocTestRunner's optionflags).  By default, no options are set.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OutputChecker", 
  "doc": "A class used to check the whether the actual output from a doctest\nexample matches the expected output.  `OutputChecker` defines two\nmethods: `check_output`, which compares a given pair of outputs,\nand returns true if they match; and `output_difference`, which\nreturns a string describing the differences between two outputs.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SkipDocTestCase", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TestResults", 
  "doc": "TestResults(failed, attempted)", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnexpectedException", 
  "doc": "A DocTest example has encountered an unexpected exception\n\nThe exception instance has variables:\n\n- test: the DocTest object being run\n\n- example: the Example object that failed\n\n- exc_info: the exception info", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_OutputRedirectingPdb", 
  "doc": "A specialized version of the python debugger that redirects stdout\nto a given stream when interacting with the user.  Stdout is *not*\nredirected when traced code is executed.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_SpoofOut", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_TestClass", 
  "doc": "A pointless class, for sanity-checking of docstring testing.\n\nMethods:\n    square()\n    get()\n\n>>> _TestClass(13).get() + _TestClass(-12).get()\n1\n>>> hex(_TestClass(13).square().get())\n'0xa9'", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Record of phased-in incompatible language changes.\n\nEach line is of the form:\n\n    FeatureName = \"_Feature(\" OptionalRelease \",\" MandatoryRelease \",\"\n                              CompilerFlag \")\"\n\nwhere, normally, OptionalRelease < MandatoryRelease, and both are 5-tuples\nof the same form as sys.version_info:\n\n    (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int\n     PY_MINOR_VERSION, # the 1; an int\n     PY_MICRO_VERSION, # the 0; an int\n     PY_RELEASE_LEVEL, # \"alpha\", \"beta\", \"candidate\" or \"final\"; string\n     PY_RELEASE_SERIAL # the 3; an int\n    )\n\nOptionalRelease records the first release in which\n\n    from __future__ import FeatureName\n\nwas accepted.\n\nIn the case of MandatoryReleases that have not yet occurred,\nMandatoryRelease predicts the release in which the feature will become part\nof the language.\n\nElse MandatoryRelease records when the feature became part of the language;\nin releases at or after that, modules no longer need\n\n    from __future__ import FeatureName\n\nto use the feature in question, but may continue to use such imports.\n\nMandatoryRelease may also be None, meaning that a planned feature got\ndropped.\n\nInstances of class _Feature have two corresponding methods,\n.getOptionalRelease() and .getMandatoryRelease().\n\nCompilerFlag is the (bitfield) flag that should be passed in the fourth\nargument to the builtin function compile() to enable the feature in\ndynamically compiled code.  This flag is stored in the .compiler_flag\nattribute on _Future instances.  These values must match the appropriate\n#defines of CO_xxx flags in Include/compile.h.\n\nNo feature line is ever to be deleted from this file.", 
  "line": 0, 
  "type": "module", 
  "name": "__future__", 
  "file": "/usr/lib/python3.2/__future__.py"
 }, 
 {
  "name": "_comment_line", 
  "doc": "Return a commented form of the given line", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ellipsis_match", 
  "doc": "Essentially the only subtle case:\n>>> _ellipsis_match('aa...aa', 'aaa')\nFalse", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_exception_traceback", 
  "doc": "Return a string containing a traceback message for the given\nexc_info tuple (as returned by sys.exc_info()).", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_extract_future_flags", 
  "doc": "Return the compiler-flags associated with the future features that\nhave been imported into the given namespace (globs).", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_indent", 
  "doc": "Add the given number of space characters to the beginning of\nevery non-blank line in `s`, and return the result.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_load_testfile", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_module_relative_path", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_normalize_module", 
  "doc": "Return the module specified by `module`.  In particular:\n  - If `module` is a module, then return module.\n  - If `module` is a string, then import and return the\n    module with that name.\n  - If `module` is None, then return the calling module.\n    The calling module is assumed to be the module of\n    the stack frame at the given depth in the call stack.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "debug", 
  "doc": "Debug a single doctest docstring.\n\nProvide the module (or dotted name of the module) containing the\ntest to be debugged and the name (within the module) of the object\nwith the docstring with tests to be debugged.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "debug_script", 
  "doc": "Debug a test script.  `src` is the script, as a string.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "debug_src", 
  "doc": "Debug a single doctest docstring, in argument `src`'", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Module difflib -- helpers for computing deltas between objects.\n\nFunction get_close_matches(word, possibilities, n=3, cutoff=0.6):\n    Use SequenceMatcher to return list of the best \"good enough\" matches.\n\nFunction context_diff(a, b):\n    For two lists of strings, return a delta in context diff format.\n\nFunction ndiff(a, b):\n    Return a delta: the difference between `a` and `b` (lists of strings).\n\nFunction restore(delta, which):\n    Return one of the two sequences that generated an ndiff delta.\n\nFunction unified_diff(a, b):\n    For two lists of strings, return a delta in unified diff format.\n\nClass SequenceMatcher:\n    A flexible class for comparing pairs of sequences of any type.\n\nClass Differ:\n    For producing human-readable deltas from sequences of lines of text.\n\nClass HtmlDiff:\n    For producing HTML side by side comparison with change highlights.", 
  "line": 0, 
  "type": "module", 
  "name": "difflib", 
  "file": "/usr/lib/python3.2/difflib.py"
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "The Python Debugger Pdb\n=======================\n\nTo use the debugger in its simplest form:\n\n        >>> import pdb\n        >>> pdb.run('<a statement>')\n\nThe debugger's prompt is '(Pdb) '.  This will stop in the first\nfunction call in <a statement>.\n\nAlternatively, if a statement terminated with an unhandled exception,\nyou can use pdb's post-mortem facility to inspect the contents of the\ntraceback:\n\n        >>> <a statement>\n        <exception traceback>\n        >>> import pdb\n        >>> pdb.pm()\n\nThe commands recognized by the debugger are listed in the next\nsection.  Most can be abbreviated as indicated; e.g., h(elp) means\nthat 'help' can be typed as 'h' or 'help' (but not as 'he' or 'hel',\nnor as 'H' or 'Help' or 'HELP').  Optional arguments are enclosed in\nsquare brackets.  Alternatives in the command syntax are separated\nby a vertical bar (|).\n\nA blank line repeats the previous command literally, except for\n'list', where it lists the next 11 lines.\n\nCommands that the debugger doesn't recognize are assumed to be Python\nstatements and are executed in the context of the program being\ndebugged.  Python statements can also be prefixed with an exclamation\npoint ('!').  This is a powerful way to inspect the program being\ndebugged; it is even possible to change variables or call functions.\nWhen an exception occurs in such a statement, the exception name is\nprinted but the debugger's state is not changed.\n\nThe debugger supports aliases, which can save typing.  And aliases can\nhave parameters (see the alias help entry) which allows one a certain\nlevel of adaptability to the context under examination.\n\nMultiple commands may be entered on a single line, separated by the\npair ';;'.  No intelligence is applied to separating the commands; the\ninput is split at the first ';;', even if it is in the middle of a\nquoted string.\n\nIf a file \".pdbrc\" exists in your home directory or in the current\ndirectory, it is read in and executed as if it had been typed at the\ndebugger prompt.  This is particularly useful for aliases.  If both\nfiles exist, the one in the home directory is read first and aliases\ndefined there can be overriden by the local file.\n\nAside from aliases, the debugger is not directly programmable; but it\nis implemented as a class from which you can derive your own debugger\nclass, which you can make as fancy as you like.\n\n\nDebugger commands\n=================\n\nh(elp)\n        Without argument, print the list of available commands.\n        With a command name as argument, print help about that command.\n        \"help pdb\" shows the full pdb documentation.\n        \"help exec\" gives help on the ! command.\n\nw(here)\n        Print a stack trace, with the most recent frame at the bottom.\n        An arrow indicates the \"current frame\", which determines the\n        context of most commands.  'bt' is an alias for this command.\n\nd(own) [count]\n        Move the current frame count (default one) levels down in the\n        stack trace (to a newer frame).\n\nu(p) [count]\n        Move the current frame count (default one) levels up in the\n        stack trace (to an older frame).\n\nb(reak) [ ([filename:]lineno | function) [, condition] ]\n        Without argument, list all breaks.\n\n        With a line number argument, set a break at this line in the\n        current file.  With a function name, set a break at the first\n        executable line of that function.  If a second argument is\n        present, it is a string specifying an expression which must\n        evaluate to true before the breakpoint is honored.\n\n        The line number may be prefixed with a filename and a colon,\n        to specify a breakpoint in another file (probably one that\n        hasn't been loaded yet).  The file is searched for on\n        sys.path; the .py suffix may be omitted.\n\ntbreak [ ([filename:]lineno | function) [, condition] ]\n        Same arguments as break, but sets a temporary breakpoint: it\n        is automatically deleted when first hit.\n\ncl(ear) filename:lineno\ncl(ear) [bpnumber [bpnumber...]]\n        With a space separated list of breakpoint numbers, clear\n        those breakpoints.  Without argument, clear all breaks (but\n        first ask confirmation).  With a filename:lineno argument,\n        clear all breaks at that line in that file.\n\ndisable bpnumber [bpnumber ...]\n        Disables the breakpoints given as a space separated list of\n        breakpoint numbers.  Disabling a breakpoint means it cannot\n        cause the program to stop execution, but unlike clearing a\n        breakpoint, it remains in the list of breakpoints and can be\n        (re-)enabled.\n\nenable bpnumber [bpnumber ...]\n        Enables the breakpoints given as a space separated list of\n        breakpoint numbers.\n\nignore bpnumber [count]\n        Set the ignore count for the given breakpoint number.  If\n        count is omitted, the ignore count is set to 0.  A breakpoint\n        becomes active when the ignore count is zero.  When non-zero,\n        the count is decremented each time the breakpoint is reached\n        and the breakpoint is not disabled and any associated\n        condition evaluates to true.\n\ncondition bpnumber [condition]\n        Set a new condition for the breakpoint, an expression which\n        must evaluate to true before the breakpoint is honored.  If\n        condition is absent, any existing condition is removed; i.e.,\n        the breakpoint is made unconditional.\n\ncommands [bpnumber]\n        (com) ...\n        (com) end\n        (Pdb)\n\n        Specify a list of commands for breakpoint number bpnumber.\n        The commands themselves are entered on the following lines.\n        Type a line containing just 'end' to terminate the commands.\n        The commands are executed when the breakpoint is hit.\n\n        To remove all commands from a breakpoint, type commands and\n        follow it immediately with end; that is, give no commands.\n\n        With no bpnumber argument, commands refers to the last\n        breakpoint set.\n\n        You can use breakpoint commands to start your program up\n        again.  Simply use the continue command, or step, or any other\n        command that resumes execution.\n\n        Specifying any command resuming execution (currently continue,\n        step, next, return, jump, quit and their abbreviations)\n        terminates the command list (as if that command was\n        immediately followed by end).  This is because any time you\n        resume execution (even with a simple next or step), you may\n        encounter another breakpoint -- which could have its own\n        command list, leading to ambiguities about which list to\n        execute.\n\n        If you use the 'silent' command in the command list, the usual\n        message about stopping at a breakpoint is not printed.  This\n        may be desirable for breakpoints that are to print a specific\n        message and then continue.  If none of the other commands\n        print anything, you will see no sign that the breakpoint was\n        reached.\n\ns(tep)\n        Execute the current line, stop at the first possible occasion\n        (either in a function that is called or in the current\n        function).\n\nn(ext)\n        Continue execution until the next line in the current function\n        is reached or it returns.\n\nunt(il) [lineno]\n        Without argument, continue execution until the line with a\n        number greater than the current one is reached.  With a line\n        number, continue execution until a line with a number greater\n        or equal to that is reached.  In both cases, also stop when\n        the current frame returns.\n\nj(ump) lineno\n        Set the next line that will be executed.  Only available in\n        the bottom-most frame.  This lets you jump back and execute\n        code again, or jump forward to skip code that you don't want\n        to run.\n\n        It should be noted that not all jumps are allowed -- for\n        instance it is not possible to jump into the middle of a\n        for loop or out of a finally clause.\n\nr(eturn)\n        Continue execution until the current function returns.\n\nretval\n        Print the return value for the last return of a function.\n\nrun [args...]\n        Restart the debugged python program. If a string is supplied\n        it is splitted with \"shlex\", and the result is used as the new\n        sys.argv.  History, breakpoints, actions and debugger options\n        are preserved.  \"restart\" is an alias for \"run\".\n\nc(ont(inue))\n        Continue execution, only stop when a breakpoint is encountered.\n\nl(ist) [first [,last] | .]\n\n        List source code for the current file.  Without arguments,\n        list 11 lines around the current line or continue the previous\n        listing.  With . as argument, list 11 lines around the current\n        line.  With one argument, list 11 lines starting at that line.\n        With two arguments, list the given range; if the second\n        argument is less than the first, it is a count.\n\n        The current line in the current frame is indicated by \"->\".\n        If an exception is being debugged, the line where the\n        exception was originally raised or propagated is indicated by\n        \">>\", if it differs from the current line.\n\nlonglist | ll\n        List the whole source code for the current function or frame.\n\na(rgs)\n        Print the argument list of the current function.\n\np(rint) expression\n        Print the value of the expression.\n\npp expression\n        Pretty-print the value of the expression.\n\nwhatis arg\n        Print the type of the argument.\n\nsource expression\n        Try to get source code for the given object and display it.\n\ndisplay [expression]\n\n        Display the value of the expression if it changed, each time execution\n        stops in the current frame.\n\n        Without expression, list all display expressions for the current frame.\n\nundisplay [expression]\n\n        Do not display the expression any more in the current frame.\n\n        Without expression, clear all display expressions for the current frame.\n\ninteract\n\n        Start an interative interpreter whose global namespace\n        contains all the (global and local) names found in the current scope.\n\nalias [name [command [parameter parameter ...] ]]\n        Create an alias called 'name' that executes 'command'.  The\n        command must *not* be enclosed in quotes.  Replaceable\n        parameters can be indicated by %1, %2, and so on, while %* is\n        replaced by all the parameters.  If no command is given, the\n        current alias for name is shown. If no name is given, all\n        aliases are listed.\n\n        Aliases may be nested and can contain anything that can be\n        legally typed at the pdb prompt.  Note!  You *can* override\n        internal pdb commands with aliases!  Those internal commands\n        are then hidden until the alias is removed.  Aliasing is\n        recursively applied to the first word of the command line; all\n        other words in the line are left alone.\n\n        As an example, here are two useful aliases (especially when\n        placed in the .pdbrc file):\n\n        # Print instance variables (usage \"pi classInst\")\n        alias pi for k in %1.__dict__.keys(): print \"%1.\",k,\"=\",%1.__dict__[k]\n        # Print instance variables in self\n        alias ps pi self\n\nunalias name\n        Delete the specified alias.\n\ndebug code\n        Enter a recursive debugger that steps through the code\n        argument (which is an arbitrary expression or statement to be\n        executed in the current environment).\n\nq(uit)\nexit\n        Quit from the debugger. The program being executed is aborted.\n\n(!) statement\n        Execute the (one-line) statement in the context of the current\n        stack frame.  The exclamation point can be omitted unless the\n        first word of the statement resembles a debugger command.  To\n        assign to a global variable you must always prefix the command\n        with a 'global' command, e.g.:\n        (Pdb) global list_options; list_options = ['-l']\n        (Pdb)\n        ", 
  "line": 0, 
  "type": "module", 
  "name": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "register_optionflag", 
  "doc": null, 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "run_docstring_examples", 
  "doc": "Test examples in the given object's docstring (`f`), using `globs`\nas globals.  Optional argument `name` is used in failure messages.\nIf the optional argument `verbose` is true, then generate output\neven if there are no failures.\n\n`compileflags` gives the set of flags that should be used by the\nPython compiler when running the examples.  If not specified, then\nit will default to the set of future-import flags that apply to\n`globs`.\n\nOptional keyword arg `optionflags` specifies options for the\ntesting and output.  See the documentation for `testmod` for more\ninformation.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "script_from_examples", 
  "doc": "Extract script from text with examples.\n\nConverts text with examples to a Python script.  Example input is\nconverted to regular code.  Example output and all other words\nare converted to comments:\n\n>>> text = '''\n...       Here are examples of simple math.\n...\n...           Python has super accurate integer addition\n...\n...           >>> 2 + 2\n...           5\n...\n...           And very friendly error messages:\n...\n...           >>> 1/0\n...           To Infinity\n...           And\n...           Beyond\n...\n...           You can use logic if you want:\n...\n...           >>> if 0:\n...           ...    blah\n...           ...    blah\n...           ...\n...\n...           Ho hum\n...           '''\n\n>>> print(script_from_examples(text))\n# Here are examples of simple math.\n#\n#     Python has super accurate integer addition\n#\n2 + 2\n# Expected:\n## 5\n#\n#     And very friendly error messages:\n#\n1/0\n# Expected:\n## To Infinity\n## And\n## Beyond\n#\n#     You can use logic if you want:\n#\nif 0:\n   blah\n   blah\n#\n#     Ho hum\n<BLANKLINE>", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_unittest_reportflags", 
  "doc": "Sets the unittest option flags.\n\nThe old flag is returned so that a runner could restore the old\nvalue if it wished to:\n\n  >>> import doctest\n  >>> old = doctest._unittest_reportflags\n  >>> doctest.set_unittest_reportflags(REPORT_NDIFF |\n  ...                          REPORT_ONLY_FIRST_FAILURE) == old\n  True\n\n  >>> doctest._unittest_reportflags == (REPORT_NDIFF |\n  ...                                   REPORT_ONLY_FIRST_FAILURE)\n  True\n\nOnly reporting flags can be set:\n\n  >>> doctest.set_unittest_reportflags(ELLIPSIS)\n  Traceback (most recent call last):\n  ...\n  ValueError: ('Only reporting flags allowed', 8)\n\n  >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |\n  ...                                   REPORT_ONLY_FIRST_FAILURE)\n  True", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "testfile", 
  "doc": "Test examples in the given file.  Return (#failures, #tests).\n\nOptional keyword arg \"module_relative\" specifies how filenames\nshould be interpreted:\n\n  - If \"module_relative\" is True (the default), then \"filename\"\n     specifies a module-relative path.  By default, this path is\n     relative to the calling module's directory; but if the\n     \"package\" argument is specified, then it is relative to that\n     package.  To ensure os-independence, \"filename\" should use\n     \"/\" characters to separate path segments, and should not\n     be an absolute path (i.e., it may not begin with \"/\").\n\n  - If \"module_relative\" is False, then \"filename\" specifies an\n    os-specific path.  The path may be absolute or relative (to\n    the current working directory).\n\nOptional keyword arg \"name\" gives the name of the test; by default\nuse the file's basename.\n\nOptional keyword argument \"package\" is a Python package or the\nname of a Python package whose directory should be used as the\nbase directory for a module relative filename.  If no package is\nspecified, then the calling module's directory is used as the base\ndirectory for module relative filenames.  It is an error to\nspecify \"package\" if \"module_relative\" is False.\n\nOptional keyword arg \"globs\" gives a dict to be used as the globals\nwhen executing examples; by default, use {}.  A copy of this dict\nis actually used for each docstring, so that each docstring's\nexamples start with a clean slate.\n\nOptional keyword arg \"extraglobs\" gives a dictionary that should be\nmerged into the globals that are used to execute examples.  By\ndefault, no extra globals are used.\n\nOptional keyword arg \"verbose\" prints lots of stuff if true, prints\nonly failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\nOptional keyword arg \"report\" prints a summary at the end when true,\nelse prints nothing at the end.  In verbose mode, the summary is\ndetailed, else very brief (in fact, empty if all tests passed).\n\nOptional keyword arg \"optionflags\" or's together module constants,\nand defaults to 0.  Possible values (see the docs for details):\n\n    DONT_ACCEPT_TRUE_FOR_1\n    DONT_ACCEPT_BLANKLINE\n    NORMALIZE_WHITESPACE\n    ELLIPSIS\n    SKIP\n    IGNORE_EXCEPTION_DETAIL\n    REPORT_UDIFF\n    REPORT_CDIFF\n    REPORT_NDIFF\n    REPORT_ONLY_FIRST_FAILURE\n\nOptional keyword arg \"raise_on_error\" raises an exception on the\nfirst unexpected exception or failure. This allows failures to be\npost-mortem debugged.\n\nOptional keyword arg \"parser\" specifies a DocTestParser (or\nsubclass) that should be used to extract tests from the files.\n\nOptional keyword arg \"encoding\" specifies an encoding that should\nbe used to convert the file to unicode.\n\nAdvanced tomfoolery:  testmod runs methods of a local instance of\nclass doctest.Tester, then merges the results into (or creates)\nglobal Tester instance doctest.master.  Methods of doctest.master\ncan be called directly too, if you want to do something unusual.\nPassing report=0 to testmod is especially useful then, to delay\ndisplaying a summary.  Invoke doctest.master.summarize(verbose)\nwhen you're done fiddling.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "testmod", 
  "doc": "m=None, name=None, globs=None, verbose=None, report=True,\n   optionflags=0, extraglobs=None, raise_on_error=False,\n   exclude_empty=False\n\nTest examples in docstrings in functions and classes reachable\nfrom module m (or the current module if m is not supplied), starting\nwith m.__doc__.\n\nAlso test examples reachable from dict m.__test__ if it exists and is\nnot None.  m.__test__ maps names to functions, classes and strings;\nfunction and class docstrings are tested even if the name is private;\nstrings are tested directly, as if they were docstrings.\n\nReturn (#failures, #tests).\n\nSee help(doctest) for an overview.\n\nOptional keyword arg \"name\" gives the name of the module; by default\nuse m.__name__.\n\nOptional keyword arg \"globs\" gives a dict to be used as the globals\nwhen executing examples; by default, use m.__dict__.  A copy of this\ndict is actually used for each docstring, so that each docstring's\nexamples start with a clean slate.\n\nOptional keyword arg \"extraglobs\" gives a dictionary that should be\nmerged into the globals that are used to execute examples.  By\ndefault, no extra globals are used.  This is new in 2.4.\n\nOptional keyword arg \"verbose\" prints lots of stuff if true, prints\nonly failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\nOptional keyword arg \"report\" prints a summary at the end when true,\nelse prints nothing at the end.  In verbose mode, the summary is\ndetailed, else very brief (in fact, empty if all tests passed).\n\nOptional keyword arg \"optionflags\" or's together module constants,\nand defaults to 0.  This is new in 2.3.  Possible values (see the\ndocs for details):\n\n    DONT_ACCEPT_TRUE_FOR_1\n    DONT_ACCEPT_BLANKLINE\n    NORMALIZE_WHITESPACE\n    ELLIPSIS\n    SKIP\n    IGNORE_EXCEPTION_DETAIL\n    REPORT_UDIFF\n    REPORT_CDIFF\n    REPORT_NDIFF\n    REPORT_ONLY_FIRST_FAILURE\n\nOptional keyword arg \"raise_on_error\" raises an exception on the\nfirst unexpected exception or failure. This allows failures to be\npost-mortem debugged.\n\nAdvanced tomfoolery:  testmod runs methods of a local instance of\nclass doctest.Tester, then merges the results into (or creates)\nglobal Tester instance doctest.master.  Methods of doctest.master\ncan be called directly too, if you want to do something unusual.\nPassing report=0 to testmod is especially useful then, to delay\ndisplaying a summary.  Invoke doctest.master.summarize(verbose)\nwhen you're done fiddling.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "testsource", 
  "doc": "Extract the test sources from a doctest docstring as a script.\n\nProvide the module (or dotted name of the module) containing the\ntest to be debugged and the name (within the module) of the object\nwith the doc string with tests to be debugged.", 
  "module": "doctest", 
  "file": "/usr/lib/python3.2/doctest.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "doc": "Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin 'test*'\n            self.assertEqual((1 + 2), 3)\n            self.assertEqual(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEqual((0 * 10), 0)\n            self.assertEqual((5 * 8), 40)\n\n    if __name__ == '__main__':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/library/unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nCopyright (c) 2003-2010 Python Software Foundation\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN \"AS IS\" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.", 
  "line": 0, 
  "type": "module", 
  "name": "unittest", 
  "file": "/usr/lib/python3.2/unittest/__init__.py"
 }, 
 {
  "name": "Barrier", 
  "doc": "Barrier.  Useful for synchronizing a fixed number of threads\nat known synchronization points.  Threads block on 'wait()' and are\nsimultaneously once they have all made that call.", 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BoundedSemaphore", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Condition", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Event", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Lock", 
  "doc": "Dummy implementation of _thread.allocate_lock().", 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/_dummy_thread.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RLock", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Semaphore", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Thread", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Timer", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "active_count", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "current_thread", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "enumerate", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "local", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/_threading_local.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "setprofile", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "settrace", 
  "doc": null, 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "stack_size", 
  "doc": "Dummy implementation of _thread.stack_size().", 
  "module": "dummy_threading", 
  "file": "/usr/lib/python3.2/_dummy_thread.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Thread module emulating a subset of Java's threading model.", 
  "line": 0, 
  "type": "module", 
  "name": "threading", 
  "file": "/usr/lib/python3.2/threading.py"
 }, 
 {
  "doc": "Email address parsing code.\n\nLifted directly from rfc822.py.  This should eventually be rewritten.", 
  "line": 0, 
  "type": "module", 
  "name": "_parseaddr", 
  "file": "/usr/lib/python3.2/email/_parseaddr.py"
 }, 
 {
  "doc": "Base64 content transfer encoding per RFCs 2045-2047.\n\nThis module handles the content transfer encoding method defined in RFC 2045\nto encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit\ncharacters encoding known as Base64.\n\nIt is used in the MIME standards for email to attach images, audio, and text\nusing some 8-bit character sets to messages.\n\nThis module provides an interface to encode and decode both headers and bodies\nwith Base64 encoding.\n\nRFC 2045 defines a method for including character set information in an\n`encoded-word' in a header.  This method is commonly used for 8-bit real names\nin To:, From:, Cc:, etc. fields, as well as Subject: lines.\n\nThis module does not do the line wrapping or end-of-line character conversion\nnecessary for proper internationalized headers; it only does dumb encoding and\ndecoding.  To deal with the various line wrapping issues, use the email.header\nmodule.", 
  "line": 0, 
  "type": "module", 
  "name": "base64mime", 
  "file": "/usr/lib/python3.2/email/base64mime.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "charset", 
  "file": "/usr/lib/python3.2/email/charset.py"
 }, 
 {
  "doc": "Encodings and related functions.", 
  "line": 0, 
  "type": "module", 
  "name": "encoders", 
  "file": "/usr/lib/python3.2/email/encoders.py"
 }, 
 {
  "doc": "email package exception classes.", 
  "line": 0, 
  "type": "module", 
  "name": "errors", 
  "file": "/usr/lib/python3.2/email/errors.py"
 }, 
 {
  "doc": "FeedParser - An email feed parser.\n\nThe feed parser implements an interface for incrementally parsing an email\nmessage, line by line.  This has advantages for certain applications, such as\nthose reading email messages off a socket.\n\nFeedParser.feed() is the primary interface for pushing new data into the\nparser.  It returns when there's nothing more it can do with the available\ndata.  When you have no more data to push into the parser, call .close().\nThis completes the parsing and returns the root message object.\n\nThe other advantage of this parser is that it will never throw a parsing\nexception.  Instead, when it finds something unexpected, it adds a 'defect' to\nthe current message.  Defects are just instances that live on the message\nobject's .defects attribute.", 
  "line": 0, 
  "type": "module", 
  "name": "feedparser", 
  "file": "/usr/lib/python3.2/email/feedparser.py"
 }, 
 {
  "doc": "Classes to generate plain text from a message object tree.", 
  "line": 0, 
  "type": "module", 
  "name": "generator", 
  "file": "/usr/lib/python3.2/email/generator.py"
 }, 
 {
  "doc": "Header encoding and decoding functionality.", 
  "line": 0, 
  "type": "module", 
  "name": "header", 
  "file": "/usr/lib/python3.2/email/header.py"
 }, 
 {
  "doc": "Various types of useful iterators and generators.", 
  "line": 0, 
  "type": "module", 
  "name": "iterators", 
  "file": "/usr/lib/python3.2/email/iterators.py"
 }, 
 {
  "doc": "Basic message object for the email package object model.", 
  "line": 0, 
  "type": "module", 
  "name": "message", 
  "file": "/usr/lib/python3.2/email/message.py"
 }, 
 {
  "name": "message_from_binary_file", 
  "doc": "Read a binary file and parse its contents into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.", 
  "module": "email", 
  "file": "/usr/lib/python3.2/email/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "message_from_bytes", 
  "doc": "Parse a bytes string into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.", 
  "module": "email", 
  "file": "/usr/lib/python3.2/email/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "message_from_file", 
  "doc": "Read a file and parse its contents into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.", 
  "module": "email", 
  "file": "/usr/lib/python3.2/email/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "message_from_string", 
  "doc": "Parse a string into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.", 
  "module": "email", 
  "file": "/usr/lib/python3.2/email/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "A parser of RFC 2822 and MIME email messages.", 
  "line": 0, 
  "type": "module", 
  "name": "parser", 
  "file": "/usr/lib/python3.2/email/parser.py"
 }, 
 {
  "doc": "Quoted-printable content transfer encoding per RFCs 2045-2047.\n\nThis module handles the content transfer encoding method defined in RFC 2045\nto encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to\nsafely encode text that is in a character set similar to the 7-bit US ASCII\ncharacter set, but that includes some 8-bit characters that are normally not\nallowed in email bodies or headers.\n\nQuoted-printable is very space-inefficient for encoding binary files; use the\nemail.base64mime module for that instead.\n\nThis module provides an interface to encode and decode both headers and bodies\nwith quoted-printable encoding.\n\nRFC 2045 defines a method for including character set information in an\n`encoded-word' in a header.  This method is commonly used for 8-bit real names\nin To:/From:/Cc: etc. fields, as well as Subject: lines.\n\nThis module does not do the line wrapping or end-of-line character\nconversion necessary for proper internationalized headers; it only\ndoes dumb encoding and decoding.  To deal with the various line\nwrapping issues, use the email.header module.", 
  "line": 0, 
  "type": "module", 
  "name": "quoprimime", 
  "file": "/usr/lib/python3.2/email/quoprimime.py"
 }, 
 {
  "doc": "Miscellaneous utilities.", 
  "line": 0, 
  "type": "module", 
  "name": "utils", 
  "file": "/usr/lib/python3.2/email/utils.py"
 }, 
 {
  "name": "CodecRegistryError", 
  "doc": null, 
  "module": "encodings", 
  "file": "/usr/lib/python3.2/encodings/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Encoding Aliases Support\n\nThis module is used by the encodings package search function to\nmap encodings names to module names.\n\nNote that the search function normalizes the encoding names before\ndoing the lookup, so the mapping will have to map normalized\nencoding names to module names.\n\nContents:\n\n    The following aliases dictionary contains mappings of all IANA\n    character set names for which the Python core library provides\n    codecs. In addition to these, a few Python specific codec\n    aliases have also been added.", 
  "line": 0, 
  "type": "module", 
  "name": "aliases", 
  "file": "/usr/lib/python3.2/encodings/aliases.py"
 }, 
 {
  "doc": "codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py"
 }, 
 {
  "doc": "Python 'latin-1' Codec\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "latin_1", 
  "file": "/usr/lib/python3.2/encodings/latin_1.py"
 }, 
 {
  "name": "normalize_encoding", 
  "doc": "Normalize an encoding name.\n\nNormalization works as follows: all non-alphanumeric\ncharacters except the dot used for Python package names are\ncollapsed and replaced with a single underscore, e.g. '  -;#'\nbecomes '_'. Leading and trailing underscores are removed.\n\nNote that encoding names should be ASCII only; if they do use\nnon-ASCII characters, these must be Latin-1 compatible.", 
  "module": "encodings", 
  "file": "/usr/lib/python3.2/encodings/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "search_function", 
  "doc": null, 
  "module": "encodings", 
  "file": "/usr/lib/python3.2/encodings/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Python 'utf-8' Codec\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "utf_8", 
  "file": "/usr/lib/python3.2/encodings/utf_8.py"
 }, 
 {
  "name": "_cmp", 
  "doc": null, 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_do_cmp", 
  "doc": null, 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_filter", 
  "doc": null, 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_sig", 
  "doc": null, 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cmp", 
  "doc": "Compare two files.\n\nArguments:\n\nf1 -- First file name\n\nf2 -- Second file name\n\nshallow -- Just check stat signature (do not read the files).\n           defaults to 1.\n\nReturn value:\n\nTrue if the files are the same, False otherwise.\n\nThis function uses a cache for past comparisons and the results,\nwith a cache invalidation mechanism relying on stale signatures.", 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cmpfiles", 
  "doc": "Compare common files in two directories.\n\na, b -- directory names\ncommon -- list of file names found in both directories\nshallow -- if true, do comparison based solely on stat() information\n\nReturns a tuple of three lists:\n  files that compare equal\n  files that are different\n  filenames that aren't regular files.", 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "demo", 
  "doc": null, 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dircmp", 
  "doc": "A class that manages the comparison of 2 directories.\n\ndircmp(a, b, ignore=None, hide=None)\n  A and B are directories.\n  IGNORE is a list of names to ignore,\n    defaults to ['RCS', 'CVS', 'tags'].\n  HIDE is a list of names to hide,\n    defaults to [os.curdir, os.pardir].\n\nHigh level usage:\n  x = dircmp(dir1, dir2)\n  x.report() -> prints a report on the differences between dir1 and dir2\n   or\n  x.report_partial_closure() -> prints report on differences between dir1\n        and dir2, and reports on common immediate subdirectories.\n  x.report_full_closure() -> like report_partial_closure,\n        but fully recursive.\n\nAttributes:\n left_list, right_list: The files in dir1 and dir2,\n    filtered by hide and ignore.\n common: a list of names in both dir1 and dir2.\n left_only, right_only: names only in dir1, dir2.\n common_dirs: subdirectories in both dir1 and dir2.\n common_files: files in both dir1 and dir2.\n common_funny: names in both dir1 and dir2 where the type differs between\n    dir1 and dir2, or the name is not stat-able.\n same_files: list of identical files.\n diff_files: list of filenames which differ.\n funny_files: list of files which could not be compared.\n subdirs: a dictionary of dircmp objects, keyed by names in common_dirs.\n ", 
  "module": "filecmp", 
  "file": "/usr/lib/python3.2/filecmp.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "filterfalse", 
  "doc": "filterfalse(function or None, sequence) --> filterfalse object\n\nReturn those items of sequence for which function(item) is false.\nIf function is None, return the items that are false.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "name": "FileInput", 
  "doc": "class FileInput([files[, inplace[, backup[, mode[, openhook]]]]])\n\nClass FileInput is the implementation of the module; its methods\nfilename(), lineno(), fileline(), isfirstline(), isstdin(), fileno(),\nnextfile() and close() correspond to the functions of the same name\nin the module.\nIn addition it has a readline() method which returns the next\ninput line, and a __getitem__() method which implements the\nsequence behavior. The sequence must be accessed in strictly\nsequential order; random access and readline() cannot be mixed.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "close", 
  "doc": "Close the sequence.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "filelineno", 
  "doc": "Return the line number in the current file. Before the first line\nhas been read, returns 0. After the last line of the last file has\nbeen read, returns the line number of that line within the file.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "filename", 
  "doc": "Return the name of the file currently being read.\nBefore the first line has been read, returns None.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fileno", 
  "doc": "Return the file number of the current file. When no file is currently\nopened, returns -1.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "hook_compressed", 
  "doc": null, 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "hook_encoded", 
  "doc": null, 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "input", 
  "doc": "input(files=None, inplace=False, backup=\"\", bufsize=0, mode=\"r\", openhook=None)\n\nCreate an instance of the FileInput class. The instance will be used\nas global state for the functions of this module, and is also returned\nto use during iteration. The parameters to this function will be passed\nalong to the constructor of the FileInput class.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfirstline", 
  "doc": "Returns true the line just read is the first line of its file,\notherwise returns false.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isstdin", 
  "doc": "Returns true if the last line was read from sys.stdin,\notherwise returns false.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lineno", 
  "doc": "Return the cumulative line number of the line that has just been read.\nBefore the first line has been read, returns 0. After the last line\nof the last file has been read, returns the line number of that line.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nextfile", 
  "doc": "Close the current file so that the next iteration will read the first\nline from the next file (if any); lines not read from the file will\nnot count towards the cumulative line count. The filename is not\nchanged until after the first line of the next file has been read.\nBefore the first line has been read, this function has no effect;\nit cannot be used to skip the first file. After the last line of the\nlast file has been read, this function has no effect.", 
  "module": "fileinput", 
  "file": "/usr/lib/python3.2/fileinput.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "_compile_pattern", 
  "doc": null, 
  "module": "fnmatch", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "filter", 
  "doc": "Return the subset of the list NAMES that match PAT.", 
  "module": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fnmatch", 
  "doc": "Test whether FILENAME matches PATTERN.\n\nPatterns are Unix shell style:\n\n*       matches everything\n?       matches any single character\n[seq]   matches any character in seq\n[!seq]  matches any char not in seq\n\nAn initial period in FILENAME is not special.\nBoth FILENAME and PATTERN are first case-normalized\nif the operating system requires it.\nIf you don't want this, use fnmatchcase(FILENAME, PATTERN).", 
  "module": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fnmatchcase", 
  "doc": "Test whether FILENAME matches PATTERN, including case.\n\nThis is a version of fnmatch() which doesn't case-normalize\nits arguments.", 
  "module": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "functools.py - Tools for working with functions and callable objects", 
  "line": 0, 
  "type": "module", 
  "name": "functools", 
  "file": "/usr/lib/python3.2/functools.py"
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Common operations on Posix pathnames.\n\nInstead of importing this module directly, import os and refer to\nthis module as os.path.  The \"os.path\" name is an alias for this\nmodule on Posix systems; on other systems (e.g. Mac, Windows),\nos.path provides the same operations in a manner specific to that\nplatform, and is an alias to another module (e.g. macpath, ntpath).\n\nSome of this can actually be useful on non-Posix systems too, e.g.\nfor manipulation of the pathname component of URLs.", 
  "line": 0, 
  "type": "module", 
  "name": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "translate", 
  "doc": "Translate a shell PATTERN to a regular expression.\n\nThere is no way to quote meta-characters.", 
  "module": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "AbstractFormatter", 
  "doc": "The standard formatter.\n\nThis implementation has demonstrated wide applicability to many writers,\nand may be used directly in most circumstances.  It has been used to\nimplement a full-featured World Wide Web browser.", 
  "module": "formatter", 
  "file": "/usr/lib/python3.2/formatter.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "AbstractWriter", 
  "doc": "A writer which can be used in debugging formatters, but not much else.\n\nEach method simply announces itself by printing its name and\narguments on standard output.", 
  "module": "formatter", 
  "file": "/usr/lib/python3.2/formatter.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DumbWriter", 
  "doc": "Simple writer class which writes output on the file object passed in\nas the file parameter or, if file is omitted, on standard output.  The\noutput is simply word-wrapped to the number of columns specified by\nthe maxcol parameter.  This class is suitable for reflowing a sequence\nof paragraphs.", 
  "module": "formatter", 
  "file": "/usr/lib/python3.2/formatter.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NullFormatter", 
  "doc": "A formatter which does nothing.\n\nIf the writer parameter is omitted, a NullWriter instance is created.\nNo methods of the writer are called by NullFormatter instances.\n\nImplementations should inherit from this class if implementing a writer\ninterface but don't need to inherit any implementation.", 
  "module": "formatter", 
  "file": "/usr/lib/python3.2/formatter.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NullWriter", 
  "doc": "Minimal writer interface to use in testing & inheritance.\n\nA writer which only provides the interface definition; no actions are\ntaken on any methods.  This should be the base class for all writers\nwhich do not need to inherit any implementation methods.", 
  "module": "formatter", 
  "file": "/usr/lib/python3.2/formatter.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "formatter", 
  "file": "/usr/lib/python3.2/formatter.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Decimal", 
  "doc": "Floating point class for decimal arithmetic.", 
  "module": "fractions", 
  "file": "/usr/lib/python3.2/decimal.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Fraction", 
  "doc": "This class implements rational numbers.\n\nIn the two-argument form of the constructor, Fraction(8, 6) will\nproduce a rational number equivalent to 4/3. Both arguments must\nbe Rational. The numerator defaults to 0 and the denominator\ndefaults to 1 so that Fraction(3) == 3 and Fraction() == 0.\n\nFractions can also be constructed from:\n\n  - numeric strings similar to those accepted by the\n    float constructor (for example, '-2.3' or '1e10')\n\n  - strings of the form '123/456'\n\n  - float and Decimal instances\n\n  - other Rational instances (including integers)", 
  "module": "fractions", 
  "file": "/usr/lib/python3.2/fractions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "gcd", 
  "doc": "Calculate the Greatest Common Divisor of a and b.\n\nUnless b==0, the result will have the same sign as b (so that when\nb is divided by it, the result comes out positive).", 
  "module": "fractions", 
  "file": "/usr/lib/python3.2/fractions.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module is always available.  It provides access to the\nmathematical functions defined by the C standard.", 
  "line": 0, 
  "type": "module", 
  "name": "math", 
  "file": null
 }, 
 {
  "doc": "Abstract Base Classes (ABCs) for numbers, according to PEP 3141.\n\nTODO: Fill out more detailed documentation on the operators.", 
  "line": 0, 
  "type": "module", 
  "name": "numbers", 
  "file": "/usr/lib/python3.2/numbers.py"
 }, 
 {
  "doc": "Operator interface.\n\nThis module exports a set of functions implemented in C corresponding\nto the intrinsic operators of Python.  For example, operator.add(x, y)\nis equivalent to the expression x+y.  The function names are those\nused for special methods; variants without leading and trailing\n'__' are also provided for convenience.", 
  "line": 0, 
  "type": "module", 
  "name": "operator", 
  "file": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FTP", 
  "doc": "An FTP client class.\n\nTo create a connection, call the class using these arguments:\n        host, user, passwd, acct, timeout\n\nThe first four arguments are all strings, and have default value ''.\ntimeout must be numeric and defaults to None if not passed,\nmeaning that no timeout will be set on any ftp socket(s)\nIf a timeout is passed, then this is now the default timeout for all ftp\nsocket operations for this instance.\n\nThen use self.connect() with optional host and port argument.\n\nTo download a file, use ftp.retrlines('RETR ' + filename),\nor ftp.retrbinary() with slightly different arguments.\nTo upload a file, use ftp.storlines() or ftp.storbinary(),\nwhich have an open file as argument (see their definitions\nbelow for details).\nThe download/upload functions first issue appropriate TYPE\nand PORT or PASV commands.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FTP_TLS", 
  "doc": "A FTP subclass which adds TLS support to FTP as described\nin RFC-4217.\n\nConnect as usual to port 21 implicitly securing the FTP control\nconnection before authenticating.\n\nSecuring the data connection requires user to explicitly ask\nfor it by calling prot_p() method.\n\nUsage example:\n>>> from ftplib import FTP_TLS\n>>> ftps = FTP_TLS('ftp.python.org')\n>>> ftps.login()  # login anonymously previously securing control channel\n'230 Guest login ok, access restrictions apply.'\n>>> ftps.prot_p()  # switch to secure data connection\n'200 Protection level set to P'\n>>> ftps.retrlines('LIST')  # list directory content securely\ntotal 9\ndrwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .\ndrwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..\ndrwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin\ndrwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc\nd-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming\ndrwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib\ndrwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub\ndrwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr\n-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg\n'226 Transfer complete.'\n>>> ftps.quit()\n'221 Goodbye.'\n>>>", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Netrc", 
  "doc": "Class to parse & provide access to 'netrc' format files.\n\nSee the netrc(4) man page for information on the file format.\n\nWARNING: This class is obsolete -- use module netrc instead.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error_perm", 
  "doc": null, 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error_proto", 
  "doc": null, 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error_reply", 
  "doc": null, 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error_temp", 
  "doc": null, 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ftpcp", 
  "doc": "Copy file from one FTP-instance to another.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "parse150", 
  "doc": "Parse the '150' response for a RETR request.\nReturns the expected transfer size or None; size is not guaranteed to\nbe present in the 150 message.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse227", 
  "doc": "Parse the '227' response for a PASV request.\nRaises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'\nReturn ('host.addr.as.numbers', port#) tuple.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse229", 
  "doc": "Parse the '229' response for a EPSV request.\nRaises error_proto if it does not contain '(|||port|)'\nReturn ('host.addr.as.numbers', port#) tuple.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse257", 
  "doc": "Parse the '257' response for a MKD or PWD request.\nThis is a response to a MKD or PWD request: a directory name.\nReturns the directoryname in the 257 reply.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_line", 
  "doc": "Default retrlines callback to print a line.", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides some more Pythonic support for SSL.\n\nObject types:\n\n  SSLSocket -- subtype of socket.socket which does SSL over the socket\n\nExceptions:\n\n  SSLError -- exception raised for I/O errors\n\nFunctions:\n\n  cert_time_to_seconds -- convert time string used for certificate\n                          notBefore and notAfter functions to integer\n                          seconds past the Epoch (the time values\n                          returned from time.time())\n\n  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided\n                          by the server running on HOST at port PORT.  No\n                          validation of the certificate is performed.\n\nInteger constants:\n\nSSL_ERROR_ZERO_RETURN\nSSL_ERROR_WANT_READ\nSSL_ERROR_WANT_WRITE\nSSL_ERROR_WANT_X509_LOOKUP\nSSL_ERROR_SYSCALL\nSSL_ERROR_SSL\nSSL_ERROR_WANT_CONNECT\n\nSSL_ERROR_EOF\nSSL_ERROR_INVALID_ERROR_CODE\n\nThe following group define certificate requirements that one side is\nallowing/requiring from the other side:\n\nCERT_NONE - no certificates from the other side are required (or will\n            be looked at if provided)\nCERT_OPTIONAL - certificates are not required, but if provided will be\n                validated, and if validation fails, the connection will\n                also fail\nCERT_REQUIRED - certificates are required, and will be validated, and\n                if validation fails, the connection will also fail\n\nThe following constants identify various SSL protocol variants:\n\nPROTOCOL_SSLv2\nPROTOCOL_SSLv3\nPROTOCOL_SSLv23\nPROTOCOL_TLSv1", 
  "line": 0, 
  "type": "module", 
  "name": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": "Test program.\nUsage: ftp [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...\n\n-d dir\n-l list\n-p password", 
  "module": "ftplib", 
  "file": "/usr/lib/python3.2/ftplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Lock", 
  "doc": "allocate_lock() -> lock object\n(allocate() is an obsolete synonym)\n\nCreate a new lock object.  See help(LockType) for information about locks.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "OrderedDict", 
  "doc": "Dictionary that remembers insertion order", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_CacheInfo", 
  "doc": "CacheInfo(hits, misses, maxsize, currsize)", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "cmp_to_key", 
  "doc": "Convert a cmp= function into a key= function", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lru_cache", 
  "doc": "Least-recently-used cache decorator.\n\nIf *maxsize* is set to None, the LRU features are disabled and the cache\ncan grow without bound.\n\nArguments to the cached function must be hashable.\n\nView the cache statistics named tuple (hits, misses, maxsize, currsize) with\nf.cache_info().  Clear the cache and statistics with f.cache_clear().\nAccess the underlying function with f.__wrapped__.\n\nSee:  http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partial", 
  "doc": "partial(func, *args, **keywords) - new function with partial application\nof the given arguments and keywords.", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "reduce", 
  "doc": "reduce(function, sequence[, initial]) -> value\n\nApply a function of two arguments cumulatively to the items of a sequence,\nfrom left to right, so as to reduce the sequence to a single value.\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\nof the sequence in the calculation, and serves as a default when the\nsequence is empty.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "total_ordering", 
  "doc": "Class decorator that fills in missing ordering methods", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "update_wrapper", 
  "doc": "Update a wrapper function to look like the wrapped function\n\nwrapper is the function to be updated\nwrapped is the original function\nassigned is a tuple naming the attributes assigned directly\nfrom the wrapped function to the wrapper function (defaults to\nfunctools.WRAPPER_ASSIGNMENTS)\nupdated is a tuple naming the attributes of the wrapper that\nare updated with the corresponding attribute from the wrapped\nfunction (defaults to functools.WRAPPER_UPDATES)", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "wraps", 
  "doc": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().", 
  "module": "functools", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_splitext", 
  "doc": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "commonprefix", 
  "doc": "Given a list of pathnames, returns the longest common leading component", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exists", 
  "doc": "Test whether a path exists.  Returns False for broken symbolic links", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getatime", 
  "doc": "Return the last access time of a file, reported by os.stat().", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getctime", 
  "doc": "Return the metadata change time of a file, reported by os.stat().", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmtime", 
  "doc": "Return the last modification time of a file, reported by os.stat().", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsize", 
  "doc": "Return the size of a file, reported by os.stat().", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdir", 
  "doc": "Return true if the pathname refers to an existing directory.", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfile", 
  "doc": "Test whether a path is a regular file", 
  "module": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "name": "GetoptError", 
  "doc": null, 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "do_longs", 
  "doc": null, 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "do_shorts", 
  "doc": null, 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "getopt", 
  "doc": "getopt(args, options[, long_options]) -> opts, args\n\nParses command line options and parameter list.  args is the\nargument list to be parsed, without the leading reference to the\nrunning program.  Typically, this means \"sys.argv[1:]\".  shortopts\nis the string of option letters that the script wants to\nrecognize, with options that require an argument followed by a\ncolon (i.e., the same format that Unix getopt() uses).  If\nspecified, longopts is a list of strings with the names of the\nlong options which should be supported.  The leading '--'\ncharacters should not be included in the option name.  Options\nwhich require an argument should be followed by an equal sign\n('=').\n\nThe return value consists of two elements: the first is a list of\n(option, value) pairs; the second is the list of program arguments\nleft after the option list was stripped (this is a trailing slice\nof the first argument).  Each option-and-value pair returned has\nthe option as its first element, prefixed with a hyphen (e.g.,\n'-x'), and the option argument as its second element, or an empty\nstring if the option has no argument.  The options occur in the\nlist in the same order in which they were found, thus allowing\nmultiple occurrences.  Long and short options may be mixed.", 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gnu_getopt", 
  "doc": "getopt(args, options[, long_options]) -> opts, args\n\nThis function works like getopt(), except that GNU style scanning\nmode is used by default. This means that option and non-option\narguments may be intermixed. The getopt() function stops\nprocessing options as soon as a non-option argument is\nencountered.\n\nIf the first character of the option string is `+', or if the\nenvironment variable POSIXLY_CORRECT is set, then option\nprocessing stops as soon as a non-option argument is encountered.", 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "long_has_args", 
  "doc": null, 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "short_has_arg", 
  "doc": null, 
  "module": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "GetPassWarning", 
  "doc": null, 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_raw_input", 
  "doc": null, 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fallback_getpass", 
  "doc": null, 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpass", 
  "doc": "Prompt for a password, with echo turned off.\n\nArgs:\n  prompt: Written on stream to ask for the input.  Default: 'Password: '\n  stream: A writable file object to display the prompt.  Defaults to\n          the tty.  If no tty is available defaults to sys.stderr.\nReturns:\n  The seKr3t input.\nRaises:\n  EOFError: If our input tty or stdin was closed.\n  GetPassWarning: When we were unable to turn echo off on the input.\n\nAlways restores terminal settings before returning.", 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getuser", 
  "doc": "Get the username from the environment or password database.\n\nFirst try various environment variables, then the password\ndatabase.  This works on Windows as long as USERNAME is set.", 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides an interface to the Posix calls for tty I/O control.\nFor a complete description of these calls, see the Posix or Unix manual\npages. It is only available for those Unix versions that support Posix\ntermios style tty I/O control.\n\nAll functions in this module take a file descriptor fd as their first\nargument. This can be an integer file descriptor, such as returned by\nsys.stdin.fileno(), or a file object, such as sys.stdin itself.", 
  "line": 0, 
  "type": "module", 
  "name": "termios", 
  "file": "/usr/lib/python3.2/lib-dynload/termios.cpython-32mu.so"
 }, 
 {
  "name": "unix_getpass", 
  "doc": "Prompt for a password, with echo turned off.\n\nArgs:\n  prompt: Written on stream to ask for the input.  Default: 'Password: '\n  stream: A writable file object to display the prompt.  Defaults to\n          the tty.  If no tty is available defaults to sys.stderr.\nReturns:\n  The seKr3t input.\nRaises:\n  EOFError: If our input tty or stdin was closed.\n  GetPassWarning: When we were unable to turn echo off on the input.\n\nAlways restores terminal settings before returning.", 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "win_getpass", 
  "doc": "Prompt for password with echo off, using Windows getch().", 
  "module": "getpass", 
  "file": "/usr/lib/python3.2/getpass.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Catalog", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "GNUTranslations", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NullTranslations", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_expand_lang", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bind_textdomain_codeset", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bindtextdomain", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "c2py", 
  "doc": "Gets a C expression as used in PO files for plural forms and returns a\nPython lambda function that implements an equivalent expression.", 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Generic (shallow and deep) copying operations.\n\nInterface summary:\n\n        import copy\n\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\n\nFor module specific errors, copy.Error is raised.\n\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\n\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\n\nPython's deep copy operation avoids these problems by:\n\n a) keeping a table of objects already copied during the current\n    copying pass\n\n b) letting user-defined classes override the copying operation or the\n    set of components copied\n\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\n\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods.", 
  "line": 0, 
  "type": "module", 
  "name": "copy", 
  "file": "/usr/lib/python3.2/copy.py"
 }, 
 {
  "name": "dgettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dngettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "install", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "ldgettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ldngettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lgettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lngettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Locale support.\n\nThe module provides low-level access to the C lib's locale APIs\nand adds high level number formatting APIs as well as a locale\naliasing engine to complement these.\n\nThe aliasing engine includes support for many commonly used locale\nnames and maps them to values suitable for passing to the C lib's\nsetlocale() function. It also includes default encodings for all\nsupported locale names.", 
  "line": 0, 
  "type": "module", 
  "name": "locale", 
  "file": "/usr/lib/python3.2/locale.py"
 }, 
 {
  "name": "ngettext", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "textdomain", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translation", 
  "doc": null, 
  "module": "gettext", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Filename matching with shell patterns.\n\nfnmatch(FILENAME, PATTERN) matches according to the local convention.\nfnmatchcase(FILENAME, PATTERN) always takes case in account.\n\nThe functions operate by translating the pattern into a regular\nexpression.  They cache the compiled regular expressions for speed.\n\nThe function translate(PATTERN) returns a regular expression\ncorresponding to PATTERN.  (It does not compile it.)", 
  "line": 0, 
  "type": "module", 
  "name": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py"
 }, 
 {
  "name": "glob", 
  "doc": "Return a list of paths matching a pathname pattern.\n\nThe pattern may contain simple shell-style wildcards a la fnmatch.", 
  "module": "glob", 
  "file": "/usr/lib/python3.2/glob.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "glob0", 
  "doc": null, 
  "module": "glob", 
  "file": "/usr/lib/python3.2/glob.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "glob1", 
  "doc": null, 
  "module": "glob", 
  "file": "/usr/lib/python3.2/glob.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_magic", 
  "doc": null, 
  "module": "glob", 
  "file": "/usr/lib/python3.2/glob.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iglob", 
  "doc": "Return an iterator which yields the paths matching a pathname pattern.\n\nThe pattern may contain simple shell-style wildcards a la fnmatch.", 
  "module": "glob", 
  "file": "/usr/lib/python3.2/glob.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "GzipFile", 
  "doc": "The GzipFile class simulates most of the methods of a file object with\nthe exception of the readinto() and truncate() methods.\n\nThis class only supports opening files in binary mode. If you need to open a\ncompressed file in text mode, wrap your GzipFile with an io.TextIOWrapper.", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LOWU32", 
  "doc": "Return the low-order 32 bits, as a non-negative int", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "U32", 
  "doc": "Return i as an unsigned integer, assuming it fits in 32 bits.\nIf it's >= 2GB when viewed as a 32-bit unsigned int, return a long.", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_PaddedFile", 
  "doc": "Minimal read-only file object that prepends a string to the contents\nof an actual file. Shouldn't be used outside of gzip.py, as it lacks\nessential functionality.", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "compress", 
  "doc": "Compress data in one shot and return the compressed string.\nOptional argument is the compression level, in range of 1-9.", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decompress", 
  "doc": "Decompress a gzip compressed string in one shot.\nReturn the decompressed string.", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "open", 
  "doc": "Shorthand for GzipFile(filename, mode, compresslevel).\n\nThe filename argument is required; mode defaults to 'rb'\nand compresslevel defaults to 9.", 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "read32", 
  "doc": null, 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "write32u", 
  "doc": null, 
  "module": "gzip", 
  "file": "/usr/lib/python3.2/gzip.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The functions in this module allow compression and decompression using the\nzlib library, which is based on GNU zip.\n\nadler32(string[, start]) -- Compute an Adler-32 checksum.\ncompress(string[, level]) -- Compress string, with compression level in 1-9.\ncompressobj([level]) -- Return a compressor object.\ncrc32(string[, start]) -- Compute a CRC-32 checksum.\ndecompress(string,[wbits],[bufsize]) -- Decompresses a compressed string.\ndecompressobj([wbits]) -- Return a decompressor object.\n\n'wbits' is window buffer size.\nCompressor objects support compress() and flush() methods; decompressor\nobjects support decompress() and flush().", 
  "line": 0, 
  "type": "module", 
  "name": "zlib", 
  "file": null
 }, 
 {
  "name": "__get_builtin_constructor", 
  "doc": null, 
  "module": "hashlib", 
  "file": "/usr/lib/python3.2/hashlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_hashlib", 
  "file": null
 }, 
 {
  "name": "md5", 
  "doc": "Returns a md5 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "new", 
  "doc": "new(name, data=b'') - Return a new hashing object using the named algorithm;\noptionally initialized with data (which must be bytes).", 
  "module": "hashlib", 
  "file": "/usr/lib/python3.2/hashlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sha1", 
  "doc": "Returns a sha1 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sha224", 
  "doc": "Returns a sha224 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sha256", 
  "doc": "Returns a sha256 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sha384", 
  "doc": "Returns a sha384 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sha512", 
  "doc": "Returns a sha512 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_nlargest", 
  "doc": "Find the n largest elements in a dataset.\n\nEquivalent to:  sorted(iterable, reverse=True)[:n]", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_nsmallest", 
  "doc": "Find the n smallest elements in a dataset.\n\nEquivalent to:  sorted(iterable)[:n]", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_siftdown", 
  "doc": null, 
  "module": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_siftup", 
  "doc": null, 
  "module": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Bisection algorithms.", 
  "line": 0, 
  "type": "module", 
  "name": "bisect", 
  "file": "/usr/lib/python3.2/bisect.py"
 }, 
 {
  "name": "chain", 
  "doc": "chain(*iterables) --> chain object\n\nReturn a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "count(start=0, step=1) --> count object\n\nReturn a count object whose .__next__() method returns consecutive values.\nEquivalent to:\n\n    def count(firstval=0, step=1):\n    x = firstval\n    while 1:\n        yield x\n        x += step", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "heapify", 
  "doc": "Transform list into a heap, in-place, in O(len(heap)) time.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "heappop", 
  "doc": "Pop the smallest item off the heap, maintaining the heap invariant.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "heappush", 
  "doc": "Push item onto heap, maintaining the heap invariant.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "heappushpop", 
  "doc": "Push item on the heap, then pop and return the smallest item\nfrom the heap. The combined action runs more efficiently than\nheappush() followed by a separate call to heappop().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "heapreplace", 
  "doc": "Pop and return the current smallest value, and add the new item.\n\nThis is more efficient than heappop() followed by heappush(), and can be\nmore appropriate when using a fixed-size heap.  Note that the value\nreturned may be larger than item!  That constrains reasonable uses of\nthis routine unless written as part of a conditional replacement:\n\n    if item > heap[0]:\n        item = heapreplace(heap, item)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islice", 
  "doc": "islice(iterable, [start,] stop [, step]) --> islice object\n\nReturn an iterator whose next() method returns selected values from an\niterable.  If start is specified, will skip all preceding elements;\notherwise, start defaults to zero.  Step defaults to one.  If\nspecified as another value, step determines how many values are \nskipped between successive calls.  Works like a slice() on a list\nbut returns an iterator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "merge", 
  "doc": "Merge multiple sorted inputs into a single sorted output.\n\nSimilar to sorted(itertools.chain(*iterables)) but returns a generator,\ndoes not pull the data into memory all at once, and assumes that each of\nthe input streams is already sorted (smallest to largest).\n\n>>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))\n[0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]", 
  "module": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nlargest", 
  "doc": "Find the n largest elements in a dataset.\n\nEquivalent to:  sorted(iterable, key=key, reverse=True)[:n]", 
  "module": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nsmallest", 
  "doc": "Find the n smallest elements in a dataset.\n\nEquivalent to:  sorted(iterable, key=key)[:n]", 
  "module": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "repeat", 
  "doc": "repeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "tee", 
  "doc": "tee(iterable, n=2) --> tuple of n independent iterators.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "HMAC", 
  "doc": "RFC 2104 HMAC class.  Also complies with RFC 4231.\n\nThis supports the API for Cryptographic Hash Functions (PEP 247).", 
  "module": "hmac", 
  "file": "/usr/lib/python3.2/hmac.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "_warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "new", 
  "doc": "Create a new hashing object and return it.\n\nkey: The starting key for the hash.\nmsg: if available, will immediately be hashed into the object's starting\nstate.\n\nYou can now feed arbitrary strings into the object using its update()\nmethod, and can ask for the hash value at any time by calling its digest()\nmethod.", 
  "module": "hmac", 
  "file": "/usr/lib/python3.2/hmac.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IMAP4", 
  "doc": "IMAP4 client class.\n\nInstantiate with: IMAP4([host[, port]])\n\n        host - host's name (default: localhost);\n        port - port number (default: standard IMAP4 port).\n\nAll IMAP4rev1 commands are supported by methods of the same\nname (in lower-case).\n\nAll arguments to commands are converted to strings, except for\nAUTHENTICATE, and the last argument to APPEND which is passed as\nan IMAP4 literal.  If necessary (the string contains any\nnon-printing characters or white-space and isn't enclosed with\neither parentheses or double quotes) each string is quoted.\nHowever, the 'password' argument to the LOGIN command is always\nquoted.  If you want to avoid having an argument string quoted\n(eg: the 'flags' argument to STORE) then enclose the string in\nparentheses (eg: \"(\\Deleted)\").\n\nEach command returns a tuple: (type, [data, ...]) where 'type'\nis usually 'OK' or 'NO', and 'data' is either the text from the\ntagged response, or untagged results from command. Each 'data'\nis either a string, or a tuple. If a tuple, then the first part\nis the header of the response, and the second part contains\nthe data (ie: 'literal' value).\n\nErrors raise the exception class <instance>.error(\"<reason>\").\nIMAP4 server errors raise <instance>.abort(\"<reason>\"),\nwhich is a sub-class of 'error'. Mailbox status changes\nfrom READ-WRITE to READ-ONLY raise the exception class\n<instance>.readonly(\"<reason>\"), which is a sub-class of 'abort'.\n\n\"error\" exceptions imply a program error.\n\"abort\" exceptions imply the connection should be reset, and\n        the command re-tried.\n\"readonly\" exceptions imply the command should be re-tried.\n\nNote: to use this module, you must read the RFCs pertaining to the\nIMAP4 protocol, as the semantics of the arguments to each IMAP4\ncommand are left to the invoker, not to mention the results. Also,\nmost IMAP servers implement a sub-set of the commands available here.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IMAP4_SSL", 
  "doc": "IMAP4 client class over SSL connection\n\nInstantiate with: IMAP4_SSL([host[, port[, keyfile[, certfile]]]])\n\n        host - host's name (default: localhost);\n        port - port number (default: standard IMAP4 SSL port).\n        keyfile - PEM formatted file that contains your private key (default: None);\n        certfile - PEM formatted certificate chain file (default: None);\n\nfor more documentation see the docstring of the parent class IMAP4.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IMAP4_stream", 
  "doc": "IMAP4 client class over a stream\n\nInstantiate with: IMAP4_stream(command)\n\n        where \"command\" is a string that can be passed to subprocess.Popen()\n\nfor more documentation see the docstring of the parent class IMAP4.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int2AP", 
  "doc": "Convert integer to A-P string representation.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Internaldate2tuple", 
  "doc": "Parse an IMAP4 INTERNALDATE string.\n\nReturn corresponding local time.  The return value is a\ntime.struct_time tuple or None if the string has wrong format.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ParseFlags", 
  "doc": "Convert IMAP4 flags response to python tuple.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Time2Internaldate", 
  "doc": "Convert date_time to IMAP4 INTERNALDATE representation.\n\nReturn string in form: '\"DD-Mmm-YYYY HH:MM:SS +HHMM\"'.  The\ndate_time argument can be a number (int or float) representing\nseconds since epoch (as returned by time.time()), a 9-tuple\nrepresenting local time (as returned by time.localtime()), or a\ndouble-quoted string.  In the last case, it is assumed to already\nbe in the correct format.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_Authenticator", 
  "doc": "Private class to provide en/decoding\nfor base64-based authentication conversation.", 
  "module": "imaplib", 
  "file": "/usr/lib/python3.2/imaplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Conversion between binary data and ASCII", 
  "line": 0, 
  "type": "module", 
  "name": "binascii", 
  "file": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "Random variable generators.\n\n    integers\n    --------\n           uniform within range\n\n    sequences\n    ---------\n           pick random element\n           pick random sample\n           generate random permutation\n\n    distributions on the real line:\n    ------------------------------\n           uniform\n           triangular\n           normal (Gaussian)\n           lognormal\n           negative exponential\n           gamma\n           beta\n           pareto\n           Weibull\n\n    distributions on the circle (angles 0 to 2pi)\n    ---------------------------------------------\n           circular uniform\n           von Mises\n\nGeneral notes on the underlying Mersenne Twister core generator:\n\n* The period is 2**19937-1.\n* It is one of the most extensively tested generators in existence.\n* The random() method is implemented in C, executes in a single Python step,\n  and is, therefore, threadsafe.", 
  "line": 0, 
  "type": "module", 
  "name": "random", 
  "file": "/usr/lib/python3.2/random.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides some more Pythonic support for SSL.\n\nObject types:\n\n  SSLSocket -- subtype of socket.socket which does SSL over the socket\n\nExceptions:\n\n  SSLError -- exception raised for I/O errors\n\nFunctions:\n\n  cert_time_to_seconds -- convert time string used for certificate\n                          notBefore and notAfter functions to integer\n                          seconds past the Epoch (the time values\n                          returned from time.time())\n\n  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided\n                          by the server running on HOST at port PORT.  No\n                          validation of the certificate is performed.\n\nInteger constants:\n\nSSL_ERROR_ZERO_RETURN\nSSL_ERROR_WANT_READ\nSSL_ERROR_WANT_WRITE\nSSL_ERROR_WANT_X509_LOOKUP\nSSL_ERROR_SYSCALL\nSSL_ERROR_SSL\nSSL_ERROR_WANT_CONNECT\n\nSSL_ERROR_EOF\nSSL_ERROR_INVALID_ERROR_CODE\n\nThe following group define certificate requirements that one side is\nallowing/requiring from the other side:\n\nCERT_NONE - no certificates from the other side are required (or will\n            be looked at if provided)\nCERT_OPTIONAL - certificates are not required, but if provided will be\n                validated, and if validation fails, the connection will\n                also fail\nCERT_REQUIRED - certificates are required, and will be validated, and\n                if validation fails, the connection will also fail\n\nThe following constants identify various SSL protocol variants:\n\nPROTOCOL_SSLv2\nPROTOCOL_SSLv3\nPROTOCOL_SSLv23\nPROTOCOL_TLSv1", 
  "line": 0, 
  "type": "module", 
  "name": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py"
 }, 
 {
  "doc": "subprocess - Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.  This module\nintends to replace several other, older modules and functions, like:\n\nos.system\nos.spawn*\n\nInformation about how the subprocess module can be used to replace these\nmodules and functions can be found below.\n\n\n\nUsing the subprocess module\n===========================\nThis module defines one class called Popen:\n\nclass Popen(args, bufsize=0, executable=None,\n            stdin=None, stdout=None, stderr=None,\n            preexec_fn=None, close_fds=True, shell=False,\n            cwd=None, env=None, universal_newlines=False,\n            startupinfo=None, creationflags=0,\n            restore_signals=True, start_new_session=False, pass_fds=()):\n\n\nArguments are:\n\nargs should be a string, or a sequence of program arguments.  The\nprogram to execute is normally the first item in the args sequence or\nstring, but can be explicitly set by using the executable argument.\n\nOn POSIX, with shell=False (default): In this case, the Popen class\nuses os.execvp() to execute the child program.  args should normally\nbe a sequence.  A string will be treated as a sequence with the string\nas the only item (the program to execute).\n\nOn POSIX, with shell=True: If args is a string, it specifies the\ncommand string to execute through the shell.  If args is a sequence,\nthe first item specifies the command string, and any additional items\nwill be treated as additional shell arguments.\n\nOn Windows: the Popen class uses CreateProcess() to execute the child\nprogram, which operates on strings.  If args is a sequence, it will be\nconverted to a string using the list2cmdline method.  Please note that\nnot all MS Windows applications interpret the command line the same\nway: The list2cmdline is designed for applications using the same\nrules as the MS C runtime.\n\nbufsize, if given, has the same meaning as the corresponding argument\nto the built-in open() function: 0 means unbuffered, 1 means line\nbuffered, any other positive value means use a buffer of\n(approximately) that size.  A negative bufsize means to use the system\ndefault, which usually means fully buffered.  The default value for\nbufsize is 0 (unbuffered).\n\nstdin, stdout and stderr specify the executed programs' standard\ninput, standard output and standard error file handles, respectively.\nValid values are PIPE, an existing file descriptor (a positive\ninteger), an existing file object, and None.  PIPE indicates that a\nnew pipe to the child should be created.  With None, no redirection\nwill occur; the child's file handles will be inherited from the\nparent.  Additionally, stderr can be STDOUT, which indicates that the\nstderr data from the applications should be captured into the same\nfile handle as for stdout.\n\nOn POSIX, if preexec_fn is set to a callable object, this object will be\ncalled in the child process just before the child is executed.  The use\nof preexec_fn is not thread safe, using it in the presence of threads\ncould lead to a deadlock in the child process before the new executable\nis executed.\n\nIf close_fds is true, all file descriptors except 0, 1 and 2 will be\nclosed before the child process is executed.  The default for close_fds\nvaries by platform:  Always true on POSIX.  True when stdin/stdout/stderr\nare None on Windows, false otherwise.\n\npass_fds is an optional sequence of file descriptors to keep open between the\nparent and child.  Providing any pass_fds implicitly sets close_fds to true.\n\nif shell is true, the specified command will be executed through the\nshell.\n\nIf cwd is not None, the current directory will be changed to cwd\nbefore the child is executed.\n\nOn POSIX, if restore_signals is True all signals that Python sets to\nSIG_IGN are restored to SIG_DFL in the child process before the exec.\nCurrently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals.  This\nparameter does nothing on Windows.\n\nOn POSIX, if start_new_session is True, the setsid() system call will be made\nin the child process prior to executing the command.\n\nIf env is not None, it defines the environment variables for the new\nprocess.\n\nIf universal_newlines is true, the file objects stdout and stderr are\nopened as a text files, but lines may be terminated by any of '\\n',\nthe Unix end-of-line convention, '\\r', the old Macintosh convention or\n'\\r\\n', the Windows convention.  All of these external representations\nare seen as '\\n' by the Python program.  Note: This feature is only\navailable if Python is built with universal newline support (the\ndefault).  Also, the newlines attribute of the file objects stdout,\nstdin and stderr are not updated by the communicate() method.\n\nThe startupinfo and creationflags, if given, will be passed to the\nunderlying CreateProcess() function.  They can specify things such as\nappearance of the main window and priority for the new process.\n(Windows only)\n\n\nThis module also defines some shortcut functions:\n\ncall(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> retcode = subprocess.call([\"ls\", \"-l\"])\n\ncheck_call(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete.  If the\n    exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> subprocess.check_call([\"ls\", \"-l\"])\n    0\n\ngetstatusoutput(cmd):\n    Return (status, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple\n    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the\n    returned output will contain output or error messages. A trailing newline\n    is stripped from the output. The exit status for the command can be\n    interpreted according to the rules for the C function wait().  Example:\n\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (256, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (256, 'sh: /bin/junk: not found')\n\ngetoutput(cmd):\n    Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n\ncheck_output(*popenargs, **kwargs):\n    Run command with arguments and return its output as a byte string.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> output = subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n\n\nExceptions\n----------\nExceptions raised in the child process, before the new program has\nstarted to execute, will be re-raised in the parent.  Additionally,\nthe exception object will have one extra attribute called\n'child_traceback', which is a string containing traceback information\nfrom the childs point of view.\n\nThe most common exception raised is OSError.  This occurs, for\nexample, when trying to execute a non-existent file.  Applications\nshould prepare for OSErrors.\n\nA ValueError will be raised if Popen is called with invalid arguments.\n\ncheck_call() and check_output() will raise CalledProcessError, if the\ncalled process returns a non-zero return code.\n\n\nSecurity\n--------\nUnlike some other popen functions, this implementation will never call\n/bin/sh implicitly.  This means that all characters, including shell\nmetacharacters, can safely be passed to child processes.\n\n\nPopen objects\n=============\nInstances of the Popen class have the following methods:\n\npoll()\n    Check if child process has terminated.  Returns returncode\n    attribute.\n\nwait()\n    Wait for child process to terminate.  Returns returncode attribute.\n\ncommunicate(input=None)\n    Interact with process: Send data to stdin.  Read data from stdout\n    and stderr, until end-of-file is reached.  Wait for process to\n    terminate.  The optional input argument should be a string to be\n    sent to the child process, or None, if no data should be sent to\n    the child.\n\n    communicate() returns a tuple (stdout, stderr).\n\n    Note: The data read is buffered in memory, so do not use this\n    method if the data size is large or unlimited.\n\nThe following attributes are also available:\n\nstdin\n    If the stdin argument is PIPE, this attribute is a file object\n    that provides input to the child process.  Otherwise, it is None.\n\nstdout\n    If the stdout argument is PIPE, this attribute is a file object\n    that provides output from the child process.  Otherwise, it is\n    None.\n\nstderr\n    If the stderr argument is PIPE, this attribute is file object that\n    provides error output from the child process.  Otherwise, it is\n    None.\n\npid\n    The process ID of the child process.\n\nreturncode\n    The child return code.  A None value indicates that the process\n    hasn't terminated yet.  A negative value -N indicates that the\n    child was terminated by signal N (POSIX only).\n\n\nReplacing older functions with the subprocess module\n====================================================\nIn this section, \"a ==> b\" means that b can be used as a replacement\nfor a.\n\nNote: All functions in this section fail (more or less) silently if\nthe executed program cannot be found; this module raises an OSError\nexception.\n\nIn the following examples, we assume that the subprocess module is\nimported with \"from subprocess import *\".\n\n\nReplacing /bin/sh shell backquote\n---------------------------------\noutput=`mycmd myarg`\n==>\noutput = Popen([\"mycmd\", \"myarg\"], stdout=PIPE).communicate()[0]\n\n\nReplacing shell pipe line\n-------------------------\noutput=`dmesg | grep hda`\n==>\np1 = Popen([\"dmesg\"], stdout=PIPE)\np2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\n\n\nReplacing os.system()\n---------------------\nsts = os.system(\"mycmd\" + \" myarg\")\n==>\np = Popen(\"mycmd\" + \" myarg\", shell=True)\npid, sts = os.waitpid(p.pid, 0)\n\nNote:\n\n* Calling the program through the shell is usually not required.\n\n* It's easier to look at the returncode attribute than the\n  exitstatus.\n\nA more real-world example would look like this:\n\ntry:\n    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n    if retcode < 0:\n        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n    else:\n        print(\"Child returned\", retcode, file=sys.stderr)\nexcept OSError as e:\n    print(\"Execution failed:\", e, file=sys.stderr)\n\n\nReplacing os.spawn*\n-------------------\nP_NOWAIT example:\n\npid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\npid = Popen([\"/bin/mycmd\", \"myarg\"]).pid\n\n\nP_WAIT example:\n\nretcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\nretcode = call([\"/bin/mycmd\", \"myarg\"])\n\n\nVector example:\n\nos.spawnvp(os.P_NOWAIT, path, args)\n==>\nPopen([path] + args[1:])\n\n\nEnvironment example:\n\nos.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n==>\nPopen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})", 
  "line": 0, 
  "type": "module", 
  "name": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_bmp", 
  "doc": null, 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_gif", 
  "doc": "GIF ('87 and '89 variants)", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_jpeg", 
  "doc": "JPEG data in JFIF or Exif format", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_pbm", 
  "doc": "PBM (portable bitmap)", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_pgm", 
  "doc": "PGM (portable graymap)", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_png", 
  "doc": null, 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_ppm", 
  "doc": "PPM (portable pixmap)", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_rast", 
  "doc": "Sun raster file", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_rgb", 
  "doc": "SGI image library", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_tiff", 
  "doc": "TIFF (can be in Motorola or Intel byte order)", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_xbm", 
  "doc": "X bitmap (X10 or X11)", 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "testall", 
  "doc": null, 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "what", 
  "doc": null, 
  "module": "imghdr", 
  "file": "/usr/lib/python3.2/imghdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__import__", 
  "doc": "Import a module.\n\nThe 'globals' argument is used to infer where the import is occuring from\nto handle relative imports. The 'locals' argument is ignored. The\n'fromlist' argument specifies what should exist as attributes on the module\nbeing imported (e.g. ``from module import <fromlist>``).  The 'level'\nargument represents the package location to import from in a relative\nimport (e.g. ``from ..pkg import mod`` would have a 'level' of 2).", 
  "module": "importlib", 
  "file": "/usr/lib/python3.2/importlib/_bootstrap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Core implementation of import.\n\nThis module is NOT meant to be directly imported! It has been designed such\nthat it can be bootstrapped into Python as the implementation of import. As\nsuch it requires the injection of specific modules and attributes in order to\nwork. One should use importlib as the public-facing version of this module.", 
  "line": 0, 
  "type": "module", 
  "name": "_bootstrap", 
  "file": "/usr/lib/python3.2/importlib/_bootstrap.py"
 }, 
 {
  "name": "_case_ok", 
  "doc": "Check if the directory contains something matching 'check'.\n\nNo check is done if the file/directory exists or not.", 
  "module": "importlib", 
  "file": "/usr/lib/python3.2/importlib/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseperation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "_io", 
  "file": null
 }, 
 {
  "doc": "This module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.", 
  "line": 0, 
  "type": "module", 
  "name": "_os", 
  "file": null
 }, 
 {
  "name": "_r_long", 
  "doc": "Convert 4 bytes in little-endian to an integer.\n\nXXX Temporary until marshal's long function are exposed.", 
  "module": "importlib", 
  "file": "/usr/lib/python3.2/importlib/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_w_long", 
  "doc": "Convert a 32-bit integer to little-endian.\n\nXXX Temporary until marshal's long functions are exposed.", 
  "module": "importlib", 
  "file": "/usr/lib/python3.2/importlib/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "_warnings provides basic warning filtering support.\nIt is a helper module to speed up interpreter start-up.", 
  "line": 0, 
  "type": "module", 
  "name": "_warnings", 
  "file": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "import_module", 
  "doc": "Import a module.\n\nThe 'package' argument is required when performing a relative import. It\nspecifies the package to use as the anchor point from which to resolve the\nrelative import to an absolute import.", 
  "module": "importlib", 
  "file": "/usr/lib/python3.2/importlib/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating point numbers.\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- write value to a string\nloads() -- read value from a string", 
  "line": 0, 
  "type": "module", 
  "name": "marshal", 
  "file": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "ArgInfo", 
  "doc": "ArgInfo(args, varargs, keywords, locals)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ArgSpec", 
  "doc": "ArgSpec(args, varargs, keywords, defaults)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Arguments", 
  "doc": "Arguments(args, varargs, varkw)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Attribute", 
  "doc": "Attribute(name, kind, defining_class, object)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BlockFinder", 
  "doc": "Provide a tokeneater() method to detect the end of a code block.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "EndOfBlock", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FullArgSpec", 
  "doc": "FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ModuleInfo", 
  "doc": "ModuleInfo(name, suffix, mode, module_type)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Traceback", 
  "doc": "Traceback(filename, lineno, function, code_context, index)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_check_class", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_check_instance", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getfullargs", 
  "doc": "Get information about the arguments accepted by a code object.\n\nFour things are returned: (args, varargs, kwonlyargs, varkw), where\n'args' and 'kwonlyargs' are lists of argument names, and 'varargs'\nand 'varkw' are the names of the * and ** arguments or None.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_is_type", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_shadowed_dict", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_static_getmro", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "attrgetter", 
  "doc": "attrgetter(attr, ...) --> attrgetter object\n\nReturn a callable object that fetches the given attribute(s) from its operand.\nAfter, f=attrgetter('name'), the call f(r) returns r.name.\nAfter, g=attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\nAfter, h=attrgetter('name.first', 'name.last'), the call h(r) returns\n(r.name.first, r.name.last).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "classify_class_attrs", 
  "doc": "Return list of attribute-descriptor tuples.\n\nFor each name in dir(cls), the return list contains a 4-tuple\nwith these elements:\n\n    0. The name (a string).\n\n    1. The kind of attribute this is, one of these strings:\n           'class method'    created via classmethod()\n           'static method'   created via staticmethod()\n           'property'        created via property()\n           'method'          any other flavor of method\n           'data'            not a method\n\n    2. The class which defined this attribute (a class).\n\n    3. The object as obtained directly from the defining class's\n       __dict__, not via getattr.  This is especially important for\n       data attributes:  C.data is just a data object, but\n       C.__dict__['data'] may be a data descriptor with additional\n       info, like a __doc__ string.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cleandoc", 
  "doc": "Clean up indentation from docstrings.\n\nAny whitespace that can be uniformly removed from the second line\nonwards is removed.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "currentframe", 
  "doc": "Return the frame of the caller or None if this is not possible.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findsource", 
  "doc": "Return the entire source file and starting line number for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a list of all the lines\nin the file and the line number indexes a line in that list.  An IOError\nis raised if the source code cannot be retrieved.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "formatannotation", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "formatannotationrelativeto", 
  "doc": null, 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "formatargspec", 
  "doc": "Format an argument spec from the values returned by getargspec\nor getfullargspec.\n\nThe first seven arguments are (args, varargs, varkw, defaults,\nkwonlyargs, kwonlydefaults, annotations).  The other five arguments\nare the corresponding optional formatting functions that are called to\nturn names and values into strings.  The last argument is an optional\nfunction to format the sequence of arguments.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "formatargvalues", 
  "doc": "Format an argument spec from the 4 values returned by getargvalues.\n\nThe first four arguments are (args, varargs, varkw, locals).  The\nnext four arguments are the corresponding optional formatting functions\nthat are called to turn names and values into strings.  The ninth\nargument is an optional function to format the sequence of arguments.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getabsfile", 
  "doc": "Return an absolute path to the source or compiled file for an object.\n\nThe idea is for each object to have a unique origin, so this routine\nnormalizes the result as much as possible.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs", 
  "doc": "Get information about the arguments accepted by a code object.\n\nThree things are returned: (args, varargs, varkw), where\n'args' is the list of argument names. Keyword-only arguments are\nappended. 'varargs' and 'varkw' are the names of the * and **\narguments or None.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargspec", 
  "doc": "Get the names and default values of a function's arguments.\n\nA tuple of four things is returned: (args, varargs, varkw, defaults).\n'args' is a list of the argument names.\n'args' will include keyword-only argument names.\n'varargs' and 'varkw' are the names of the * and ** arguments or None.\n'defaults' is an n-tuple of the default values of the last n arguments.\n\nUse the getfullargspec() API for Python-3000 code, as annotations\nand keyword arguments are supported. getargspec() will raise ValueError\nif the func has either annotations or keyword arguments.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargvalues", 
  "doc": "Get information about arguments passed into a particular frame.\n\nA tuple of four things is returned: (args, varargs, varkw, locals).\n'args' is a list of the argument names.\n'varargs' and 'varkw' are the names of the * and ** arguments or None.\n'locals' is the locals dictionary of the given frame.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getattr_static", 
  "doc": "Retrieve attributes without triggering dynamic lookup via the\ndescriptor protocol,  __getattr__ or __getattribute__.\n\nNote: this function may not be able to retrieve all attributes\nthat getattr can fetch (like dynamically created attributes)\nand may find attributes that getattr can't (like descriptors\nthat raise AttributeError). It can also return descriptor objects\ninstead of instance members in some cases. See the\ndocumentation for details.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getblock", 
  "doc": "Extract the block of code at the top of the given list of lines.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcallargs", 
  "doc": "Get the mapping of arguments to values.\n\nA dict is returned, with keys the function argument names (including the\nnames of the * and ** arguments, if any), and values the respective bound\nvalues from 'positional' and 'named'.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getclasstree", 
  "doc": "Arrange the given list of classes into a hierarchy of nested lists.\n\nWhere a nested list appears, it contains classes derived from the class\nwhose entry immediately precedes the list.  Each entry is a 2-tuple\ncontaining a class and a tuple of its base classes.  If the 'unique'\nargument is true, exactly one entry appears in the returned structure\nfor each class in the given list.  Otherwise, classes using multiple\ninheritance and their descendants will appear multiple times.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcomments", 
  "doc": "Get lines of comments immediately preceding an object's source code.\n\nReturns None when source can't be found.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getdoc", 
  "doc": "Get the documentation string for an object.\n\nAll tabs are expanded to spaces.  To clean up docstrings that are\nindented to line up with blocks of code, any whitespace than can be\nuniformly removed from the second line onwards is removed.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getfile", 
  "doc": "Work out which source or compiled file an object was defined in.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getframeinfo", 
  "doc": "Get information about a frame or traceback object.\n\nA tuple of five things is returned: the filename, the line number of\nthe current line, the function name, a list of lines of context from\nthe source code, and the index of the current line within that list.\nThe optional second argument specifies the number of lines of context\nto return, which are centered around the current line.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getfullargspec", 
  "doc": "Get the names and default values of a function's arguments.\n\nA tuple of seven things is returned:\n(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults annotations).\n'args' is a list of the argument names.\n'varargs' and 'varkw' are the names of the * and ** arguments or None.\n'defaults' is an n-tuple of the default values of the last n arguments.\n'kwonlyargs' is a list of keyword-only argument names.\n'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n'annotations' is a dictionary mapping argument names to annotations.\n\nThe first four items in the tuple correspond to getargspec().", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getgeneratorstate", 
  "doc": "Get current state of a generator-iterator.\n\nPossible states are:\n  GEN_CREATED: Waiting to start execution.\n  GEN_RUNNING: Currently being executed by the interpreter.\n  GEN_SUSPENDED: Currently suspended at a yield expression.\n  GEN_CLOSED: Execution has completed.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getinnerframes", 
  "doc": "Get a list of records for a traceback's frame and all lower frames.\n\nEach record contains a frame object, filename, line number, function\nname, a list of lines of context, and index within the context.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getlineno", 
  "doc": "Get the line number from a frame object, allowing for optimization.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmembers", 
  "doc": "Return all members of an object as (name, value) pairs sorted by name.\nOptionally, only return members that satisfy a given predicate.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmodule", 
  "doc": "Return the module an object was defined in, or None if not found.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmoduleinfo", 
  "doc": "Get the module name, suffix, mode, and module type for a given file.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmodulename", 
  "doc": "Return the module name for a given file, or None.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmro", 
  "doc": "Return tuple of base classes (including cls) in method resolution order.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getouterframes", 
  "doc": "Get a list of records for a frame and all higher (calling) frames.\n\nEach record contains a frame object, filename, line number, function\nname, a list of lines of context, and index within the context.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsource", 
  "doc": "Return the text of the source code for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a single string.  An\nIOError is raised if the source code cannot be retrieved.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsourcefile", 
  "doc": "Return the filename that can be used to locate an object's source.\nReturn None if no way can be identified to get the source.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsourcelines", 
  "doc": "Return a list of source lines and starting line number for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a list of the lines\ncorresponding to the object and the line number indicates where in the\noriginal source file the first line of code was found.  An IOError is\nraised if the source code cannot be retrieved.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "indentsize", 
  "doc": "Return the indent size, in spaces, at the start of a line of text.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isabstract", 
  "doc": "Return true if the object is an abstract base class (ABC).", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isbuiltin", 
  "doc": "Return true if the object is a built-in function or method.\n\nBuilt-in functions and methods provide these attributes:\n    __doc__         documentation string\n    __name__        original name of this function or method\n    __self__        instance to which a method is bound, or None", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isclass", 
  "doc": "Return true if the object is a class.\n\nClass objects provide these attributes:\n    __doc__         documentation string\n    __module__      name of module in which this class was defined", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iscode", 
  "doc": "Return true if the object is a code object.\n\nCode objects provide these attributes:\n    co_argcount     number of arguments (not including * or ** args)\n    co_code         string of raw compiled bytecode\n    co_consts       tuple of constants used in the bytecode\n    co_filename     name of file in which this code object was created\n    co_firstlineno  number of first line in Python source code\n    co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg\n    co_lnotab       encoded mapping of line numbers to bytecode indices\n    co_name         name with which this code object was defined\n    co_names        tuple of names of local variables\n    co_nlocals      number of local variables\n    co_stacksize    virtual machine stack space required\n    co_varnames     tuple of names of arguments and local variables", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdatadescriptor", 
  "doc": "Return true if the object is a data descriptor.\n\nData descriptors have both a __get__ and a __set__ attribute.  Examples are\nproperties (defined in Python) and getsets and members (defined in C).\nTypically, data descriptors will also have __name__ and __doc__ attributes\n(properties, getsets, and members have both of these attributes), but this\nis not guaranteed.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isframe", 
  "doc": "Return true if the object is a frame object.\n\nFrame objects provide these attributes:\n    f_back          next outer frame object (this frame's caller)\n    f_builtins      built-in namespace seen by this frame\n    f_code          code object being executed in this frame\n    f_globals       global namespace seen by this frame\n    f_lasti         index of last attempted instruction in bytecode\n    f_lineno        current line number in Python source code\n    f_locals        local namespace seen by this frame\n    f_trace         tracing function for this frame, or None", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfunction", 
  "doc": "Return true if the object is a user-defined function.\n\nFunction objects provide these attributes:\n    __doc__         documentation string\n    __name__        name with which this function was defined\n    __code__        code object containing compiled function bytecode\n    __defaults__    tuple of any default values for arguments\n    __globals__     global namespace in which this function was defined\n    __annotations__ dict of parameter annotations\n    __kwdefaults__  dict of keyword only parameters with defaults", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isgenerator", 
  "doc": "Return true if the object is a generator.\n\nGenerator objects provide these attributes:\n    __iter__        defined to support interation over container\n    close           raises a new GeneratorExit exception inside the\n                    generator to terminate the iteration\n    gi_code         code object\n    gi_frame        frame object or possibly None once the generator has\n                    been exhausted\n    gi_running      set to 1 when generator is executing, 0 otherwise\n    next            return the next item from the container\n    send            resumes the generator and \"sends\" a value that becomes\n                    the result of the current yield-expression\n    throw           used to raise an exception inside the generator", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isgeneratorfunction", 
  "doc": "Return true if the object is a user-defined generator function.\n\nGenerator function objects provides same attributes as functions.\n\nSee help(isfunction) for attributes listing.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isgetsetdescriptor", 
  "doc": "Return true if the object is a getset descriptor.\n\ngetset descriptors are specialized descriptors defined in extension\nmodules.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismemberdescriptor", 
  "doc": "Return true if the object is a member descriptor.\n\nMember descriptors are specialized descriptors defined in extension\nmodules.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismethod", 
  "doc": "Return true if the object is an instance method.\n\nInstance method objects provide these attributes:\n    __doc__         documentation string\n    __name__        name with which this method was defined\n    __func__        function object containing implementation of method\n    __self__        instance to which this method is bound", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismethoddescriptor", 
  "doc": "Return true if the object is a method descriptor.\n\nBut not if ismethod() or isclass() or isfunction() are true.\n\nThis is new in Python 2.2, and, for example, is true of int.__add__.\nAn object passing this test has a __get__ attribute but not a __set__\nattribute, but beyond that the set of attributes varies.  __name__ is\nusually sensible, and __doc__ often is.\n\nMethods implemented via descriptors that also pass one of the other\ntests return false from the ismethoddescriptor() test, simply because\nthe other tests promise more -- you can, e.g., count on having the\n__func__ attribute (etc) when an object passes ismethod().", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismodule", 
  "doc": "Return true if the object is a module.\n\nModule objects provide these attributes:\n    __cached__      pathname to byte compiled file\n    __doc__         documentation string\n    __file__        filename (missing for built-in modules)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isroutine", 
  "doc": "Return true if the object is any kind of function or method.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istraceback", 
  "doc": "Return true if the object is a traceback.\n\nTraceback objects provide these attributes:\n    tb_frame        frame object at this level\n    tb_lasti        index of last attempted instruction in bytecode\n    tb_lineno       current line number in Python source code\n    tb_next         next inner traceback object (called by this level)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Functional tools for creating and using iterators.\n\nInfinite iterators:\ncount([n]) --> n, n+1, n+2, ...\ncycle(p) --> p0, p1, ... plast, p0, p1, ...\nrepeat(elem [,n]) --> elem, elem, elem, ... endlessly or up to n times\n\nIterators terminating on the shortest input sequence:\naccumulate(p, start=0) --> p0, p0+p1, p0+p1+p2\nchain(p, q, ...) --> p0, p1, ... plast, q0, q1, ... \ncompress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...\ndropwhile(pred, seq) --> seq[n], seq[n+1], starting when pred fails\ngroupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)\nfilterfalse(pred, seq) --> elements of seq where pred(elem) is False\nislice(seq, [start,] stop [, step]) --> elements from\n       seq[start:stop:step]\nstarmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...\ntee(it, n=2) --> (it1, it2 , ... itn) splits one iterator into n\ntakewhile(pred, seq) --> seq[0], seq[1], until pred fails\nzip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ... \n\nCombinatoric generators:\nproduct(p, q, ... [repeat=1]) --> cartesian product\npermutations(p[, r])\ncombinations(p, r)\ncombinations_with_replacement(p, r)", 
  "line": 0, 
  "type": "module", 
  "name": "itertools", 
  "file": null
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "stack", 
  "doc": "Return a list of records for the stack above the caller's frame.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "A collection of string constants.\n\nPublic module variables:\n\nwhitespace -- a string containing all ASCII whitespace\nascii_lowercase -- a string containing all ASCII lowercase letters\nascii_uppercase -- a string containing all ASCII uppercase letters\nascii_letters -- a string containing all ASCII letters\ndigits -- a string containing all ASCII decimal digits\nhexdigits -- a string containing all ASCII hexadecimal digits\noctdigits -- a string containing all ASCII octal digits\npunctuation -- a string containing all ASCII punctuation characters\nprintable -- a string containing all ASCII characters considered printable", 
  "line": 0, 
  "type": "module", 
  "name": "string", 
  "file": "/usr/lib/python3.2/string.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "trace", 
  "doc": "Return a list of records for the stack below the current exception.", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Define names for built-in types that aren't directly accessible as a builtin.", 
  "line": 0, 
  "type": "module", 
  "name": "types", 
  "file": "/usr/lib/python3.2/types.py"
 }, 
 {
  "name": "walktree", 
  "doc": "Recursive helper function for getclasstree().", 
  "module": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BlockingIOError", 
  "doc": "Exception raised when I/O would block on a non-blocking I/O stream", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedIOBase", 
  "doc": null, 
  "module": "io", 
  "file": "/usr/lib/python3.2/io.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedRWPair", 
  "doc": "A buffered reader and writer object together.\n\nA buffered reader object and buffered writer object put together to\nform a sequential IO object that can read and write. This is typically\nused with a socket or two-way pipe.\n\nreader and writer are RawIOBase objects that are readable and\nwriteable respectively. If the buffer_size is omitted it defaults to\nDEFAULT_BUFFER_SIZE.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedRandom", 
  "doc": "A buffered interface to random access streams.\n\nThe constructor creates a reader and writer for a seekable stream,\nraw, given in the first argument. If the buffer_size is omitted it\ndefaults to DEFAULT_BUFFER_SIZE. max_buffer_size isn't used anymore.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedReader", 
  "doc": "Create a new buffered reader using the given readable raw IO object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BufferedWriter", 
  "doc": "A buffer for a writeable sequential RawIO object.\n\nThe constructor creates a BufferedWriter for the given writeable raw\nstream. If the buffer_size is not given, it defaults to\nDEFAULT_BUFFER_SIZE. max_buffer_size isn't used anymore.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BytesIO", 
  "doc": "BytesIO([buffer]) -> object\n\nCreate a buffered I/O implementation using an in-memory bytes\nbuffer, ready for reading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FileIO", 
  "doc": "file(name: str[, mode: str]) -> file IO object\n\nOpen a file.  The mode can be 'r', 'w' or 'a' for reading (default),\nwriting or appending.  The file will be created if it doesn't exist\nwhen opened for writing or appending; it will be truncated when\nopened for writing.  Add a '+' to the mode to allow simultaneous\nreading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IOBase", 
  "doc": null, 
  "module": "io", 
  "file": "/usr/lib/python3.2/io.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IncrementalNewlineDecoder", 
  "doc": "Codec used when reading a file in universal newlines mode.  It wraps\nanother incremental decoder, translating \\r\\n and \\r into \\n.  It also\nrecords the types of newlines encountered.  When used with\ntranslate=False, it ensures that the newline sequence is returned in\none piece. When used with decoder=None, it expects unicode strings as\ndecode input and translates newlines without first invoking an external\ndecoder.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OpenWrapper", 
  "doc": "open(file, mode='r', buffering=-1, encoding=None,\n     errors=None, newline=None, closefd=True) -> file object\n\nOpen file and return a stream.  Raise IOError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), and 'a' for appending (which on some Unix systems,\nmeans that all writes append to the end of the file regardless of the\ncurrent seek position). In text mode, if encoding is not specified the\nencoding used is platform dependent. (For reading and writing raw\nbytes use binary mode and leave encoding unspecified.) The available\nmodes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n'U'       universal newline mode (for backwards compatibility; unneeded\n          for new code)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register for a list of the permitted\nencoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '', no translation takes place. If newline is any of the\n  other legal values, any '\\n' characters written are translated to\n  the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RawIOBase", 
  "doc": null, 
  "module": "io", 
  "file": "/usr/lib/python3.2/io.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextIOBase", 
  "doc": null, 
  "module": "io", 
  "file": "/usr/lib/python3.2/io.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextIOWrapper", 
  "doc": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding.\n\nerrors determines the strictness of encoding and decoding (see the\ncodecs.register) and defaults to \"strict\".\n\nnewline can be None, '', '\\n', '\\r', or '\\r\\n'.  It controls the\nhandling of line endings. If it is None, universal newlines is\nenabled.  With this enabled, on input, the lines endings '\\n', '\\r',\nor '\\r\\n' are translated to '\\n' before being returned to the\ncaller. Conversely, on output, '\\n' is translated to the system\ndefault line seperator, os.linesep. If newline is any other of its\nlegal values, that newline becomes the newline when the file is read\nand it is returned untranslated. On output, '\\n' is converted to the\nnewline.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnsupportedOperation", 
  "doc": null, 
  "module": "io", 
  "file": "/usr/lib/python3.2/io.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseperation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "_io", 
  "file": null
 }, 
 {
  "doc": "Abstract Base Classes (ABCs) according to PEP 3119.", 
  "line": 0, 
  "type": "module", 
  "name": "abc", 
  "file": "/usr/lib/python3.2/abc.py"
 }, 
 {
  "name": "open", 
  "doc": "open(file, mode='r', buffering=-1, encoding=None,\n     errors=None, newline=None, closefd=True) -> file object\n\nOpen file and return a stream.  Raise IOError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), and 'a' for appending (which on some Unix systems,\nmeans that all writes append to the end of the file regardless of the\ncurrent seek position). In text mode, if encoding is not specified the\nencoding used is platform dependent. (For reading and writing raw\nbytes use binary mode and leave encoding unspecified.) The available\nmodes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n'U'       universal newline mode (for backwards compatibility; unneeded\n          for new code)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register for a list of the permitted\nencoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '', no translation takes place. If newline is any of the\n  other legal values, any '\\n' characters written are translated to\n  the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "JSONDecoder", 
  "doc": "Simple JSON <http://json.org> decoder\n\nPerforms the following translations in decoding by default:\n\n+---------------+-------------------+\n| JSON          | Python            |\n+===============+===================+\n| object        | dict              |\n+---------------+-------------------+\n| array         | list              |\n+---------------+-------------------+\n| string        | str               |\n+---------------+-------------------+\n| number (int)  | int               |\n+---------------+-------------------+\n| number (real) | float             |\n+---------------+-------------------+\n| true          | True              |\n+---------------+-------------------+\n| false         | False             |\n+---------------+-------------------+\n| null          | None              |\n+---------------+-------------------+\n\nIt also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\ntheir corresponding ``float`` values, which is outside the JSON spec.", 
  "module": "json", 
  "file": "/usr/lib/python3.2/json/decoder.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "JSONEncoder", 
  "doc": "Extensible JSON <http://json.org> encoder for Python data structures.\n\nSupports the following objects and types by default:\n\n+-------------------+---------------+\n| Python            | JSON          |\n+===================+===============+\n| dict              | object        |\n+-------------------+---------------+\n| list, tuple       | array         |\n+-------------------+---------------+\n| str               | string        |\n+-------------------+---------------+\n| int, float        | number        |\n+-------------------+---------------+\n| True              | true          |\n+-------------------+---------------+\n| False             | false         |\n+-------------------+---------------+\n| None              | null          |\n+-------------------+---------------+\n\nTo extend this to recognize other objects, subclass and implement a\n``.default()`` method with another method that returns a serializable\nobject for ``o`` if possible, otherwise it should call the superclass\nimplementation (to raise ``TypeError``).", 
  "module": "json", 
  "file": "/usr/lib/python3.2/json/encoder.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Implementation of JSONDecoder", 
  "line": 0, 
  "type": "module", 
  "name": "decoder", 
  "file": "/usr/lib/python3.2/json/decoder.py"
 }, 
 {
  "name": "dump", 
  "doc": "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object).\n\nIf ``skipkeys`` is true then ``dict`` keys that are not basic types\n(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\ninstead of raising a ``TypeError``.\n\nIf ``ensure_ascii`` is false, then the strings written to ``fp`` can\ncontain non-ASCII characters if they appear in strings contained in\n``obj``. Otherwise, all such characters are escaped in JSON strings.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``OverflowError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\nin strict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. ``None`` is the most compact\nrepresentation.\n\nIf ``separators`` is an ``(item_separator, dict_separator)`` tuple\nthen it will be used instead of the default ``(', ', ': ')`` separators.\n``(',', ':')`` is the most compact JSON representation.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg; otherwise ``JSONEncoder`` is used.", 
  "module": "json", 
  "file": "/usr/lib/python3.2/json/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dumps", 
  "doc": "Serialize ``obj`` to a JSON formatted ``str``.\n\nIf ``skipkeys`` is false then ``dict`` keys that are not basic types\n(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\ninstead of raising a ``TypeError``.\n\nIf ``ensure_ascii`` is false, then the return value can contain non-ASCII\ncharacters if they appear in strings contained in ``obj``. Otherwise, all\nsuch characters are escaped in JSON strings.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``OverflowError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\nstrict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. ``None`` is the most compact\nrepresentation.\n\nIf ``separators`` is an ``(item_separator, dict_separator)`` tuple\nthen it will be used instead of the default ``(', ', ': ')`` separators.\n``(',', ':')`` is the most compact JSON representation.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg; otherwise ``JSONEncoder`` is used.", 
  "module": "json", 
  "file": "/usr/lib/python3.2/json/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Implementation of JSONEncoder", 
  "line": 0, 
  "type": "module", 
  "name": "encoder", 
  "file": "/usr/lib/python3.2/json/encoder.py"
 }, 
 {
  "name": "load", 
  "doc": "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\na JSON document) to a Python object.\n\n``object_hook`` is an optional function that will be called with the\nresult of any object literal decode (a ``dict``). The return value of\n``object_hook`` will be used instead of the ``dict``. This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n``object_pairs_hook`` is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs.  The\nreturn value of ``object_pairs_hook`` will be used instead of the ``dict``.\nThis feature can be used to implement custom decoders that rely on the\norder that the key and value pairs are decoded (for example,\ncollections.OrderedDict will remember the order of insertion). If\n``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg; otherwise ``JSONDecoder`` is used.", 
  "module": "json", 
  "file": "/usr/lib/python3.2/json/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "loads", 
  "doc": "Deserialize ``s`` (a ``str`` instance containing a JSON\ndocument) to a Python object.\n\n``object_hook`` is an optional function that will be called with the\nresult of any object literal decode (a ``dict``). The return value of\n``object_hook`` will be used instead of the ``dict``. This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n``object_pairs_hook`` is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs.  The\nreturn value of ``object_pairs_hook`` will be used instead of the ``dict``.\nThis feature can be used to implement custom decoders that rely on the\norder that the key and value pairs are decoded (for example,\ncollections.OrderedDict will remember the order of insertion). If\n``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n\n``parse_float``, if specified, will be called with the string\nof every JSON float to be decoded. By default this is equivalent to\nfloat(num_str). This can be used to use another datatype or parser\nfor JSON floats (e.g. decimal.Decimal).\n\n``parse_int``, if specified, will be called with the string\nof every JSON int to be decoded. By default this is equivalent to\nint(num_str). This can be used to use another datatype or parser\nfor JSON integers (e.g. float).\n\n``parse_constant``, if specified, will be called with one of the\nfollowing strings: -Infinity, Infinity, NaN, null, true, false.\nThis can be used to raise an exception if invalid JSON numbers\nare encountered.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg; otherwise ``JSONDecoder`` is used.\n\nThe ``encoding`` argument is ignored and deprecated.", 
  "module": "json", 
  "file": "/usr/lib/python3.2/json/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "JSON token scanner", 
  "line": 0, 
  "type": "module", 
  "name": "scanner", 
  "file": "/usr/lib/python3.2/json/scanner.py"
 }, 
 {
  "name": "iskeyword", 
  "doc": "x.__contains__(y) <==> y in x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "keyword", 
  "file": "/usr/lib/python3.2/keyword.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "checkcache", 
  "doc": "Discard cache entries that are out of date.\n(This is not checked upon each call!)", 
  "module": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "clearcache", 
  "doc": "Clear the cache entirely.", 
  "module": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getline", 
  "doc": null, 
  "module": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getlines", 
  "doc": "Get the lines for a file from the cache.\nUpdate the cache if it doesn't contain an entry for this file already.", 
  "module": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "updatecache", 
  "doc": "Update a cache entry and return its list of lines.\nIf something's wrong, print a message, discard the cache entry,\nand return an empty list.", 
  "module": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_build_localename", 
  "doc": "Builds a locale code from the given tuple (language code,\nencoding).\n\nNo aliasing or normalizing takes place.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_builtin_str", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_format", 
  "doc": null, 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_group", 
  "doc": null, 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_grouping_intervals", 
  "doc": null, 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_localeconv", 
  "doc": "() -> dict. Returns numeric and monetary locale-specific parameters.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_localename", 
  "doc": "Parses the locale code for localename and returns the\nresult as tuple (language code, encoding).\n\nThe localename is normalized and passed through the locale\nalias engine. A ValueError is raised in case the locale name\ncannot be parsed.\n\nThe language code corresponds to RFC 1766.  code and encoding\ncan be None in case the values cannot be determined or are\nunknown to this implementation.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_print_locale", 
  "doc": "Test function.\n    ", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_setlocale", 
  "doc": "(integer,string=None) -> string. Activates/queries locale processing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strcoll", 
  "doc": "strcoll(string,string) -> int.\nCompares two strings according to the locale.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strip_padding", 
  "doc": null, 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_strxfrm", 
  "doc": "strxfrm(string) -> string.\nReturns a string that behaves for cmp locale-aware.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "atof", 
  "doc": "Parses a string as a float according to the locale settings.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "atoi", 
  "doc": "Converts a string to an integer according to the locale settings.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bind_textdomain_codeset", 
  "doc": "bind_textdomain_codeset(domain, codeset) -> string\nBind the C library's domain to codeset.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bindtextdomain", 
  "doc": "bindtextdomain(domain, dir) -> string\nBind the C library's domain to dir.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "name": "currency", 
  "doc": "Formats val according to the currency settings\nin the current locale.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dcgettext", 
  "doc": "dcgettext(domain, msg, category) -> string\nReturn translation of msg in domain and category.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dgettext", 
  "doc": "dgettext(domain, msg) -> string\nReturn translation of msg in domain.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Standard \"encodings\" Package\n\n    Standard Python encoding modules are stored in this package\n    directory.\n\n    Codec modules must have names corresponding to normalized encoding\n    names as defined in the normalize_encoding() function below, e.g.\n    'utf-8' must be implemented by the module 'utf_8.py'.\n\n    Each codec module must export the following interface:\n\n    * getregentry() -> codecs.CodecInfo object\n    The getregentry() API must return a CodecInfo object with encoder, decoder,\n    incrementalencoder, incrementaldecoder, streamwriter and streamreader\n    atttributes which adhere to the Python Codec Interface Standard.\n\n    In addition, a module may optionally also define the following\n    APIs which are then used by the package's codec search function:\n\n    * getaliases() -> sequence of encoding name strings to use as aliases\n\n    Alias names returned by getaliases() must be normalized encoding\n    names as defined by normalize_encoding().\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "encodings", 
  "file": "/usr/lib/python3.2/encodings/__init__.py"
 }, 
 {
  "name": "format", 
  "doc": "Returns the locale-aware substitution of a %? specifier\n(percent).\n\nadditional is for format strings which contain one or more\n'*' modifiers.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_string", 
  "doc": "Formats a string in the same way that the % formatting would use,\nbut takes the current locale into account.\nGrouping is applied if the third parameter is true.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "functools.py - Tools for working with functions and callable objects", 
  "line": 0, 
  "type": "module", 
  "name": "functools", 
  "file": "/usr/lib/python3.2/functools.py"
 }, 
 {
  "name": "getdefaultlocale", 
  "doc": "Tries to determine the default locale settings and returns\nthem as tuple (language code, encoding).\n\nAccording to POSIX, a program which has not called\nsetlocale(LC_ALL, \"\") runs using the portable 'C' locale.\nCalling setlocale(LC_ALL, \"\") lets it use the default locale as\ndefined by the LANG variable. Since we don't want to interfere\nwith the current locale setting we thus emulate the behavior\nin the way described above.\n\nTo maintain compatibility with other platforms, not only the\nLANG variable is tested, but a list of variables given as\nenvvars parameter. The first found to be defined will be\nused. envvars defaults to the search path used in GNU gettext;\nit must always contain the variable name 'LANG'.\n\nExcept for the code 'C', the language code corresponds to RFC\n1766.  code and encoding can be None in case the values cannot\nbe determined.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getlocale", 
  "doc": "Returns the current setting for the given locale category as\ntuple (language code, encoding).\n\ncategory may be one of the LC_* value except LC_ALL. It\ndefaults to LC_CTYPE.\n\nExcept for the code 'C', the language code corresponds to RFC\n1766.  code and encoding can be None in case the values cannot\nbe determined.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpreferredencoding", 
  "doc": "Return the charset that the user is likely using,\naccording to the system configuration.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gettext", 
  "doc": "gettext(msg) -> string\nReturn translation of msg.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "localeconv", 
  "doc": "() -> dict. Returns numeric and monetary locale-specific parameters.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nl_langinfo", 
  "doc": "nl_langinfo(key) -> string\nReturn the value for the locale information associated with key.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normalize", 
  "doc": "Returns a normalized locale code for the given locale\nname.\n\nThe returned locale code is formatted for use with\nsetlocale().\n\nIf normalization fails, the original name is returned\nunchanged.\n\nIf the given encoding is not known, the function defaults to\nthe default encoding for the locale code just like setlocale()\ndoes.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "resetlocale", 
  "doc": "Sets the locale for category to the default setting.\n\nThe default setting is determined by calling\ngetdefaultlocale(). category defaults to LC_ALL.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setlocale", 
  "doc": "Set the locale for the given category.  The locale can be\na string, an iterable of two strings (language code and encoding),\nor None.\n\nIterables are converted to strings using the locale aliasing\nengine.  Locale strings are passed directly to the C lib.\n\ncategory may be given as one of the LC_* values.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "str", 
  "doc": "Convert float to integer, taking the locale into account.", 
  "module": "locale", 
  "file": "/usr/lib/python3.2/locale.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strcoll", 
  "doc": "string,string -> int. Compares two strings according to the locale.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strxfrm", 
  "doc": "strxfrm(string) -> string.\n\nReturn a string that can be used as a key for locale-aware comparisons.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "textdomain", 
  "doc": "textdomain(domain) -> string\nSet the C library's textdmain to domain, returning the new domain.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BufferingFormatter", 
  "doc": "A formatter suitable for formatting a number of records.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FileHandler", 
  "doc": "A handler class which writes formatted logging records to disk files.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Filter", 
  "doc": "Filter instances are used to perform arbitrary filtering of LogRecords.\n\nLoggers and Handlers can optionally use Filter instances to filter\nrecords as desired. The base filter class only allows events which are\nbelow a certain point in the logger hierarchy. For example, a filter\ninitialized with \"A.B\" will allow events logged by loggers \"A.B\",\n\"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\ninitialized with the empty string, all events are passed.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Filterer", 
  "doc": "A base class for loggers and handlers which allows them to share\ncommon code.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Formatter", 
  "doc": "Formatter instances are used to convert a LogRecord to text.\n\nFormatters need to know how a LogRecord is constructed. They are\nresponsible for converting a LogRecord to (usually) a string which can\nbe interpreted by either a human or an external system. The base Formatter\nallows a formatting string to be specified. If none is supplied, the\ndefault value of \"%s(message)\" is used.\n\nThe Formatter can be initialized with a format string which makes use of\nknowledge of the LogRecord attributes - e.g. the default value mentioned\nabove makes use of the fact that the user's message and arguments are pre-\nformatted into a LogRecord's message attribute. Currently, the useful\nattributes in a LogRecord are described by:\n\n%(name)s            Name of the logger (logging channel)\n%(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                    WARNING, ERROR, CRITICAL)\n%(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                    \"WARNING\", \"ERROR\", \"CRITICAL\")\n%(pathname)s        Full pathname of the source file where the logging\n                    call was issued (if available)\n%(filename)s        Filename portion of pathname\n%(module)s          Module (name portion of filename)\n%(lineno)d          Source line number where the logging call was issued\n                    (if available)\n%(funcName)s        Function name\n%(created)f         Time when the LogRecord was created (time.time()\n                    return value)\n%(asctime)s         Textual time when the LogRecord was created\n%(msecs)d           Millisecond portion of the creation time\n%(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                    relative to the time the logging module was loaded\n                    (typically at application startup time)\n%(thread)d          Thread ID (if available)\n%(threadName)s      Thread name (if available)\n%(process)d         Process ID (if available)\n%(message)s         The result of record.getMessage(), computed just as\n                    the record is emitted", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Handler", 
  "doc": "Handler instances dispatch logging events to specific destinations.\n\nThe base handler class. Acts as a placeholder which defines the Handler\ninterface. Handlers can optionally use Formatter instances to format\nrecords as desired. By default, no formatter is specified; in this case,\nthe 'raw' message as determined by record.message is logged.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LogRecord", 
  "doc": "A LogRecord instance represents an event being logged.\n\nLogRecord instances are created every time something is logged. They\ncontain all the information pertinent to the event being logged. The\nmain information passed in is in msg and args, which are combined\nusing str(msg) % args to create the message field of the record. The\nrecord also includes information such as when the record was created,\nthe source line where the logging call was made, and any exception\ninformation to be logged.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Logger", 
  "doc": "Instances of the Logger class represent a single logging channel. A\n\"logging channel\" indicates an area of an application. Exactly how an\n\"area\" is defined is up to the application developer. Since an\napplication can have any number of areas, logging channels are identified\nby a unique string. Application areas can be nested (e.g. an area\nof \"input processing\" might include sub-areas \"read CSV files\", \"read\nXLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\nchannel names are organized into a namespace hierarchy where levels are\nseparated by periods, much like the Java or Python package namespace. So\nin the instance given above, channel names might be \"input\" for the upper\nlevel, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\nThere is no arbitrary limit to the depth of nesting.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LoggerAdapter", 
  "doc": "An adapter for loggers which makes it easier to specify contextual\ninformation in logging output.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Manager", 
  "doc": "There is [under normal circumstances] just one Manager instance, which\nholds the hierarchy of loggers.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NullHandler", 
  "doc": "This handler does nothing. It's intended to be used to avoid the\n\"No handlers could be found for logger XXX\" one-off warning. This is\nimportant for library code, which may contain code to log events. If a user\nof the library does not configure logging, the one-off warning might be\nproduced; to avoid this, the library developer simply needs to instantiate\na NullHandler and add it to the top-level logger of the library module or\npackage.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PercentStyle", 
  "doc": null, 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PlaceHolder", 
  "doc": "PlaceHolder instances are used in the Manager logger hierarchy to take\nthe place of nodes for which no loggers have been defined. This class is\nintended for internal use only and not as part of the public API.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RootLogger", 
  "doc": "A root logger is not that different to any other logger, except that\nit must have a logging level and there is only one instance of it in\nthe hierarchy.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StrFormatStyle", 
  "doc": null, 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StreamHandler", 
  "doc": "A handler class which writes logging records, appropriately formatted,\nto a stream. Note that this class does not close the stream, as\nsys.stdout or sys.stderr may be used.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StringTemplateStyle", 
  "doc": null, 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Template", 
  "doc": "A string class for supporting $-substitutions.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/string.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StderrHandler", 
  "doc": "This class is like a StreamHandler using sys.stderr, but always uses\nwhatever sys.stderr is currently set to rather than the value of\nsys.stderr at handler construction time.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_acquireLock", 
  "doc": "Acquire the module-level lock for serializing access to shared data.\n\nThis should be released with _releaseLock().", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_addHandlerRef", 
  "doc": "Add a handler to the internal cleanup list using a weak reference.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_checkLevel", 
  "doc": null, 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_logRecordFactory", 
  "doc": "A LogRecord instance represents an event being logged.\n\nLogRecord instances are created every time something is logged. They\ncontain all the information pertinent to the event being logged. The\nmain information passed in is in msg and args, which are combined\nusing str(msg) % args to create the message field of the record. The\nrecord also includes information such as when the record was created,\nthe source line where the logging call was made, and any exception\ninformation to be logged.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_loggerClass", 
  "doc": "Instances of the Logger class represent a single logging channel. A\n\"logging channel\" indicates an area of an application. Exactly how an\n\"area\" is defined is up to the application developer. Since an\napplication can have any number of areas, logging channels are identified\nby a unique string. Application areas can be nested (e.g. an area\nof \"input processing\" might include sub-areas \"read CSV files\", \"read\nXLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\nchannel names are organized into a namespace hierarchy where levels are\nseparated by periods, much like the Java or Python package namespace. So\nin the instance given above, channel names might be \"input\" for the upper\nlevel, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\nThere is no arbitrary limit to the depth of nesting.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_releaseLock", 
  "doc": "Release the module-level lock acquired by calling _acquireLock().", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_removeHandlerRef", 
  "doc": "Remove a handler reference from the internal cleanup list.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_showwarning", 
  "doc": "Implementation of showwarnings which redirects to logging, which will first\ncheck to see if the file parameter is None. If a file is specified, it will\ndelegate to the original warnings implementation of showwarning. Otherwise,\nit will call warnings.formatwarning and will log the resulting string to a\nwarnings logger named \"py.warnings\" with level logging.WARNING.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "addLevelName", 
  "doc": "Associate 'levelName' with 'level'.\n\nThis is used when converting levels to text during message formatting.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "allow programmer to define multiple exit functions to be executedupon normal program termination.\n\nTwo public functions, register and unregister, are defined.", 
  "line": 0, 
  "type": "module", 
  "name": "atexit", 
  "file": null
 }, 
 {
  "name": "basicConfig", 
  "doc": "Do basic configuration for the logging system.\n\nThis function does nothing if the root logger already has handlers\nconfigured. It is a convenience method intended for use by simple scripts\nto do one-shot configuration of the logging package.\n\nThe default behaviour is to create a StreamHandler which writes to\nsys.stderr, set a formatter using the BASIC_FORMAT format string, and\nadd the handler to the root logger.\n\nA number of optional keyword arguments may be specified, which can alter\nthe default behaviour.\n\nfilename  Specifies that a FileHandler be created, using the specified\n          filename, rather than a StreamHandler.\nfilemode  Specifies the mode to open the file, if filename is specified\n          (if filemode is unspecified, it defaults to 'a').\nformat    Use the specified format string for the handler.\ndatefmt   Use the specified date/time format.\nstyle     If a format string is specified, use this to specify the\n          type of format string (possible values '%', '{', '$', for\n          %-formatting, :meth:`str.format` and :class:`string.Template`\n          - defaults to '%').\nlevel     Set the root logger level to the specified level.\nstream    Use the specified stream to initialize the StreamHandler. Note\n          that this argument is incompatible with 'filename' - if both\n          are present, 'stream' is ignored.\n\nNote that you could specify a stream created using open(filename, mode)\nrather than passing the filename and mode in. However, it should be\nremembered that StreamHandler does not close its stream (since it may be\nusing sys.stdout or sys.stderr), whereas FileHandler closes its stream\nwhen the handler is closed.\n\n.. versionchanged: 3.2\n   Added the ``style`` parameter.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "captureWarnings", 
  "doc": "If capture is true, redirect all warnings to the logging package.\nIf capture is False, ensure that warnings are not redirected to logging\nbut to their original destinations.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py"
 }, 
 {
  "name": "critical", 
  "doc": "Log a message with severity 'CRITICAL' on the root logger. If the logger\nhas no handlers, call basicConfig() to add a console handler with a\npre-defined format.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "currentframe", 
  "doc": null, 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "debug", 
  "doc": "Log a message with severity 'DEBUG' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "disable", 
  "doc": "Disable all logging calls of severity 'level' and below.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": "Log a message with severity 'ERROR' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exception", 
  "doc": "Log a message with severity 'ERROR' on the root logger, with exception\ninformation. If the logger has no handlers, basicConfig() is called to add\na console handler with a pre-defined format.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fatal", 
  "doc": "Log a message with severity 'CRITICAL' on the root logger. If the logger\nhas no handlers, call basicConfig() to add a console handler with a\npre-defined format.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getLevelName", 
  "doc": "Return the textual representation of logging level 'level'.\n\nIf the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\nINFO, DEBUG) then you get the corresponding string. If you have\nassociated levels with names using addLevelName then the name you have\nassociated with 'level' is returned.\n\nIf a numeric value corresponding to one of the defined levels is passed\nin, the corresponding string representation is returned.\n\nOtherwise, the string \"Level %s\" % level is returned.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getLogRecordFactory", 
  "doc": "Return the factory to be used when instantiating a log record.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getLogger", 
  "doc": "Return a logger with the specified name, creating it if necessary.\n\nIf no name is specified, return the root logger.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getLoggerClass", 
  "doc": "Return the class to be used when instantiating a logger.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "info", 
  "doc": "Log a message with severity 'INFO' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "log", 
  "doc": "Log 'msg % args' with the integer severity 'level' on the root logger. If\nthe logger has no handlers, call basicConfig() to add a console handler\nwith a pre-defined format.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "makeLogRecord", 
  "doc": "Make a LogRecord whose attributes are defined by the specified dictionary,\nThis function is useful for converting a logging event received over\na socket connection (which is sent as a dictionary) into a LogRecord\ninstance.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "setLogRecordFactory", 
  "doc": "Set the factory to be used when instantiating a log record.\n\n:param factory: A callable which will be called to instantiate\na log record.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setLoggerClass", 
  "doc": "Set the class to be used when instantiating a logger. The class should\ndefine __init__() such that only a name argument is required, and the\n__init__() should call Logger.__init__()", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "shutdown", 
  "doc": "Perform any cleanup actions in the logging system (e.g. flushing\nbuffers).\n\nShould be called at application exit.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides primitive operations to write multi-threaded programs.\nThe 'threading' module provides a more convenient interface.", 
  "line": 0, 
  "type": "module", 
  "name": "thread", 
  "file": null
 }, 
 {
  "doc": "Thread module emulating a subset of Java's threading model.", 
  "line": 0, 
  "type": "module", 
  "name": "threading", 
  "file": "/usr/lib/python3.2/threading.py"
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "name": "warn", 
  "doc": "Log a message with severity 'WARNING' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "warning", 
  "doc": "Log a message with severity 'WARNING' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.", 
  "module": "logging", 
  "file": "/usr/lib/python3.2/logging/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "doc": "Weak reference support for Python.\n\nThis module is an implementation of PEP 205:\n\nhttp://www.python.org/dev/peps/pep-0205/", 
  "line": 0, 
  "type": "module", 
  "name": "weakref", 
  "file": "/usr/lib/python3.2/weakref.py"
 }, 
 {
  "name": "S_IFMT", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_IMODE", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISBLK", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISCHR", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISDIR", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISFIFO", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISLNK", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISREG", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISSOCK", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_colon", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abspath", 
  "doc": "Return an absolute path.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "basename", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "commonprefix", 
  "doc": "Given a list of pathnames, returns the longest common leading component", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dirname", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exists", 
  "doc": "Test whether a path exists.  Returns False for broken symbolic links", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expanduser", 
  "doc": "Dummy to retain interface-compatibility with other operating systems.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandvars", 
  "doc": "Dummy to retain interface-compatibility with other operating systems.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Path operations common to more than one OS\nDo not use directly.  The OS specific modules import the appropriate\nfunctions from this module themselves.", 
  "line": 0, 
  "type": "module", 
  "name": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py"
 }, 
 {
  "name": "getatime", 
  "doc": "Return the last access time of a file, reported by os.stat().", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getctime", 
  "doc": "Return the metadata change time of a file, reported by os.stat().", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmtime", 
  "doc": "Return the last modification time of a file, reported by os.stat().", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsize", 
  "doc": "Return the size of a file, reported by os.stat().", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isabs", 
  "doc": "Return true if a path is absolute.\nOn the Mac, relative paths begin with a colon,\nbut as a special case, paths with no colons at all are also relative.\nAnything else is absolute (the string up to the first colon is the\nvolume name).", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdir", 
  "doc": "Return true if the pathname refers to an existing directory.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfile", 
  "doc": "Test whether a path is a regular file", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islink", 
  "doc": "Return true if the pathname refers to a symbolic link.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismount", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lexists", 
  "doc": "Test whether a path exists.  Returns True for broken symbolic links", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "norm_error", 
  "doc": "Path cannot be normalized", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "normcase", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normpath", 
  "doc": "Normalize a pathname.  Will return the same result for\nequivalent paths.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "realpath", 
  "doc": null, 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "Split a pathname into two parts: the directory leading up to the final\nbit, and the basename (the filename, without colons, in that directory).\nThe result (s, t) is such that join(s, t) yields the original argument.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitdrive", 
  "doc": "Split a pathname into a drive specification and the rest of the\npath.  Useful on DOS/Windows/NT; on the Mac, the drive is always\nempty (don't use the volume name -- it doesn't have the same\nsyntactic and semantic oddities as DOS drive letters, such as there\nbeing a separate current directory per drive).", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitext", 
  "doc": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.", 
  "module": "macpath", 
  "file": "/usr/lib/python3.2/macpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_pncomp2url", 
  "doc": null, 
  "module": "macurl2path", 
  "file": "/usr/lib/python3.2/macurl2path.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "pathname2url", 
  "doc": "OS-specific conversion from a file system path to a relative URL\nof the 'file' scheme; not recommended for general use.", 
  "module": "macurl2path", 
  "file": "/usr/lib/python3.2/macurl2path.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "macurl2path", 
  "file": "/usr/lib/python3.2/macurl2path.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "url2pathname", 
  "doc": "OS-specific conversion from a relative URL of the 'file' scheme\nto a file system path; not recommended for general use.", 
  "module": "macurl2path", 
  "file": "/usr/lib/python3.2/macurl2path.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "urllib", 
  "file": "/usr/lib/python3.2/urllib/__init__.py"
 }, 
 {
  "name": "Babyl", 
  "doc": "An Rmail-style Babyl mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BabylMessage", 
  "doc": "Message with Babyl-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": "Raised for module-specific errors.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ExternalClashError", 
  "doc": "Another process caused an action to fail.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FormatError", 
  "doc": "A file appears to have an invalid format.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MH", 
  "doc": "An MH mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MHMessage", 
  "doc": "Message with MH-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MMDF", 
  "doc": "An MMDF mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MMDFMessage", 
  "doc": "Message with MMDF-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Mailbox", 
  "doc": "A group of messages in a particular place.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Maildir", 
  "doc": "A qmail-style Maildir mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MaildirMessage", 
  "doc": "Message with Maildir-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Message", 
  "doc": "Message with mailbox-format-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NoSuchMailboxError", 
  "doc": "The specified mailbox does not exist and won't be created.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NotEmptyError", 
  "doc": "The specified mailbox is not empty and deletion was requested.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_PartialFile", 
  "doc": "A read-only wrapper of part of a file.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_ProxyFile", 
  "doc": "A read-only wrapper of a file.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_create_carefully", 
  "doc": "Create a file if it doesn't exist and open for reading and writing.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_create_temporary", 
  "doc": "Create a temp file based on path and open for reading and writing.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_lock_file", 
  "doc": "Lock file f using lockf and dot locking.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_mboxMMDF", 
  "doc": "An mbox or MMDF mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_mboxMMDFMessage", 
  "doc": "Message with mbox- or MMDF-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_singlefileMailbox", 
  "doc": "A single-file mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_sync_close", 
  "doc": "Close file f, ensuring all changes are physically on disk.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_sync_flush", 
  "doc": "Ensure changes to file f are physically on disk.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unlock_file", 
  "doc": "Unlock file f using lockf and dot locking.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Calendar printing functions\n\nNote when comparing these calendars to the ones printed by cal(1): By\ndefault, these calendars have Monday as the first day of the week, and\nSunday as the last (the European convention). Use setfirstweekday() to\nset the first day of the week (0=Monday, 6=Sunday).", 
  "line": 0, 
  "type": "module", 
  "name": "calendar", 
  "file": "/usr/lib/python3.2/calendar.py"
 }, 
 {
  "doc": "Utilities for with-statement contexts.  See PEP 343.", 
  "line": 0, 
  "type": "module", 
  "name": "contextlib", 
  "file": "/usr/lib/python3.2/contextlib.py"
 }, 
 {
  "doc": "Generic (shallow and deep) copying operations.\n\nInterface summary:\n\n        import copy\n\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\n\nFor module specific errors, copy.Error is raised.\n\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\n\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\n\nPython's deep copy operation avoids these problems by:\n\n a) keeping a table of objects already copied during the current\n    copying pass\n\n b) letting user-defined classes override the copying operation or the\n    set of components copied\n\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\n\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods.", 
  "line": 0, 
  "type": "module", 
  "name": "copy", 
  "file": "/usr/lib/python3.2/copy.py"
 }, 
 {
  "doc": "A package for parsing, handling, and generating email messages.", 
  "line": 0, 
  "type": "module", 
  "name": "email", 
  "file": "/usr/lib/python3.2/email/__init__.py"
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "This module performs file control and I/O control on file \ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.", 
  "line": 0, 
  "type": "module", 
  "name": "fcntl", 
  "file": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "mbox", 
  "doc": "A classic mbox mailbox.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "mboxMessage", 
  "doc": "Message with mbox-specific properties.", 
  "module": "mailbox", 
  "file": "/usr/lib/python3.2/mailbox.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "findmatch", 
  "doc": "Find a match for a mailcap entry.\n\nReturn a tuple containing the command line, and the mailcap entry\nused; (None, None) if no match is found.  This may invoke the\n'test' command of several matching entries before deciding which\nentry to use.", 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findparam", 
  "doc": null, 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcaps", 
  "doc": "Return a dictionary containing the mailcap database.\n\nThe dictionary maps a MIME type (in all lowercase, e.g. 'text/plain')\nto a list of dictionaries corresponding to mailcap entries.  The list\ncollects all the entries for that MIME type from all available mailcap\nfiles.  Each dictionary contains key-value pairs for that MIME type,\nwhere the viewing command is stored with the key \"view\".", 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "listmailcapfiles", 
  "doc": "Return a list of all mailcap files found on the system.", 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lookup", 
  "doc": null, 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "parsefield", 
  "doc": "Separate one key-value pair in a mailcap entry.", 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parseline", 
  "doc": "Parse one entry in a mailcap file and return a dictionary.\n\nThe viewing command is stored as the value with the key \"view\",\nand the rest of the fields produce key-value pairs in the dict.", 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "readmailcapfile", 
  "doc": "Read a mailcap file and return a dictionary keyed by MIME type.\n\nEach MIME type is mapped to an entry consisting of a list of\ndictionaries; the list will contain more than one such dictionary\nif a given MIME type appears more than once in the mailcap file.\nEach dictionary contains key-value pairs for that MIME type, where\nthe viewing command is stored with the key \"view\".", 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "show", 
  "doc": null, 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "subst", 
  "doc": null, 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "mailcap", 
  "file": "/usr/lib/python3.2/mailcap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "MimeTypes", 
  "doc": "MIME-types datastore.\n\nThis datastore can handle information from mime.types-style files\nand supports basic determination of MIME type from a filename or\nURL, and can guess a reasonable extension given a MIME type.", 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_default_mime_types", 
  "doc": null, 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "add_type", 
  "doc": "Add a mapping between a type and an extension.\n\nWhen the extension is already known, the new\ntype will replace the old one. When the type\nis already known the extension will be added\nto the list of known extensions.\n\nIf strict is true, information will be added to\nlist of standard types, else to the list of non-standard\ntypes.", 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "guess_all_extensions", 
  "doc": "Guess the extensions for a file based on its MIME type.\n\nReturn value is a list of strings giving the possible filename\nextensions, including the leading dot ('.').  The extension is not\nguaranteed to have been associated with any particular data\nstream, but would be mapped to the MIME type `type' by\nguess_type().  If no extension can be guessed for `type', None\nis returned.\n\nOptional `strict' argument when false adds a bunch of commonly found,\nbut non-standard types.", 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "guess_extension", 
  "doc": "Guess the extension for a file based on its MIME type.\n\nReturn value is a string giving a filename extension, including the\nleading dot ('.').  The extension is not guaranteed to have been\nassociated with any particular data stream, but would be mapped to the\nMIME type `type' by guess_type().  If no extension can be guessed for\n`type', None is returned.\n\nOptional `strict' argument when false adds a bunch of commonly found,\nbut non-standard types.", 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "guess_type", 
  "doc": "Guess the type of a file based on its URL.\n\nReturn value is a tuple (type, encoding) where type is None if the\ntype can't be guessed (no or unknown suffix) or a string of the\nform type/subtype, usable for a MIME Content-type header; and\nencoding is None for no encoding or the name of the program used\nto encode (e.g. compress or gzip).  The mappings are table\ndriven.  Encoding suffixes are case sensitive; type suffixes are\nfirst tried case sensitive, then case insensitive.\n\nThe suffixes .tgz, .taz and .tz (case sensitive!) are all mapped\nto \".tar.gz\".  (This is table-driven too, using the dictionary\nsuffix_map).\n\nOptional `strict' argument when false adds a bunch of commonly found, but\nnon-standard types.", 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "init", 
  "doc": null, 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Common operations on Posix pathnames.\n\nInstead of importing this module directly, import os and refer to\nthis module as os.path.  The \"os.path\" name is an alias for this\nmodule on Posix systems; on other systems (e.g. Mac, Windows),\nos.path provides the same operations in a manner specific to that\nplatform, and is an alias to another module (e.g. macpath, ntpath).\n\nSome of this can actually be useful on non-Posix systems too, e.g.\nfor manipulation of the pathname component of URLs.", 
  "line": 0, 
  "type": "module", 
  "name": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py"
 }, 
 {
  "name": "read_mime_types", 
  "doc": null, 
  "module": "mimetypes", 
  "file": "/usr/lib/python3.2/mimetypes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "urllib", 
  "file": "/usr/lib/python3.2/urllib/__init__.py"
 }, 
 {
  "name": "AddPackagePath", 
  "doc": null, 
  "module": "modulefinder", 
  "file": "/usr/lib/python3.2/modulefinder.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Module", 
  "doc": null, 
  "module": "modulefinder", 
  "file": "/usr/lib/python3.2/modulefinder.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ModuleFinder", 
  "doc": null, 
  "module": "modulefinder", 
  "file": "/usr/lib/python3.2/modulefinder.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ReplacePackage", 
  "doc": null, 
  "module": "modulefinder", 
  "file": "/usr/lib/python3.2/modulefinder.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Disassembler of Python byte code into mnemonics.", 
  "line": 0, 
  "type": "module", 
  "name": "dis", 
  "file": "/usr/lib/python3.2/dis.py"
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "doc": "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating point numbers.\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- write value to a string\nloads() -- read value from a string", 
  "line": 0, 
  "type": "module", 
  "name": "marshal", 
  "file": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "modulefinder", 
  "file": "/usr/lib/python3.2/modulefinder.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Define names for built-in types that aren't directly accessible as a builtin.", 
  "line": 0, 
  "type": "module", 
  "name": "types", 
  "file": "/usr/lib/python3.2/types.py"
 }, 
 {
  "name": "Array", 
  "doc": "Returns a synchronized shared array", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "AuthenticationError", 
  "doc": null, 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BoundedSemaphore", 
  "doc": "Returns a bounded semaphore object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BufferTooShort", 
  "doc": null, 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Condition", 
  "doc": "Returns a condition object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Event", 
  "doc": "Returns an event object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "JoinableQueue", 
  "doc": "Returns a queue object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Lock", 
  "doc": "Returns a non-recursive lock object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Manager", 
  "doc": "Returns a manager associated with a running server process\n\nThe managers methods such as `Lock()`, `Condition()` and `Queue()`\ncan be used to create shared objects.", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Pipe", 
  "doc": "Returns two connection object connected by a pipe", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Pool", 
  "doc": "Returns a process pool object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Process", 
  "doc": "Process objects represent activity that is run in a separate process\n\nThe class is analagous to `threading.Thread`", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/process.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ProcessError", 
  "doc": null, 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Queue", 
  "doc": "Returns a queue object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RLock", 
  "doc": "Returns a recursive lock object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RawArray", 
  "doc": "Returns a shared array", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RawValue", 
  "doc": "Returns a shared object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Semaphore", 
  "doc": "Returns a semaphore object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "TimeoutError", 
  "doc": null, 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Value", 
  "doc": "Returns a synchronized shared object", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_multiprocessing", 
  "file": "/usr/lib/python3.2/lib-dynload/_multiprocessing.cpython-32mu.so"
 }, 
 {
  "name": "active_children", 
  "doc": "Return list of process objects corresponding to live child processes", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/process.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "allow_connection_pickling", 
  "doc": "Install support for sending connections and sockets between processes", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cpu_count", 
  "doc": "Returns the number of CPUs in the system", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "current_process", 
  "doc": "Return process object representing the current process", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/process.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "freeze_support", 
  "doc": "Check whether this is a fake forked process in a frozen executable.\nIf so then run code specified by commandline and exit.", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_logger", 
  "doc": "Return package logger -- if it does not already exist then it is created", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "log_to_stderr", 
  "doc": "Turn on logging and add a handler which prints to stderr", 
  "module": "multiprocessing", 
  "file": "/usr/lib/python3.2/multiprocessing/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "process", 
  "file": "/usr/lib/python3.2/multiprocessing/process.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "util", 
  "file": "/usr/lib/python3.2/multiprocessing/util.py"
 }, 
 {
  "name": "NetrcParseError", 
  "doc": "Exception raised on syntax errors in the .netrc file.", 
  "module": "netrc", 
  "file": "/usr/lib/python3.2/netrc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "netrc", 
  "doc": null, 
  "module": "netrc", 
  "file": "/usr/lib/python3.2/netrc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "A lexical analyzer class for simple shell-like syntaxes.", 
  "line": 0, 
  "type": "module", 
  "name": "shlex", 
  "file": "/usr/lib/python3.2/shlex.py"
 }, 
 {
  "name": "ArticleInfo", 
  "doc": "ArticleInfo(number, message_id, lines)", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "GroupInfo", 
  "doc": "GroupInfo(group, last, first, flag)", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTP", 
  "doc": null, 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTPDataError", 
  "doc": "Error in response data", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTPError", 
  "doc": "Base class for all nntplib exceptions", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTPPermanentError", 
  "doc": "5xx errors", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTPProtocolError", 
  "doc": "Response does not begin with [1-5]", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTPReplyError", 
  "doc": "Unexpected [123]xx reply", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTPTemporaryError", 
  "doc": "4xx errors", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NNTP_SSL", 
  "doc": null, 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_NNTPBase", 
  "doc": null, 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_email_decode_header", 
  "doc": "Decode a message header value without converting charset.\n\nReturns a list of (string, charset) pairs containing each of the decoded\nparts of the header.  Charset is None for non-encoded parts of the header,\notherwise a lower-case string containing the name of the character set\nspecified in the encoded string.\n\nheader may be a string that may or may not contain RFC2047 encoded words,\nor it may be a Header object.\n\nAn email.errors.HeaderParseError may be raised when certain decoding error\noccurs (e.g. a base64 decoding exception).", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/email/header.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_encrypt_on", 
  "doc": "Wrap a socket in SSL/TLS. Arguments:\n- sock: Socket to wrap\n- context: SSL context to use for the encrypted connection\nReturns:\n- sock: New, encrypted socket.", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_datetime", 
  "doc": "Parse a pair of (date, time) strings, and return a datetime object.\nIf only the date is given, it is assumed to be date and time\nconcatenated together (e.g. response to the DATE command).", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_overview", 
  "doc": "Parse the response to a OVER or XOVER command according to the\noverview format `fmt`.", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_overview_fmt", 
  "doc": "Parse a list of string representing the response to LIST OVERVIEW.FMT\nand return a list of header/metadata names.\nRaises NNTPDataError if the response is not compliant\n(cf. RFC 3977, section 8.4).", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unparse_datetime", 
  "doc": "Format a date or datetime object as a pair of (date, time) strings\nin the format required by the NEWNEWS and NEWGROUPS commands.  If a\ndate object is passed, the time is assumed to be midnight (00h00).\n\nThe returned representation depends on the legacy flag:\n* if legacy is False (the default):\n  date has the YYYYMMDD format and time the HHMMSS format\n* if legacy is True:\n  date has the YYMMDD format and time the HHMMSS format.\nRFC 3977 compliant servers should understand both formats; therefore,\nlegacy is only needed when talking to old servers.", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "doc": "Fast implementation of the datetime type.", 
  "line": 0, 
  "type": "module", 
  "name": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py"
 }, 
 {
  "name": "decode_header", 
  "doc": "Takes an unicode string representing a munged header value\nand decodes it as a (possibly non-ASCII) readable value.", 
  "module": "nntplib", 
  "file": "/usr/lib/python3.2/nntplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides some more Pythonic support for SSL.\n\nObject types:\n\n  SSLSocket -- subtype of socket.socket which does SSL over the socket\n\nExceptions:\n\n  SSLError -- exception raised for I/O errors\n\nFunctions:\n\n  cert_time_to_seconds -- convert time string used for certificate\n                          notBefore and notAfter functions to integer\n                          seconds past the Epoch (the time values\n                          returned from time.time())\n\n  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided\n                          by the server running on HOST at port PORT.  No\n                          validation of the certificate is performed.\n\nInteger constants:\n\nSSL_ERROR_ZERO_RETURN\nSSL_ERROR_WANT_READ\nSSL_ERROR_WANT_WRITE\nSSL_ERROR_WANT_X509_LOOKUP\nSSL_ERROR_SYSCALL\nSSL_ERROR_SSL\nSSL_ERROR_WANT_CONNECT\n\nSSL_ERROR_EOF\nSSL_ERROR_INVALID_ERROR_CODE\n\nThe following group define certificate requirements that one side is\nallowing/requiring from the other side:\n\nCERT_NONE - no certificates from the other side are required (or will\n            be looked at if provided)\nCERT_OPTIONAL - certificates are not required, but if provided will be\n                validated, and if validation fails, the connection will\n                also fail\nCERT_REQUIRED - certificates are required, and will be validated, and\n                if validation fails, the connection will also fail\n\nThe following constants identify various SSL protocol variants:\n\nPROTOCOL_SSLv2\nPROTOCOL_SSLv3\nPROTOCOL_SSLv23\nPROTOCOL_TLSv1", 
  "line": 0, 
  "type": "module", 
  "name": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py"
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "_get_altsep", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_bothseps", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_colon", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_dot", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_empty", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_sep", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_special", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getfileinformation", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getfinalpathname", 
  "doc": null, 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abspath", 
  "doc": "Return the absolute version of a path.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "basename", 
  "doc": "Returns the final component of a pathname", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "commonprefix", 
  "doc": "Given a list of pathnames, returns the longest common leading component", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dirname", 
  "doc": "Returns the directory component of a pathname", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exists", 
  "doc": "Test whether a path exists.  Returns False for broken symbolic links", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expanduser", 
  "doc": "Expand ~ and ~user constructs.\n\nIf user or $HOME is unknown, do nothing.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandvars", 
  "doc": "Expand shell variables of the forms $var, ${var} and %var%.\n\nUnknown variables are left unchanged.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Path operations common to more than one OS\nDo not use directly.  The OS specific modules import the appropriate\nfunctions from this module themselves.", 
  "line": 0, 
  "type": "module", 
  "name": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py"
 }, 
 {
  "name": "getatime", 
  "doc": "Return the last access time of a file, reported by os.stat().", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getctime", 
  "doc": "Return the metadata change time of a file, reported by os.stat().", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmtime", 
  "doc": "Return the last modification time of a file, reported by os.stat().", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsize", 
  "doc": "Return the size of a file, reported by os.stat().", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isabs", 
  "doc": "Test whether a path is absolute", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdir", 
  "doc": "Return true if the pathname refers to an existing directory.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfile", 
  "doc": "Test whether a path is a regular file", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islink", 
  "doc": "Test whether a path is a symbolic link.\nThis will always return false for Windows prior to 6.0\nand for OS/2.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismount", 
  "doc": "Test whether a path is a mount point (defined as root of drive)", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "Join two or more pathname components, inserting \"\\\" as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lexists", 
  "doc": "Test whether a path exists.  Returns True for broken symbolic links", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normcase", 
  "doc": "Normalize case of pathname.\n\nMakes all characters lowercase and all slashes into backslashes.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normpath", 
  "doc": "Normalize path, eliminating double slashes, etc.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "realpath", 
  "doc": "Return the absolute version of a path.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "relpath", 
  "doc": "Return a relative version of a path", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "samefile", 
  "doc": "Test whether two pathnames reference the same actual file", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sameopenfile", 
  "doc": "Test whether two file objects reference the same file", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "Split a pathname.\n\nReturn tuple (head, tail) where tail is everything after the final slash.\nEither part may be empty.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitdrive", 
  "doc": "Split a pathname into drive/UNC sharepoint and relative path specifiers.\nReturns a 2-tuple (drive_or_unc, path); either part may be empty.\n\nIf you assign\n    result = splitdrive(p)\nIt is always true that:\n    result[0] + result[1] == p\n\nIf the path contained a drive letter, drive_or_unc will contain everything\nup to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\nIf the path contained a UNC path, the drive_or_unc will contain the host name\nand share up to but not including the fourth directory separator character.\ne.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\nPaths cannot contain both a drive letter and a UNC path.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitext", 
  "doc": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitunc", 
  "doc": "Deprecated since Python 3.1.  Please use splitdrive() instead;\nit now handles UNC paths.\n\nSplit a pathname into UNC mount point and relative path specifiers.\n\nReturn a 2-tuple (unc, rest); either part may be empty.\nIf unc is not empty, it has the form '//host/mount' (or similar\nusing backslashes).  unc+rest is always the input path.\nPaths containing drive letters never have an UNC part.", 
  "module": "ntpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "pathname2url", 
  "doc": "OS-specific conversion from a file system path to a relative URL\nof the 'file' scheme; not recommended for general use.", 
  "module": "nturl2path", 
  "file": "/usr/lib/python3.2/nturl2path.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "url2pathname", 
  "doc": "OS-specific conversion from a relative URL of the 'file' scheme\nto a file system path; not recommended for general use.", 
  "module": "nturl2path", 
  "file": "/usr/lib/python3.2/nturl2path.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ABCMeta", 
  "doc": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Complex", 
  "doc": "Complex defines the operations that work on the builtin complex type.\n\nIn short, those are: a conversion to complex, .real, .imag, +, -,\n*, /, abs(), .conjugate, ==, and !=.\n\nIf it is given heterogenous arguments, and doesn't have special\nknowledge about them, it should fall back to the builtin complex\ntype as described below.", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/numbers.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Integral", 
  "doc": "Integral adds a conversion to int and the bit-string operations.", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/numbers.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Number", 
  "doc": "All numbers inherit from this class.\n\nIf you just want to check if an argument x is a number, without\ncaring what kind, use isinstance(x, Number).", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/numbers.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Rational", 
  "doc": ".numerator and .denominator should be in lowest terms.", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/numbers.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Real", 
  "doc": "To Complex, Real adds the operations that work on real numbers.\n\nIn short, those are: a conversion to float, trunc(), divmod,\n%, <, <=, >, and >=.\n\nReal also provides defaults for the derived operations.", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/numbers.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "abstractmethod", 
  "doc": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abstractproperty", 
  "doc": "A decorator indicating abstract properties.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract properties are overridden.\nThe abstract properties can be called using any of the normal\n'super' call mechanisms.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractproperty\n        def my_abstract_property(self):\n            ...\n\nThis defines a read-only property; you can also define a read-write\nabstract property using the 'long' form of property declaration:\n\n    class C(metaclass=ABCMeta):\n        def getx(self): ...\n        def setx(self, value): ...\n        x = abstractproperty(getx, setx)", 
  "module": "numbers", 
  "file": "/usr/lib/python3.2/abc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "AmbiguousOptionError", 
  "doc": "Raised if an ambiguous option is seen on the command line.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BadOptionError", 
  "doc": "Raised if an invalid option is seen on the command line.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HelpFormatter", 
  "doc": "Abstract base class for formatting option help.  OptionParser\ninstances should use one of the HelpFormatter subclasses for\nformatting help; by default IndentedHelpFormatter is used.\n\nInstance attributes:\n  parser : OptionParser\n    the controlling OptionParser instance\n  indent_increment : int\n    the number of columns to indent per nesting level\n  max_help_position : int\n    the maximum starting column for option help text\n  help_position : int\n    the calculated starting column for option help text;\n    initially the same as the maximum\n  width : int\n    total number of columns for output (pass None to constructor for\n    this value to be taken from the $COLUMNS environment variable)\n  level : int\n    current indentation level\n  current_indent : int\n    current indentation level (in columns)\n  help_width : int\n    number of columns available for option help text (calculated)\n  default_tag : str\n    text to replace with each option's default value, \"%default\"\n    by default.  Set to false value to disable default value expansion.\n  option_strings : { Option : str }\n    maps Option instances to the snippet of help text explaining\n    the syntax of that option, e.g. \"-h, --help\" or\n    \"-fFILE, --file=FILE\"\n  _short_opt_fmt : str\n    format string controlling how short options with values are\n    printed in help text.  Must be either \"%s%s\" (\"-fFILE\") or\n    \"%s %s\" (\"-f FILE\"), because those are the two syntaxes that\n    Optik supports.\n  _long_opt_fmt : str\n    similar but for long options; must be either \"%s %s\" (\"--file FILE\")\n    or \"%s=%s\" (\"--file=FILE\").", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IndentedHelpFormatter", 
  "doc": "Format help with indented section bodies.\n    ", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptParseError", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Option", 
  "doc": "Instance attributes:\n  _short_opts : [string]\n  _long_opts : [string]\n\n  action : string\n  type : string\n  dest : string\n  default : any\n  nargs : int\n  const : any\n  choices : [string]\n  callback : function\n  callback_args : (any*)\n  callback_kwargs : { string : any }\n  help : string\n  metavar : string", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptionConflictError", 
  "doc": "Raised if conflicting options are added to an OptionParser.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptionContainer", 
  "doc": "Abstract base class.\n\nClass attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  option_list : [Option]\n    the list of Option objects contained by this OptionContainer\n  _short_opt : { string : Option }\n    dictionary mapping short option strings, eg. \"-f\" or \"-X\",\n    to the Option instances that implement them.  If an Option\n    has multiple short option strings, it will appears in this\n    dictionary multiple times. [1]\n  _long_opt : { string : Option }\n    dictionary mapping long option strings, eg. \"--file\" or\n    \"--exclude\", to the Option instances that implement them.\n    Again, a given Option can occur multiple times in this\n    dictionary. [1]\n  defaults : { string : any }\n    dictionary mapping option destination names to default\n    values for each destination [1]\n\n[1] These mappings are common to (shared by) all components of the\n    controlling OptionParser, where they are initially created.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptionError", 
  "doc": "Raised if an Option instance is created with invalid or\ninconsistent arguments.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptionGroup", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptionParser", 
  "doc": "Class attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  usage : string\n    a usage string for your program.  Before it is displayed\n    to the user, \"%prog\" will be expanded to the name of\n    your program (self.prog or os.path.basename(sys.argv[0])).\n  prog : string\n    the name of the current program (to override\n    os.path.basename(sys.argv[0])).\n  description : string\n    A paragraph of text giving a brief overview of your program.\n    optparse reformats this paragraph to fit the current terminal\n    width and prints it when the user requests help (after usage,\n    but before the list of options).\n  epilog : string\n    paragraph of help text to print after option help\n\n  option_groups : [OptionGroup]\n    list of option groups in this parser (option groups are\n    irrelevant for parsing the command-line, but very useful\n    for generating help)\n\n  allow_interspersed_args : bool = true\n    if true, positional arguments may be interspersed with options.\n    Assuming -a and -b each take a single argument, the command-line\n      -ablah foo bar -bboo baz\n    will be interpreted the same as\n      -ablah -bboo -- foo bar baz\n    If this flag were false, that command line would be interpreted as\n      -ablah -- foo bar -bboo baz\n    -- ie. we stop processing options as soon as we see the first\n    non-option argument.  (This is the tradition followed by\n    Python's getopt module, Perl's Getopt::Std, and other argument-\n    parsing libraries, but it is generally annoying to users.)\n\n  process_default_values : bool = true\n    if true, option default values are processed similarly to option\n    values from the command line: that is, they are passed to the\n    type-checking function for the option's type (as long as the\n    default value is a string).  (This really only matters if you\n    have defined custom types; see SF bug #955889.)  Set it to false\n    to restore the behaviour of Optik 1.4.1 and earlier.\n\n  rargs : [string]\n    the argument list currently being parsed.  Only set when\n    parse_args() is active, and continually trimmed down as\n    we consume arguments.  Mainly there for the benefit of\n    callback options.\n  largs : [string]\n    the list of leftover arguments that we have skipped while\n    parsing options.  If allow_interspersed_args is false, this\n    list is always empty.\n  values : Values\n    the set of option values currently being accumulated.  Only\n    set when parse_args() is active.  Also mainly for callbacks.\n\nBecause of the 'rargs', 'largs', and 'values' attributes,\nOptionParser is not thread-safe.  If, for some perverse reason, you\nneed to parse command-line arguments simultaneously in different\nthreads, use different OptionParser instances.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptionValueError", 
  "doc": "Raised if an invalid option value is encountered on the command\nline.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TitledHelpFormatter", 
  "doc": "Format help with underlined section headers.\n    ", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Values", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_match_abbrev", 
  "doc": "_match_abbrev(s : string, wordmap : {string : Option}) -> string\n\nReturn the string key in 'wordmap' for which 's' is an unambiguous\nabbreviation.  If 's' is found to be ambiguous or doesn't match any of\n'words', raise BadOptionError.", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_int", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_long", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_num", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_repr", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "check_builtin", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "check_choice", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gettext", 
  "doc": null, 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/gettext.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "make_option", 
  "doc": "Instance attributes:\n  _short_opts : [string]\n  _long_opts : [string]\n\n  action : string\n  type : string\n  dest : string\n  default : any\n  nargs : int\n  const : any\n  choices : [string]\n  callback : function\n  callback_args : (any*)\n  callback_kwargs : { string : any }\n  help : string\n  metavar : string", 
  "module": "optparse", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Text wrapping and filling.", 
  "line": 0, 
  "type": "module", 
  "name": "textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py"
 }, 
 {
  "name": "MutableMapping", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "WCOREDUMP", 
  "doc": "WCOREDUMP(status) -> bool\n\nReturn True if the process returning 'status' was dumped to a core file.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WEXITSTATUS", 
  "doc": "WEXITSTATUS(status) -> integer\n\nReturn the process return code from 'status'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WIFCONTINUED", 
  "doc": "WIFCONTINUED(status) -> bool\n\nReturn True if the process returning 'status' was continued from a\njob control stop.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WIFEXITED", 
  "doc": "WIFEXITED(status) -> bool\n\nReturn true if the process returning 'status' exited using the exit()\nsystem call.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WIFSIGNALED", 
  "doc": "WIFSIGNALED(status) -> bool\n\nReturn True if the process returning 'status' was terminated by a signal.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WIFSTOPPED", 
  "doc": "WIFSTOPPED(status) -> bool\n\nReturn True if the process returning 'status' was stopped.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WSTOPSIG", 
  "doc": "WSTOPSIG(status) -> integer\n\nReturn the signal that stopped the process that provided\nthe 'status' value.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WTERMSIG", 
  "doc": "WTERMSIG(status) -> integer\n\nReturn the signal that terminated the process that provided the 'status'\nvalue.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_Environ", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Helper to provide extensibility for pickle.\n\nThis is only useful to add pickle support for extension types defined in\nC, not for instances of user-defined classes.", 
  "line": 0, 
  "type": "module", 
  "name": "_copyreg", 
  "file": "/usr/lib/python3.2/copyreg.py"
 }, 
 {
  "name": "_execvpe", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_exists", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_exit", 
  "doc": "_exit(status)\n\nExit to the system with specified status, without normal exit processing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_exports_list", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_masked_mode", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_make_stat_result", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_make_statvfs_result", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_pickle_stat_result", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_pickle_statvfs_result", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_putenv", 
  "doc": "putenv(key, value)\n\nChange or add an environment variable.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_spawnvef", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unsetenv", 
  "doc": "unsetenv(key)\n\nDelete an environment variable.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_wrap_close", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "abort", 
  "doc": "abort() -> does not return!\n\nAbort the interpreter immediately.  This 'dumps core' or otherwise fails\nin the hardest way possible on the hosting operating system.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "access", 
  "doc": "access(path, mode) -> True if granted, False otherwise\n\nUse the real uid/gid to test for access to a path.  Note that most\noperations will use the effective uid/gid, therefore this routine can\nbe used in a suid/sgid environment to test if the invoking user has the\nspecified access to the path.  The mode argument can be F_OK to test\nexistence, or the inclusive-OR of R_OK, W_OK, and X_OK.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "chdir", 
  "doc": "chdir(path)\n\nChange the current working directory to the specified path.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "chmod", 
  "doc": "chmod(path, mode)\n\nChange the access permissions of a file.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "chown", 
  "doc": "chown(path, uid, gid)\n\nChange the owner and group id of path to the numeric uid and gid.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "chroot", 
  "doc": "chroot(path)\n\nChange root directory to path.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "close", 
  "doc": "close(fd)\n\nClose a file descriptor (for low level IO).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "closerange", 
  "doc": "closerange(fd_low, fd_high)\n\nCloses all file descriptors in [fd_low, fd_high), ignoring errors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "confstr", 
  "doc": "confstr(name) -> string\n\nReturn a string-valued system configuration variable.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ctermid", 
  "doc": "ctermid() -> string\n\nReturn the name of the controlling terminal for this process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "device_encoding", 
  "doc": "device_encoding(fd) -> str\n\nReturn a string describing the encoding of the device\nif the output is a terminal; else return None.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dup", 
  "doc": "dup(fd) -> fd2\n\nReturn a duplicate of a file descriptor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dup2", 
  "doc": "dup2(old_fd, new_fd)\n\nDuplicate file descriptor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "name": "error", 
  "doc": "OS system call failed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "execl", 
  "doc": "execl(file, *args)\n\nExecute the executable file with argument list args, replacing the\ncurrent process. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execle", 
  "doc": "execle(file, *args, env)\n\nExecute the executable file with argument list args and\nenvironment env, replacing the current process. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execlp", 
  "doc": "execlp(file, *args)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args, replacing the current process. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execlpe", 
  "doc": "execlpe(file, *args, env)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args and environment env, replacing the current\nprocess. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execv", 
  "doc": "execv(path, args)\n\nExecute an executable path with arguments, replacing current process.\n\n    path: path of executable file\n    args: tuple or list of strings", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execve", 
  "doc": "execve(path, args, env)\n\nExecute a path with arguments and environment, replacing current process.\n\n    path: path of executable file\n    args: tuple or list of arguments\n    env: dictionary of strings mapping to strings", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execvp", 
  "doc": "execvp(file, args)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args, replacing the current process.\nargs may be a list or tuple of strings. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execvpe", 
  "doc": "execvpe(file, args, env)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args and environment env , replacing the\ncurrent process.\nargs may be a list or tuple of strings. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fchdir", 
  "doc": "fchdir(fildes)\n\nChange to the directory of the given file descriptor.  fildes must be\nopened on a directory, not a file.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fchmod", 
  "doc": "fchmod(fd, mode)\n\nChange the access permissions of the file given by file\ndescriptor fd.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fchown", 
  "doc": "fchown(fd, uid, gid)\n\nChange the owner and group id of the file given by file descriptor\nfd to the numeric uid and gid.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fdatasync", 
  "doc": "fdatasync(fildes)\n\nforce write of file with filedescriptor to disk.\n does not force update of metadata.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fdopen", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fork", 
  "doc": "fork() -> pid\n\nFork a child process.\nReturn 0 to child process and PID of child to parent process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "forkpty", 
  "doc": "forkpty() -> (pid, master_fd)\n\nFork a new process with a new pseudo-terminal as controlling tty.\n\nLike fork(), return 0 as pid to child process, and PID of child to parent.\nTo both, return fd of newly opened pseudo-terminal.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fpathconf", 
  "doc": "fpathconf(fd, name) -> integer\n\nReturn the configuration limit name for the file descriptor fd.\nIf there is no limit, return -1.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fsdecode", 
  "doc": "Decode filename from the filesystem encoding with 'surrogateescape' error\nhandler, return str unchanged. On Windows, use 'strict' error handler if\nthe file system encoding is 'mbcs' (which is the default encoding).", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fsencode", 
  "doc": "Encode filename to the filesystem encoding with 'surrogateescape' error\nhandler, return bytes unchanged. On Windows, use 'strict' error handler if\nthe file system encoding is 'mbcs' (which is the default encoding).", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fstat", 
  "doc": "fstat(fd) -> stat result\n\nLike stat(), but for an open file descriptor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fstatvfs", 
  "doc": "fstatvfs(fd) -> statvfs result\n\nPerform an fstatvfs system call on the given fd.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fsync", 
  "doc": "fsync(fildes)\n\nforce write of file with filedescriptor to disk.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ftruncate", 
  "doc": "ftruncate(fd, length)\n\nTruncate a file to a specified length.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_exec_path", 
  "doc": "Returns the sequence of directories that will be searched for the\nnamed executable (similar to a shell) when launching a process.\n\n*env* must be an environment variable dict or None.  If *env* is None,\nos.environ will be used.", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcwd", 
  "doc": "getcwd() -> path\n\nReturn a unicode string representing the current working directory.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcwdb", 
  "doc": "getcwdb() -> path\n\nReturn a bytes string representing the current working directory.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getegid", 
  "doc": "getegid() -> egid\n\nReturn the current process's effective group id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getenv", 
  "doc": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are str.", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getenvb", 
  "doc": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are bytes.", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "geteuid", 
  "doc": "geteuid() -> euid\n\nReturn the current process's effective user id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getgid", 
  "doc": "getgid() -> gid\n\nReturn the current process's group id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getgroups", 
  "doc": "getgroups() -> list of group IDs\n\nReturn list of supplemental group IDs for the process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getloadavg", 
  "doc": "getloadavg() -> (float, float, float)\n\nReturn the number of processes in the system run queue averaged over\nthe last 1, 5, and 15 minutes or raises OSError if the load average\nwas unobtainable", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getlogin", 
  "doc": "getlogin() -> string\n\nReturn the actual login name.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpgid", 
  "doc": "getpgid(pid) -> pgid\n\nCall the system call getpgid().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpgrp", 
  "doc": "getpgrp() -> pgrp\n\nReturn the current process group id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpid", 
  "doc": "getpid() -> pid\n\nReturn the current process id", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getppid", 
  "doc": "getppid() -> ppid\n\nReturn the parent's process id.  If the parent process has already exited,\nWindows machines will still return its id; others systems will return the id\nof the 'init' process (1).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getresgid", 
  "doc": "getresgid() -> (rgid, egid, sgid)\n\nGet tuple of the current process's real, effective, and saved group ids.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getresuid", 
  "doc": "getresuid() -> (ruid, euid, suid)\n\nGet tuple of the current process's real, effective, and saved user ids.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsid", 
  "doc": "getsid(pid) -> sid\n\nCall the system call getsid().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getuid", 
  "doc": "getuid() -> uid\n\nReturn the current process's user id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "initgroups", 
  "doc": "initgroups(username, gid) -> None\n\nCall the system initgroups() to initialize the group access list with all of\nthe groups of which the specified username is a member, plus the specified\ngroup id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isatty", 
  "doc": "isatty(fd) -> bool\n\nReturn True if the file descriptor 'fd' is an open file descriptor\nconnected to the slave end of a terminal.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "kill", 
  "doc": "kill(pid, sig)\n\nKill a process with a signal.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "killpg", 
  "doc": "killpg(pgid, sig)\n\nKill a process group with a signal.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lchown", 
  "doc": "lchown(path, uid, gid)\n\nChange the owner and group id of path to the numeric uid and gid.\nThis function will not follow symbolic links.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "link", 
  "doc": "link(src, dst)\n\nCreate a hard link to a file.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "listdir", 
  "doc": "listdir([path]) -> list_of_strings\n\nReturn a list containing the names of the entries in the directory.\n\n    path: path of directory to list (default: '.')\n\nThe list is in arbitrary order.  It does not include the special\nentries '.' and '..' even if they are present in the directory.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lseek", 
  "doc": "lseek(fd, pos, how) -> newpos\n\nSet the current position of a file descriptor.\nReturn the new cursor position in bytes, starting from the beginning.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstat", 
  "doc": "lstat(path) -> stat result\n\nLike stat(path), but do not follow symbolic links.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "major", 
  "doc": "major(device) -> major number\nExtracts a device major number from a raw device number.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "makedev", 
  "doc": "makedev(major, minor) -> device number\nComposes a raw device number from the major and minor device numbers.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "makedirs", 
  "doc": "makedirs(path [, mode=0o777][, exist_ok=False])\n\nSuper-mkdir; create a leaf directory and all intermediate ones.\nWorks like mkdir, except that any intermediate path segment (not\njust the rightmost) will be created if it does not exist. If the\ntarget directory with the same mode as we specified already exists,\nraises an OSError if exist_ok is False, otherwise no exception is\nraised.  This is recursive.", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "minor", 
  "doc": "minor(device) -> minor number\nExtracts a device minor number from a raw device number.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mkdir", 
  "doc": "mkdir(path [, mode=0777])\n\nCreate a directory.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mkfifo", 
  "doc": "mkfifo(filename [, mode=0666])\n\nCreate a FIFO (a POSIX named pipe).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mknod", 
  "doc": "mknod(filename [, mode=0600, device])\n\nCreate a filesystem node (file, device special file or named pipe)\nnamed filename. mode specifies both the permissions to use and the\ntype of node to be created, being combined (bitwise OR) with one of\nS_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO. For S_IFCHR and S_IFBLK,\ndevice defines the newly created device special file (probably using\nos.makedev()), otherwise it is ignored.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nice", 
  "doc": "nice(inc) -> new_priority\n\nDecrease the priority of process by inc and return the new priority.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": "open(filename, flag [, mode=0777]) -> fd\n\nOpen a file (for low level IO).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "openpty", 
  "doc": "openpty() -> (master_fd, slave_fd)\n\nOpen a pseudo-terminal, returning open fd's for both master and slave end.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Common operations on Posix pathnames.\n\nInstead of importing this module directly, import os and refer to\nthis module as os.path.  The \"os.path\" name is an alias for this\nmodule on Posix systems; on other systems (e.g. Mac, Windows),\nos.path provides the same operations in a manner specific to that\nplatform, and is an alias to another module (e.g. macpath, ntpath).\n\nSome of this can actually be useful on non-Posix systems too, e.g.\nfor manipulation of the pathname component of URLs.", 
  "line": 0, 
  "type": "module", 
  "name": "path", 
  "file": "/usr/lib/python3.2/posixpath.py"
 }, 
 {
  "name": "pathconf", 
  "doc": "pathconf(path, name) -> integer\n\nReturn the configuration limit name for the file or directory path.\nIf there is no limit, return -1.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pipe", 
  "doc": "pipe() -> (read_end, write_end)\n\nCreate a pipe.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "popen", 
  "doc": null, 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "putenv", 
  "doc": "putenv(key, value)\n\nChange or add an environment variable.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read", 
  "doc": "read(fd, buffersize) -> string\n\nRead a file descriptor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "readlink", 
  "doc": "readlink(path) -> path\n\nReturn a string representing the path to which the symbolic link points.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "remove", 
  "doc": "remove(path)\n\nRemove a file (same as unlink(path)).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "removedirs", 
  "doc": "removedirs(path)\n\nSuper-rmdir; remove a leaf directory and all empty intermediate\nones.  Works like rmdir except that, if the leaf directory is\nsuccessfully removed, directories corresponding to rightmost path\nsegments will be pruned away until either the whole path is\nconsumed or an error occurs.  Errors during this latter phase are\nignored -- they generally mean that a directory was not empty.", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rename", 
  "doc": "rename(old, new)\n\nRename a file or directory.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "renames", 
  "doc": "renames(old, new)\n\nSuper-rename; create directories as necessary and delete any left\nempty.  Works like rename, except creation of any intermediate\ndirectories needed to make the new pathname good is attempted\nfirst.  After the rename, directories corresponding to rightmost\npath segments of the old name will be pruned way until either the\nwhole path is consumed or a nonempty directory is found.\n\nNote: this function can fail with the new directory structure made\nif you lack permissions needed to unlink the leaf directory or\nfile.", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rmdir", 
  "doc": "rmdir(path)\n\nRemove a directory.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setegid", 
  "doc": "setegid(gid)\n\nSet the current process's effective group id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "seteuid", 
  "doc": "seteuid(uid)\n\nSet the current process's effective user id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setgid", 
  "doc": "setgid(gid)\n\nSet the current process's group id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setgroups", 
  "doc": "setgroups(list)\n\nSet the groups of the current process to list.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setpgid", 
  "doc": "setpgid(pid, pgrp)\n\nCall the system call setpgid().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setpgrp", 
  "doc": "setpgrp()\n\nMake this process the process group leader.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setregid", 
  "doc": "setregid(rgid, egid)\n\nSet the current process's real and effective group ids.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setresgid", 
  "doc": "setresgid(rgid, egid, sgid)\n\nSet the current process's real, effective, and saved group ids.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setresuid", 
  "doc": "setresuid(ruid, euid, suid)\n\nSet the current process's real, effective, and saved user ids.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setreuid", 
  "doc": "setreuid(ruid, euid)\n\nSet the current process's real and effective user ids.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setsid", 
  "doc": "setsid()\n\nCall the system call setsid().", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setuid", 
  "doc": "setuid(uid)\n\nSet the current process's user id.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnl", 
  "doc": "spawnl(mode, file, *args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnle", 
  "doc": "spawnle(mode, file, *args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nsupplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnlp", 
  "doc": "spawnlp(mode, file, *args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnlpe", 
  "doc": "spawnlpe(mode, file, *args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnv", 
  "doc": "spawnv(mode, file, args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnve", 
  "doc": "spawnve(mode, file, args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nspecified environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnvp", 
  "doc": "spawnvp(mode, file, args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawnvpe", 
  "doc": "spawnvpe(mode, file, args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "stat", 
  "doc": "stat(path) -> stat result\n\nPerform a stat system call on the given path.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "stat_float_times", 
  "doc": "stat_float_times([newval]) -> oldval\n\nDetermine whether os.[lf]stat represents time stamps as float objects.\nIf newval is True, future calls to stat() return floats, if it is False,\nfuture calls return ints. \nIf newval is omitted, return the current setting.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "stat_result", 
  "doc": "stat_result: Result from stat or lstat.\n\nThis object may be accessed either as a tuple of\n  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\nor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n\nPosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\nor st_flags, they are available as attributes only.\n\nSee os.stat for more information.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "statvfs", 
  "doc": "statvfs(path) -> statvfs result\n\nPerform a statvfs system call on the given path.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "statvfs_result", 
  "doc": "statvfs_result: Result from statvfs or fstatvfs.\n\nThis object may be accessed either as a tuple of\n  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\nor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n\nSee os.statvfs for more information.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "strerror", 
  "doc": "strerror(code) -> string\n\nTranslate an error code to a message string.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "symlink", 
  "doc": "symlink(src, dst)\n\nCreate a symbolic link pointing to src named dst.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "sysconf", 
  "doc": "sysconf(name) -> integer\n\nReturn an integer-valued system configuration variable.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "system", 
  "doc": "system(command) -> exit_status\n\nExecute the command (a string) in a subshell.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcgetpgrp", 
  "doc": "tcgetpgrp(fd) -> pgid\n\nReturn the process group associated with the terminal given by a fd.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcsetpgrp", 
  "doc": "tcsetpgrp(fd, pgid)\n\nSet the process group associated with the terminal given by a fd.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "times", 
  "doc": "times() -> (utime, stime, cutime, cstime, elapsed_time)\n\nReturn a tuple of floating point numbers indicating process times.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ttyname", 
  "doc": "ttyname(fd) -> string\n\nReturn the name of the terminal device connected to 'fd'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "umask", 
  "doc": "umask(new_mask) -> old_mask\n\nSet the current numeric umask and return the previous umask.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "uname", 
  "doc": "uname() -> (sysname, nodename, release, version, machine)\n\nReturn a tuple identifying the current operating system.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unlink", 
  "doc": "unlink(path)\n\nRemove a file (same as remove(path)).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unsetenv", 
  "doc": "unsetenv(key)\n\nDelete an environment variable.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "urandom", 
  "doc": "urandom(n) -> str\n\nReturn n random bytes suitable for cryptographic use.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "utime", 
  "doc": "utime(path, (atime, mtime))\nutime(path, None)\n\nSet the access and modified time of the file to the given values.  If the\nsecond form is used, set the access and modified times to the current time.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "wait", 
  "doc": "wait() -> (pid, status)\n\nWait for completion of a child process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "wait3", 
  "doc": "wait3(options) -> (pid, status, rusage)\n\nWait for completion of a child process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "wait4", 
  "doc": "wait4(pid, options) -> (pid, status, rusage)\n\nWait for completion of a given child process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "waitpid", 
  "doc": "waitpid(pid, options) -> (pid, status)\n\nWait for completion of a given child process.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "walk", 
  "doc": "Directory tree generator.\n\nFor each directory in the directory tree rooted at top (including top\nitself, but excluding '.' and '..'), yields a 3-tuple\n\n    dirpath, dirnames, filenames\n\ndirpath is a string, the path to the directory.  dirnames is a list of\nthe names of the subdirectories in dirpath (excluding '.' and '..').\nfilenames is a list of the names of the non-directory files in dirpath.\nNote that the names in the lists are just names, with no path components.\nTo get a full path (which begins with top) to a file or directory in\ndirpath, do os.path.join(dirpath, name).\n\nIf optional arg 'topdown' is true or not specified, the triple for a\ndirectory is generated before the triples for any of its subdirectories\n(directories are generated top down).  If topdown is false, the triple\nfor a directory is generated after the triples for all of its\nsubdirectories (directories are generated bottom up).\n\nWhen topdown is true, the caller can modify the dirnames list in-place\n(e.g., via del or slice assignment), and walk will only recurse into the\nsubdirectories whose names remain in dirnames; this can be used to prune\nthe search, or to impose a specific order of visiting.  Modifying\ndirnames when topdown is false is ineffective, since the directories in\ndirnames have already been generated by the time dirnames itself is\ngenerated.\n\nBy default errors from the os.listdir() call are ignored.  If\noptional arg 'onerror' is specified, it should be a function; it\nwill be called with one argument, an os.error instance.  It can\nreport the error to continue with the walk, or raise the exception\nto abort the walk.  Note that the filename is available as the\nfilename attribute of the exception object.\n\nBy default, os.walk does not follow symbolic links to subdirectories on\nsystems that support them.  In order to get this functionality, set the\noptional argument 'followlinks' to true.\n\nCaution:  if you pass a relative pathname for top, don't change the\ncurrent working directory between resumptions of walk.  walk never\nchanges the current directory, and assumes that the client doesn't\neither.\n\nExample:\n\nimport os\nfrom os.path import join, getsize\nfor root, dirs, files in os.walk('python/Lib/email'):\n    print(root, \"consumes\", end=\"\")\n    print(sum([getsize(join(root, name)) for name in files]), end=\"\")\n    print(\"bytes in\", len(files), \"non-directory files\")\n    if 'CVS' in dirs:\n        dirs.remove('CVS')  # don't visit CVS directories", 
  "module": "os", 
  "file": "/usr/lib/python3.2/os.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "write", 
  "doc": "write(fd, string) -> byteswritten\n\nWrite a string to a file descriptor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abspath", 
  "doc": "Return the absolute version of a path", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "basename", 
  "doc": "Returns the final component of a pathname", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "commonprefix", 
  "doc": "Given a list of pathnames, returns the longest common leading component", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dirname", 
  "doc": "Returns the directory component of a pathname", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exists", 
  "doc": "Test whether a path exists.  Returns False for broken symbolic links", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expanduser", 
  "doc": "Expand ~ and ~user constructs.\n\nIf user or $HOME is unknown, do nothing.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandvars", 
  "doc": "Expand shell variables of the forms $var, ${var} and %var%.\n\nUnknown variables are left unchanged.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getatime", 
  "doc": "Return the last access time of a file, reported by os.stat().", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getctime", 
  "doc": "Return the metadata change time of a file, reported by os.stat().", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmtime", 
  "doc": "Return the last modification time of a file, reported by os.stat().", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsize", 
  "doc": "Return the size of a file, reported by os.stat().", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isabs", 
  "doc": "Test whether a path is absolute", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdir", 
  "doc": "Return true if the pathname refers to an existing directory.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfile", 
  "doc": "Test whether a path is a regular file", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islink", 
  "doc": "Test whether a path is a symbolic link.\nThis will always return false for Windows prior to 6.0\nand for OS/2.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismount", 
  "doc": "Test whether a path is a mount point (defined as root of drive)", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "Join two or more pathname components, inserting sep as needed", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lexists", 
  "doc": "Test whether a path exists.  Returns False for broken symbolic links", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normcase", 
  "doc": "Normalize case of pathname.\n\nMakes all characters lowercase and all altseps into seps.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normpath", 
  "doc": "Normalize path, eliminating double slashes, etc.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "realpath", 
  "doc": "Return the absolute version of a path", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "Split a pathname.\n\nReturn tuple (head, tail) where tail is everything after the final slash.\nEither part may be empty.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitdrive", 
  "doc": "Split a pathname into drive/UNC sharepoint and relative path specifiers.\nReturns a 2-tuple (drive_or_unc, path); either part may be empty.\n\nIf you assign\n    result = splitdrive(p)\nIt is always true that:\n    result[0] + result[1] == p\n\nIf the path contained a drive letter, drive_or_unc will contain everything\nup to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\nIf the path contained a UNC path, the drive_or_unc will contain the host name\nand share up to but not including the fourth directory separator character.\ne.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\nPaths cannot contain both a drive letter and a UNC path.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitext", 
  "doc": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/ntpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitunc", 
  "doc": "Split a pathname into UNC mount point and relative path specifiers.\n\nReturn a 2-tuple (unc, rest); either part may be empty.\nIf unc is not empty, it has the form '//host/mount' (or similar\nusing backslashes).  unc+rest is always the input path.\nPaths containing drive letters never have an UNC part.", 
  "module": "os2emxpath", 
  "file": "/usr/lib/python3.2/os2emxpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "name": "Pdb", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Restart", 
  "doc": "Causes a debugger to be restarted for the debugged python program.", 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_rstr", 
  "doc": "String that doesn't quote its repr.", 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Debugger basics", 
  "line": 0, 
  "type": "module", 
  "name": "bdb", 
  "file": "/usr/lib/python3.2/bdb.py"
 }, 
 {
  "doc": "A generic class to build line-oriented command interpreters.\n\nInterpreters constructed with this class obey the following conventions:\n\n1. End of file on input is processed as the command 'EOF'.\n2. A command is parsed out of each line by collecting the prefix composed\n   of characters in the identchars member.\n3. A command `foo' is dispatched to a method 'do_foo()'; the do_ method\n   is passed a single argument consisting of the remainder of the line.\n4. Typing an empty line repeats the last command.  (Actually, it calls the\n   method `emptyline', which may be overridden in a subclass.)\n5. There is a predefined `help' method.  Given an argument `topic', it\n   calls the command `help_topic'.  With no arguments, it lists all topics\n   with defined help_ functions, broken into up to three topics; documented\n   commands, miscellaneous help topics, and undocumented commands.\n6. The command '?' is a synonym for `help'.  The command '!' is a synonym\n   for `shell', if a do_shell method exists.\n7. If completion is enabled, completing commands will be done automatically,\n   and completing of commands args is done by calling complete_foo() with\n   arguments text, line, begidx, endidx.  text is string we are matching\n   against, all returned matches must begin with it.  line is the current\n   input line (lstripped), begidx and endidx are the beginning and end\n   indexes of the text being matched, which could be used to provide\n   different completion depending upon which position the argument is in.\n\nThe `default' method may be overridden to intercept commands for which there\nis no do_ method.\n\nThe `completedefault' method may be overridden to intercept completions for\ncommands that have no complete_ method.\n\nThe data member `self.ruler' sets the character used to draw separator lines\nin the help messages.  If empty, no ruler line is drawn.  It defaults to \"=\".\n\nIf the value of `self.intro' is nonempty when the cmdloop method is called,\nit is printed out on interpreter startup.  This value may be overridden\nvia an optional argument to the cmdloop() method.\n\nThe data members `self.doc_header', `self.misc_header', and\n`self.undoc_header' set the headers used for the help function's\nlistings of documented functions, miscellaneous topics, and undocumented\nfunctions respectively.", 
  "line": 0, 
  "type": "module", 
  "name": "cmd", 
  "file": "/usr/lib/python3.2/cmd.py"
 }, 
 {
  "doc": "Utilities needed to emulate Python's interactive interpreter.", 
  "line": 0, 
  "type": "module", 
  "name": "code", 
  "file": "/usr/lib/python3.2/code.py"
 }, 
 {
  "doc": "Disassembler of Python byte code into mnemonics.", 
  "line": 0, 
  "type": "module", 
  "name": "dis", 
  "file": "/usr/lib/python3.2/dis.py"
 }, 
 {
  "name": "find_function", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsourcelines", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "help", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "name": "lasti2lineno", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "pm", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "post_mortem", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support to pretty-print lists, tuples, & dictionaries recursively.\n\nVery simple, but useful, especially in debugging data structures.\n\nClasses\n-------\n\nPrettyPrinter()\n    Handle pretty-printing operations onto a stream using a configured\n    set of formatting parameters.\n\nFunctions\n---------\n\npformat()\n    Format a Python object into a pretty-printed representation.\n\npprint()\n    Pretty-print a Python object to a stream [default is sys.stdout].\n\nsaferepr()\n    Generate a 'standard' repr()-like value, but protect against recursive\n    data structures.", 
  "line": 0, 
  "type": "module", 
  "name": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "run", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "runcall", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "runctx", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "runeval", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_trace", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides mechanisms to use signal handlers in Python.\n\nFunctions:\n\nalarm() -- cause SIGALRM after a specified time [Unix only]\nsetitimer() -- cause a signal (described below) after a specified\n               float time and the timer may restart then [Unix only]\ngetitimer() -- get current value of timer [Unix only]\nsignal() -- set the action for a given signal\ngetsignal() -- get the signal action for a given signal\npause() -- wait until a signal arrives [Unix only]\ndefault_int_handler() -- default SIGINT handler\n\nsignal constants:\nSIG_DFL -- used to refer to the system default handler\nSIG_IGN -- used to ignore the signal\nNSIG -- number of defined signals\nSIGINT, SIGTERM, etc. -- signal numbers\n\nitimer constants:\nITIMER_REAL -- decrements in real time, and delivers SIGALRM upon\n               expiration\nITIMER_VIRTUAL -- decrements only when the process is executing,\n               and delivers SIGVTALRM upon expiration\nITIMER_PROF -- decrements both when the process is executing and\n               when the system is executing on behalf of the process.\n               Coupled with ITIMER_VIRTUAL, this timer is usually\n               used to profile the time spent by the application\n               in user and kernel space. SIGPROF is delivered upon\n               expiration.\n\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.", 
  "line": 0, 
  "type": "module", 
  "name": "signal", 
  "file": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "pdb", 
  "file": "/usr/lib/python3.2/pdb.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "name": "BuiltinFunctionType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FunctionType", 
  "doc": "function(code, globals[, name[, argdefs[, closure]]])\n\nCreate a function object from a code object and a dictionary.\nThe optional name string overrides the name from the code object.\nThe optional argdefs tuple specifies the default argument values.\nThe optional closure tuple supplies the bindings for free variables.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PickleError", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Pickler", 
  "doc": "Pickler(file, protocol=None)\nThis takes a binary file for writing a pickle data stream.\n\nThe optional protocol argument tells the pickler to use the\ngiven protocol; supported protocols are 0, 1, 2, 3.  The default\nprotocol is 3; a backward-incompatible protocol designed for\nPython 3.0.\n\nSpecifying a negative protocol version selects the highest\nprotocol version supported.  The higher the protocol used, the\nmore recent the version of Python needed to read the pickle\nproduced.\n\nThe file argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, a io.BytesIO instance, or any other custom object that\nmeets this interface.\n\nIf fix_imports is True and protocol is less than 3, pickle will try to\nmap the new Python 3.x names to the old module names used in Python\n2.x, so that the pickle data stream is readable with Python 2.x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PicklingError", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Unpickler", 
  "doc": "Unpickler(file, *, encoding='ASCII', errors='strict')\nThis takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nproto argument is needed.\n\nThe file-like object must have two methods, a read() method\nthat takes an integer argument, and a readline() method that\nrequires no arguments.  Both methods should return bytes.\nThus file-like object can be a binary file object opened for\nreading, a BytesIO object, or any other custom object that\nmeets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatiblity support for pickle stream\ngenerated by Python 2.x.  If *fix_imports* is True, pickle will try to\nmap the old Python 2.x names to the new names used in Python 3.x.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2.x; these default to 'ASCII' and\n'strict', respectively.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnpicklingError", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Pickler", 
  "doc": null, 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Stop", 
  "doc": null, 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Unpickler", 
  "doc": null, 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_compat_pickle", 
  "file": "/usr/lib/python3.2/_compat_pickle.py"
 }, 
 {
  "name": "_keep_alive", 
  "doc": "Keeps a reference to the object x in the memo.\n\nBecause we remember objects by their id, we have\nto assure that possibly temporary objects are kept\nalive by referencing them.\nWe store a reference at the id of the memo, which should\nnormally not be used unless someone tries to deepcopy\nthe memo itself...", 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py"
 }, 
 {
  "name": "decode_long", 
  "doc": "Decode a long from a two's complement little-endian binary string.\n\n>>> decode_long(b'')\n0\n>>> decode_long(b\"\\xff\\x00\")\n255\n>>> decode_long(b\"\\xff\\x7f\")\n32767\n>>> decode_long(b\"\\x00\\xff\")\n-256\n>>> decode_long(b\"\\x00\\x80\")\n-32768\n>>> decode_long(b\"\\x80\")\n-128\n>>> decode_long(b\"\\x7f\")\n127", 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dump", 
  "doc": "dump(obj, file, protocol=None, *, fix_imports=True) -> None\n\nWrite a pickled representation of obj to the open file object file.  This\nis equivalent to ``Pickler(file, protocol).dump(obj)``, but may be more\nefficient.\n\nThe optional protocol argument tells the pickler to use the given protocol;\nsupported protocols are 0, 1, 2, 3.  The default protocol is 3; a\nbackward-incompatible protocol designed for Python 3.0.\n\nSpecifying a negative protocol version selects the highest protocol version\nsupported.  The higher the protocol used, the more recent the version of\nPython needed to read the pickle produced.\n\nThe file argument must have a write() method that accepts a single bytes\nargument.  It can thus be a file object opened for binary writing, a\nio.BytesIO instance, or any other custom object that meets this interface.\n\nIf fix_imports is True and protocol is less than 3, pickle will try to\nmap the new Python 3.x names to the old module names used in Python 2.x,\nso that the pickle data stream is readable with Python 2.x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dumps", 
  "doc": "dumps(obj, protocol=None, *, fix_imports=True) -> bytes\n\nReturn the pickled representation of the object as a bytes\nobject, instead of writing it to a file.\n\nThe optional protocol argument tells the pickler to use the given protocol;\nsupported protocols are 0, 1, 2, 3.  The default protocol is 3; a\nbackward-incompatible protocol designed for Python 3.0.\n\nSpecifying a negative protocol version selects the highest protocol version\nsupported.  The higher the protocol used, the more recent the version of\nPython needed to read the pickle produced.\n\nIf fix_imports is True and *protocol* is less than 3, pickle will try to\nmap the new Python 3.x names to the old module names used in Python 2.x,\nso that the pickle data stream is readable with Python 2.x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode_long", 
  "doc": "Encode a long to a two's complement little-endian binary string.\nNote that 0 is a special case, returning an empty string, to save a\nbyte in the LONG1 pickling context.\n\n>>> encode_long(0)\nb''\n>>> encode_long(255)\nb'\\xff\\x00'\n>>> encode_long(32767)\nb'\\xff\\x7f'\n>>> encode_long(-256)\nb'\\x00\\xff'\n>>> encode_long(-32768)\nb'\\x00\\x80'\n>>> encode_long(-128)\nb'\\x80'\n>>> encode_long(127)\nb'\\x7f'\n>>>", 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "load", 
  "doc": "load(file, *, fix_imports=True, encoding='ASCII', errors='strict') -> object\n\nRead a pickled object representation from the open file object file and\nreturn the reconstituted object hierarchy specified therein.  This is\nequivalent to ``Unpickler(file).load()``, but may be more efficient.\n\nThe protocol version of the pickle is detected automatically, so no protocol\nargument is needed.  Bytes past the pickled object's representation are\nignored.\n\nThe argument file must have two methods, a read() method that takes an\ninteger argument, and a readline() method that requires no arguments.  Both\nmethods should return bytes.  Thus *file* can be a binary file object opened\nfor reading, a BytesIO object, or any other custom object that meets this\ninterface.\n\nOptional keyword arguments are fix_imports, encoding and errors,\nwhich are used to control compatiblity support for pickle stream generated\nby Python 2.x.  If fix_imports is True, pickle will try to map the old\nPython 2.x names to the new names used in Python 3.x.  The encoding and\nerrors tell pickle how to decode 8-bit string instances pickled by Python\n2.x; these default to 'ASCII' and 'strict', respectively.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "loads", 
  "doc": "loads(input, *, fix_imports=True, encoding='ASCII', errors='strict') -> object\n\nRead a pickled object hierarchy from a bytes object and return the\nreconstituted object hierarchy specified therein\n\nThe protocol version of the pickle is detected automatically, so no protocol\nargument is needed.  Bytes past the pickled object's representation are\nignored.\n\nOptional keyword arguments are fix_imports, encoding and errors, which\nare used to control compatiblity support for pickle stream generated\nby Python 2.x.  If fix_imports is True, pickle will try to map the old\nPython 2.x names to the new names used in Python 3.x.  The encoding and\nerrors tell pickle how to decode 8-bit string instances pickled by Python\n2.x; these default to 'ASCII' and 'strict', respectively.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating point numbers.\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- write value to a string\nloads() -- read value from a string", 
  "line": 0, 
  "type": "module", 
  "name": "marshal", 
  "file": null
 }, 
 {
  "name": "mloads", 
  "doc": "loads(string)\n\nConvert the string to a value. If no valid value is found, raise\nEOFError, ValueError or TypeError. Extra characters in the string are\nignored.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "whichmodule", 
  "doc": "Figure out the module in which a function occurs.\n\nSearch sys.modules for the module.\nCache in classmap.\nReturn a module name.\nIf the function cannot be found, return \"__main__\".", 
  "module": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ArgumentDescriptor", 
  "doc": null, 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OpcodeInfo", 
  "doc": null, 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StackObject", 
  "doc": null, 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Example", 
  "doc": null, 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unpack", 
  "doc": "unpack(fmt, buffer) -> (v1, v2, ...)\n\nReturn a tuple containing values unpacked according to the format string\nfmt.  Requires len(buffer) == calcsize(fmt). See help(struct) for more\non format strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "codecs -- Python Codec Registry, API and helpers.\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.", 
  "line": 0, 
  "type": "module", 
  "name": "codecs", 
  "file": "/usr/lib/python3.2/codecs.py"
 }, 
 {
  "name": "decode_long", 
  "doc": "Decode a long from a two's complement little-endian binary string.\n\n>>> decode_long(b'')\n0\n>>> decode_long(b\"\\xff\\x00\")\n255\n>>> decode_long(b\"\\xff\\x7f\")\n32767\n>>> decode_long(b\"\\x00\\xff\")\n-256\n>>> decode_long(b\"\\x00\\x80\")\n-32768\n>>> decode_long(b\"\\x80\")\n-128\n>>> decode_long(b\"\\x7f\")\n127", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickle.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dis", 
  "doc": "Produce a symbolic disassembly of a pickle.\n\n'pickle' is a file-like object, or string, containing a (at least one)\npickle.  The pickle is disassembled from the current position, through\nthe first STOP opcode encountered.\n\nOptional arg 'out' is a file-like object to which the disassembly is\nprinted.  It defaults to sys.stdout.\n\nOptional arg 'memo' is a Python dict, used as the pickle's memo.  It\nmay be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.\nPassing the same memo object to another dis() call then allows disassembly\nto proceed across multiple pickles that were all created by the same\npickler with the same memo.  Ordinarily you don't need to worry about this.\n\nOptional arg 'indentlevel' is the number of blanks by which to indent\na new MARK level.  It defaults to 4.\n\nOptional arg 'annotate' if nonzero instructs dis() to add short\ndescription of the opcode on each line of disassembled output.\nThe value given to 'annotate' must be an integer and is used as a\nhint for the column where annotation should start.  The default\nvalue is 0, meaning no annotations.\n\nIn addition to printing the disassembly, some sanity checks are made:\n\n+ All embedded opcode arguments \"make sense\".\n\n+ Explicit and implicit pop operations have enough items on the stack.\n\n+ When an opcode implicitly refers to a markobject, a markobject is\n  actually on the stack.\n\n+ A memo entry isn't referenced before it's defined.\n\n+ The markobject isn't stored in the memo.\n\n+ A memo entry isn't redefined.", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "genops", 
  "doc": "Generate all the opcodes in a pickle.\n\n'pickle' is a file-like object, or string, containing the pickle.\n\nEach opcode in the pickle is generated, from the current pickle position,\nstopping after a STOP opcode is delivered.  A triple is generated for\neach opcode:\n\n    opcode, arg, pos\n\nopcode is an OpcodeInfo record, describing the current opcode.\n\nIf the opcode has an argument embedded in the pickle, arg is its decoded\nvalue, as a Python object.  If the opcode doesn't have an argument, arg\nis None.\n\nIf the pickle has a tell() method, pos was the value of pickle.tell()\nbefore reading the current opcode.  If the pickle is a bytes object,\nit's wrapped in a BytesIO object, and the latter's tell() result is\nused.  Else (the pickle doesn't have a tell(), and it's not obvious how\nto query its current position) pos is None.", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "optimize", 
  "doc": "Optimize a pickle string by removing unused PUT opcodes", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Create portable serialized representations of Python objects.\n\nSee module copyreg for a mechanism for registering custom picklers.\nSee module pickletools source for extensive comments.\n\nClasses:\n\n    Pickler\n    Unpickler\n\nFunctions:\n\n    dump(object, file)\n    dumps(object) -> string\n    load(file) -> object\n    loads(string) -> object\n\nMisc variables:\n\n    __version__\n    format_version\n    compatible_formats", 
  "line": 0, 
  "type": "module", 
  "name": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "read_decimalnl_long", 
  "doc": ">>> import io\n\n>>> read_decimalnl_long(io.BytesIO(b\"1234L\\n56\"))\n1234\n\n>>> read_decimalnl_long(io.BytesIO(b\"123456789012345678901234L\\n6\"))\n123456789012345678901234", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_decimalnl_short", 
  "doc": ">>> import io\n>>> read_decimalnl_short(io.BytesIO(b\"1234\\n56\"))\n1234\n\n>>> read_decimalnl_short(io.BytesIO(b\"1234L\\n56\"))\nTraceback (most recent call last):\n...\nValueError: trailing 'L' not allowed in b'1234L'", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_float8", 
  "doc": ">>> import io, struct\n>>> raw = struct.pack(\">d\", -1.25)\n>>> raw\nb'\\xbf\\xf4\\x00\\x00\\x00\\x00\\x00\\x00'\n>>> read_float8(io.BytesIO(raw + b\"\\n\"))\n-1.25", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_floatnl", 
  "doc": ">>> import io\n>>> read_floatnl(io.BytesIO(b\"-1.25\\n6\"))\n-1.25", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_int4", 
  "doc": ">>> import io\n>>> read_int4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n255\n>>> read_int4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == -(2**31)\nTrue", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_long1", 
  "doc": ">>> import io\n>>> read_long1(io.BytesIO(b\"\\x00\"))\n0\n>>> read_long1(io.BytesIO(b\"\\x02\\xff\\x00\"))\n255\n>>> read_long1(io.BytesIO(b\"\\x02\\xff\\x7f\"))\n32767\n>>> read_long1(io.BytesIO(b\"\\x02\\x00\\xff\"))\n-256\n>>> read_long1(io.BytesIO(b\"\\x02\\x00\\x80\"))\n-32768", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_long4", 
  "doc": ">>> import io\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x00\"))\n255\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x7f\"))\n32767\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\xff\"))\n-256\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\x80\"))\n-32768\n>>> read_long1(io.BytesIO(b\"\\x00\\x00\\x00\\x00\"))\n0", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_string1", 
  "doc": ">>> import io\n>>> read_string1(io.BytesIO(b\"\\x00\"))\n''\n>>> read_string1(io.BytesIO(b\"\\x03abcdef\"))\n'abc'", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_string4", 
  "doc": ">>> import io\n>>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\n''\n>>> read_string4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\n'abc'\n>>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\nTraceback (most recent call last):\n...\nValueError: expected 50331648 bytes in a string4, but only 6 remain", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_stringnl", 
  "doc": ">>> import io\n>>> read_stringnl(io.BytesIO(b\"'abcd'\\nefg\\n\"))\n'abcd'\n\n>>> read_stringnl(io.BytesIO(b\"\\n\"))\nTraceback (most recent call last):\n...\nValueError: no string quotes around b''\n\n>>> read_stringnl(io.BytesIO(b\"\\n\"), stripquotes=False)\n''\n\n>>> read_stringnl(io.BytesIO(b\"''\\n\"))\n''\n\n>>> read_stringnl(io.BytesIO(b'\"abcd\"'))\nTraceback (most recent call last):\n...\nValueError: no newline found when trying to read stringnl\n\nEmbedded escapes are undone in the result.\n>>> read_stringnl(io.BytesIO(br\"'a\\n\\\\b\\x00c\\td'\" + b\"\\n'e'\"))\n'a\\n\\\\b\\x00c\\td'", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_stringnl_noescape", 
  "doc": null, 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_stringnl_noescape_pair", 
  "doc": ">>> import io\n>>> read_stringnl_noescape_pair(io.BytesIO(b\"Queue\\nEmpty\\njunk\"))\n'Queue Empty'", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_uint1", 
  "doc": ">>> import io\n>>> read_uint1(io.BytesIO(b'\\xff'))\n255", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_uint2", 
  "doc": ">>> import io\n>>> read_uint2(io.BytesIO(b'\\xff\\x00'))\n255\n>>> read_uint2(io.BytesIO(b'\\xff\\xff'))\n65535", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_unicodestring4", 
  "doc": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length\n>>> t = read_unicodestring4(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring4(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring4, but only 6 remain", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_unicodestringnl", 
  "doc": ">>> import io\n>>> read_unicodestringnl(io.BytesIO(b\"abc\\\\uabcd\\njunk\")) == 'abc\\uabcd'\nTrue", 
  "module": "pickletools", 
  "file": "/usr/lib/python3.2/pickletools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Template", 
  "doc": "Class representing a pipeline template.", 
  "module": "pipes", 
  "file": "/usr/lib/python3.2/pipes.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "makepipeline", 
  "doc": null, 
  "module": "pipes", 
  "file": "/usr/lib/python3.2/pipes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "quote", 
  "doc": "Return a shell-escaped version of the file string.", 
  "module": "pipes", 
  "file": "/usr/lib/python3.2/pipes.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "A collection of string constants.\n\nPublic module variables:\n\nwhitespace -- a string containing all ASCII whitespace\nascii_lowercase -- a string containing all ASCII lowercase letters\nascii_uppercase -- a string containing all ASCII uppercase letters\nascii_letters -- a string containing all ASCII letters\ndigits -- a string containing all ASCII decimal digits\nhexdigits -- a string containing all ASCII hexadecimal digits\noctdigits -- a string containing all ASCII octal digits\npunctuation -- a string containing all ASCII punctuation characters\nprintable -- a string containing all ASCII characters considered printable", 
  "line": 0, 
  "type": "module", 
  "name": "string", 
  "file": "/usr/lib/python3.2/string.py"
 }, 
 {
  "doc": "Temporary files.\n\nThis module provides generic, low- and high-level interfaces for\ncreating temporary files and directories.  The interfaces listed\nas \"safe\" just below can be used without fear of race conditions.\nThose listed as \"unsafe\" cannot, and are provided for backward\ncompatibility only.\n\nThis module also provides some data items to the user:\n\n  TMP_MAX  - maximum number of names that will be tried before\n             giving up.\n  template - the default prefix for all temporary names.\n             You may change this to control the default prefix.\n  tempdir  - If this is set to a string before the first use of\n             any routine from this module, it will be considered as\n             another candidate location to store temporary files.", 
  "line": 0, 
  "type": "module", 
  "name": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py"
 }, 
 {
  "name": "ImpImporter", 
  "doc": "PEP 302 Importer that wraps Python's \"classic\" import algorithm\n\nImpImporter(dirname) produces a PEP 302 importer that searches that\ndirectory.  ImpImporter(None) produces a PEP 302 importer that searches\nthe current sys.path, plus any modules that are frozen or built-in.\n\nNote that ImpImporter does not currently support being used by placement\non sys.meta_path.", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ImpLoader", 
  "doc": "PEP 302 Loader that wraps Python's \"classic\" import algorithm\n    ", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ModuleType", 
  "doc": "module(name[, doc])\n\nCreate a module object.\nThe name must be a string; the optional doc argument can have any type.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "extend_path", 
  "doc": "Extend a package's path.\n\nIntended use is to place the following code in a package's __init__.py:\n\n    from pkgutil import extend_path\n    __path__ = extend_path(__path__, __name__)\n\nThis will add to the package's __path__ all subdirectories of\ndirectories on sys.path named after the package.  This is useful\nif one wants to distribute different parts of a single logical\npackage as multiple directories.\n\nIt also looks for *.pkg files beginning where * matches the name\nargument.  This feature is similar to *.pth files (see site.py),\nexcept that it doesn't special-case lines starting with 'import'.\nA *.pkg file is trusted at face value: apart from checking for\nduplicates, all entries found in a *.pkg file are added to the\npath, regardless of whether they are exist the filesystem.  (This\nis a feature.)\n\nIf the input path is not a list (as is the case for frozen\npackages) it is returned unchanged.  The input path is not\nmodified; an extended copy is returned.  Items are only appended\nto the copy at the end.\n\nIt is assumed that sys.path is a sequence.  Items of sys.path that\nare not (unicode or 8-bit) strings referring to existing\ndirectories are ignored.  Unicode items of sys.path that cause\nerrors when used as filenames may cause this function to raise an\nexception (in line with os.path.isdir() behavior).", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find_loader", 
  "doc": "Find a PEP 302 \"loader\" object for fullname\n\nIf fullname contains dots, path must be the containing package's __path__.\nReturns None if the module cannot be found or imported. This function uses\niter_importers(), and is thus subject to the same limitations regarding\nplatform-specific special import locations such as the Windows registry.", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_data", 
  "doc": "Get a resource from a package.\n\nThis is a wrapper round the PEP 302 loader get_data API. The package\nargument should be the name of a package, in standard module format\n(foo.bar). The resource argument should be in the form of a relative\nfilename, using '/' as the path separator. The parent directory name '..'\nis not allowed, and nor is a rooted name (starting with a '/').\n\nThe function returns a binary string, which is the contents of the\nspecified resource.\n\nFor packages located in the filesystem, which have already been imported,\nthis is the rough equivalent of\n\n    d = os.path.dirname(sys.modules[package].__file__)\n    data = open(os.path.join(d, resource), 'rb').read()\n\nIf the package cannot be located or loaded, or it uses a PEP 302 loader\nwhich does not support get_data(), then None is returned.", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_importer", 
  "doc": "Retrieve a PEP 302 importer for the given path item\n\nThe returned importer is cached in sys.path_importer_cache\nif it was newly created by a path hook.\n\nIf there is no importer, a wrapper around the basic import\nmachinery is returned. This wrapper is never inserted into\nthe importer cache (None is inserted instead).\n\nThe cache (or part of it) can be cleared manually if a\nrescan of sys.path_hooks is necessary.", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_loader", 
  "doc": "Get a PEP 302 \"loader\" object for module_or_name\n\nIf the module or package is accessible via the normal import\nmechanism, a wrapper around the relevant part of that machinery\nis returned.  Returns None if the module cannot be found or imported.\nIf the named module is not already imported, its containing package\n(if any) is imported, in order to establish the package __path__.\n\nThis function uses iter_importers(), and is thus subject to the same\nlimitations regarding platform-specific special import locations such\nas the Windows registry.", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "iter_importer_modules", 
  "doc": null, 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iter_importers", 
  "doc": "Yield PEP 302 importers for the given module name\n\nIf fullname contains a '.', the importers will be for the package\ncontaining fullname, otherwise they will be importers for sys.meta_path,\nsys.path, and Python's \"classic\" import machinery, in that order.  If\nthe named module is in a package, that package is imported as a side\neffect of invoking this function.\n\nNon PEP 302 mechanisms (e.g. the Windows registry) used by the\nstandard import machinery to find files in alternative locations\nare partially supported, but are searched AFTER sys.path. Normally,\nthese locations are searched BEFORE sys.path, preventing sys.path\nentries from shadowing them.\n\nFor this to cause a visible difference in behaviour, there must\nbe a module or package name that is accessible via both sys.path\nand one of the non PEP 302 file system mechanisms. In this case,\nthe emulation will find the former version, while the builtin\nimport mechanism will find the latter.\n\nItems of the following types can be affected by this discrepancy:\n    imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iter_modules", 
  "doc": "Yields (module_loader, name, ispkg) for all submodules on path,\nor, if path is None, all top-level modules on sys.path.\n\n'path' should be either None or a list of paths to look for\nmodules in.\n\n'prefix' is a string to output on the front of every module name\non output.", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "iter_zipimport_modules", 
  "doc": null, 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "read_code", 
  "doc": null, 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "simplegeneric", 
  "doc": "Make a trivial single-dispatch generic function", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "walk_packages", 
  "doc": "Yields (module_loader, name, ispkg) for all modules recursively\non path, or, if path is None, all accessible modules.\n\n'path' should be either None or a list of paths to look for\nmodules in.\n\n'prefix' is a string to output on the front of every module name\non output.\n\nNote that this function must import all *packages* (NOT all\nmodules!) on the given path, in order to access the __path__\nattribute to find submodules.\n\n'onerror' is a function which gets called with one argument (the\nname of the package which was being imported) if any exception\noccurs while trying to import a package.  If no onerror function is\nsupplied, ImportErrors are caught and ignored, while all other\nexceptions are propagated, terminating the search.\n\nExamples:\n\n# list all modules python can access\nwalk_packages()\n\n# list all submodules of ctypes\nwalk_packages(ctypes.__path__, ctypes.__name__+'.')", 
  "module": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "zipimport provides support for importing Python modules from Zip archives.\n\nThis module exports three objects:\n- zipimporter: a class; its constructor takes a path to a Zip archive.\n- ZipImportError: exception raised by zipimporter objects. It's a\n  subclass of ImportError, so it can be caught as ImportError, too.\n- _zip_directory_cache: a dict, mapping archive paths to zip directory\n  info dicts, as used in zipimporter._files.\n\nIt is usually not needed to use the zipimport module explicitly; it is\nused by the builtin import mechanism for sys.path items that are paths\nto Zip archives.", 
  "line": 0, 
  "type": "module", 
  "name": "zipimport", 
  "file": null
 }, 
 {
  "name": "zipimporter", 
  "doc": "zipimporter(archivepath) -> zipimporter object\n\nCreate a new zipimporter instance. 'archivepath' must be a path to\na zipfile, or to a specific path inside a zipfile. For example, it can be\n'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\nvalid directory inside the archive.\n\n'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\narchive.\n\nThe 'archive' attribute of zipimporter objects contains the name of the\nzipfile targeted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_bcd2str", 
  "doc": null, 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dist_try_harder", 
  "doc": "Tries some special tricks to get the distribution\ninformation in case the default method fails.\n\nCurrently supports older SuSE Linux, Caldera OpenLinux and\nSlackware Linux distributions.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_follow_symlinks", 
  "doc": "In case filepath is a symlink, follow it until a\nreal file is reached.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_java_getprop", 
  "doc": null, 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_mac_ver_gestalt", 
  "doc": "Thanks to Mark R. Levinson for mailing documentation links and\ncode examples for this function. Documentation for the\ngestalt() API is available online at:\n\n   http://www.rgaros.nl/gestalt/", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_mac_ver_lookup", 
  "doc": null, 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_mac_ver_xml", 
  "doc": null, 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_node", 
  "doc": "Helper to determine the node name of this machine.\n    ", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_norm_version", 
  "doc": "Normalize the version and build strings and return a single\nversion string using the format major.minor.build (or patchlevel).", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_release_file", 
  "doc": null, 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_platform", 
  "doc": "Helper to format the platform string in a filename\ncompatible format e.g. \"system-version-machine\".", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_popen", 
  "doc": "Fairly portable (alternative) popen implementation.\n\nThis is mostly needed in case os.popen() is not available, or\ndoesn't work as advertised, e.g. in Win9X GUI programs like\nPythonWin or IDLE.\n\nWriting to the pipe is currently not supported.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_sys_version", 
  "doc": "Returns a parsed version of Python's sys.version as tuple\n(name, version, branch, revision, buildno, builddate, compiler)\nreferring to the Python implementation name, version, branch,\nrevision, build number, build date/time as string and the compiler\nidentification string.\n\nNote that unlike the Python sys.version, the returned value\nfor the Python version will always include the patchlevel (it\ndefaults to '.0').\n\nThe function returns empty strings for tuple entries that\ncannot be determined.\n\nsys_version may be given to parse an alternative version\nstring, e.g. if the version was read from a different Python\ninterpreter.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_syscmd_file", 
  "doc": "Interface to the system's file command.\n\nThe function uses the -b option of the file command to have it\nomit the filename in its output. Follow the symlinks. It returns\ndefault in case the command should fail.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_syscmd_uname", 
  "doc": "Interface to the system's uname command.\n    ", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_syscmd_ver", 
  "doc": "Tries to figure out the OS version used and returns\na tuple (system,release,version).\n\nIt uses the \"ver\" shell command for this which is known\nto exists on Windows, DOS and OS/2. XXX Others too ?\n\nIn case this fails, the given parameters are used as\ndefaults.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_win32_getvalue", 
  "doc": "Read a value for name from the registry key.\n\nIn case this fails, default is returned.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "architecture", 
  "doc": "Queries the given executable (defaults to the Python interpreter\nbinary) for various architecture information.\n\nReturns a tuple (bits,linkage) which contains information about\nthe bit architecture and the linkage format used for the\nexecutable. Both values are returned as strings.\n\nValues that cannot be determined are returned as given by the\nparameter presets. If bits is given as '', the sizeof(pointer)\n(or sizeof(long) on Python version < 1.5.2) is used as\nindicator for the supported pointer size.\n\nThe function relies on the system's \"file\" command to do the\nactual work. This is available on most if not all Unix\nplatforms. On some non-Unix platforms where the \"file\" command\ndoes not exist and the executable is set to the Python interpreter\nbinary defaults from _default_architecture are used.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dist", 
  "doc": "Tries to determine the name of the Linux OS distribution name.\n\nThe function first looks for a distribution release file in\n/etc and then reverts to _dist_try_harder() in case no\nsuitable files are found.\n\nReturns a tuple (distname,version,id) which default to the\nargs given as parameters.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "java_ver", 
  "doc": "Version interface for Jython.\n\nReturns a tuple (release,vendor,vminfo,osinfo) with vminfo being\na tuple (vm_name,vm_release,vm_vendor) and osinfo being a\ntuple (os_name,os_version,os_arch).\n\nValues which cannot be determined are set to the defaults\ngiven as parameters (which all default to '').", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "libc_ver", 
  "doc": "Tries to determine the libc version that the file executable\n(which defaults to the Python interpreter) is linked against.\n\nReturns a tuple of strings (lib,version) which default to the\ngiven parameters in case the lookup fails.\n\nNote that the function has intimate knowledge of how different\nlibc versions add symbols to the executable and thus is probably\nonly useable for executables compiled using gcc.\n\nThe file is read and scanned in chunks of chunksize bytes.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "linux_distribution", 
  "doc": "Tries to determine the name of the Linux OS distribution name.\n\nThe function first looks for a distribution release file in\n/etc and then reverts to _dist_try_harder() in case no\nsuitable files are found.\n\nsupported_dists may be given to define the set of Linux\ndistributions to look for. It defaults to a list of currently\nsupported Linux distributions identified by their release file\nname.\n\nIf full_distribution_name is true (default), the full\ndistribution read from the OS is returned. Otherwise the short\nname taken from supported_dists is used.\n\nReturns a tuple (distname,version,id) which default to the\nargs given as parameters.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mac_ver", 
  "doc": "Get MacOS version information and return it as tuple (release,\nversioninfo, machine) with versioninfo being a tuple (version,\ndev_stage, non_release_version).\n\nEntries which cannot be determined are set to the paramter values\nwhich default to ''. All tuple entries are strings.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "machine", 
  "doc": "Returns the machine type, e.g. 'i386'\n\nAn empty string is returned if the value cannot be determined.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "node", 
  "doc": "Returns the computer's network name (which may not be fully\nqualified)\n\nAn empty string is returned if the value cannot be determined.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "platform", 
  "doc": "Returns a single string identifying the underlying platform\nwith as much useful information as possible (but no more :).\n\nThe output is intended to be human readable rather than\nmachine parseable. It may look different on different\nplatforms and this is intended.\n\nIf \"aliased\" is true, the function will use aliases for\nvarious platforms that report system names which differ from\ntheir common names, e.g. SunOS will be reported as\nSolaris. The system_alias() function is used to implement\nthis.\n\nSetting terse to true causes the function to return only the\nabsolute minimum information needed to identify the platform.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "popen", 
  "doc": "Portable popen() interface.\n    ", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "processor", 
  "doc": "Returns the (true) processor name, e.g. 'amdk6'\n\nAn empty string is returned if the value cannot be\ndetermined. Note that many platforms do not provide this\ninformation or simply return the same value as for machine(),\ne.g.  NetBSD does this.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_branch", 
  "doc": "Returns a string identifying the Python implementation\nbranch.\n\nFor CPython this is the Subversion branch from which the\nPython binary was built.\n\nIf not available, an empty string is returned.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_build", 
  "doc": "Returns a tuple (buildno, builddate) stating the Python\nbuild number and date as strings.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_compiler", 
  "doc": "Returns a string identifying the compiler used for compiling\nPython.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_implementation", 
  "doc": "Returns a string identifying the Python implementation.\n\nCurrently, the following implementations are identified:\n  'CPython' (C implementation of Python),\n  'IronPython' (.NET implementation of Python),\n  'Jython' (Java implementation of Python),\n  'PyPy' (Python implementation of Python).", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_revision", 
  "doc": "Returns a string identifying the Python implementation\nrevision.\n\nFor CPython this is the Subversion revision from which the\nPython binary was built.\n\nIf not available, an empty string is returned.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_version", 
  "doc": "Returns the Python version as string 'major.minor.patchlevel'\n\nNote that unlike the Python sys.version, the returned value\nwill always include the patchlevel (it defaults to 0).", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "python_version_tuple", 
  "doc": "Returns the Python version as tuple (major, minor, patchlevel)\nof strings.\n\nNote that unlike the Python sys.version, the returned value\nwill always include the patchlevel (it defaults to 0).", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "release", 
  "doc": "Returns the system's release, e.g. '2.2.0' or 'NT'\n\nAn empty string is returned if the value cannot be determined.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "system", 
  "doc": "Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.\n\nAn empty string is returned if the value cannot be determined.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "system_alias", 
  "doc": "Returns (system,release,version) aliased to common\nmarketing names used for some systems.\n\nIt also does some reordering of the information in some cases\nwhere it would otherwise cause confusion.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "uname", 
  "doc": "Fairly portable uname interface. Returns a tuple\nof strings (system,node,release,version,machine,processor)\nidentifying the underlying platform.\n\nNote that unlike the os.uname function this also returns\npossible processor information as an additional tuple entry.\n\nEntries which cannot be determined are set to ''.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "version", 
  "doc": "Returns the system's release version, e.g. '#3 on degas'\n\nAn empty string is returned if the value cannot be determined.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "win32_ver", 
  "doc": "Get additional version information from the Windows Registry\nand return a tuple (version,csd,ptype) referring to version\nnumber, CSD level (service pack), and OS type (multi/single\nprocessor).\n\nAs a hint: ptype returns 'Uniprocessor Free' on single\nprocessor NT machines and 'Multiprocessor Free' on multi\nprocessor machines. The 'Free' refers to the OS version being\nfree of debugging code. It could also state 'Checked' which\nmeans the OS version uses debugging code, i.e. code that\nchecks arguments, ranges, etc. (Thomas Heller).\n\nNote: this function works best with Mark Hammond's win32\npackage installed, but also on Python 2.3 and later. It\nobviously only runs on Win32 compatible platforms.", 
  "module": "platform", 
  "file": "/usr/lib/python3.2/platform.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BytesIO", 
  "doc": "BytesIO([buffer]) -> object\n\nCreate a buffered I/O implementation using an in-memory bytes\nbuffer, ready for reading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Data", 
  "doc": "Wrapper for binary data.", 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Dict", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DumbXMLWriter", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Plist", 
  "doc": "This class has been deprecated. Use readPlist() and writePlist()\nfunctions instead, together with regular dict objects.", 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PlistParser", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PlistWriter", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_InternalDict", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_dateFromString", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_dateToString", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_encodeBase64", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_escape", 
  "doc": null, 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Conversion between binary data and ASCII", 
  "line": 0, 
  "type": "module", 
  "name": "binascii", 
  "file": null
 }, 
 {
  "doc": "Fast implementation of the datetime type.", 
  "line": 0, 
  "type": "module", 
  "name": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "readPlist", 
  "doc": "Read a .plist file. 'pathOrFile' may either be a file name or a\n(readable) file object. Return the unpacked root object (which\nusually is a dictionary).", 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "readPlistFromBytes", 
  "doc": "Read a plist data from a bytes object. Return the root object.\n    ", 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "writePlist", 
  "doc": "Write 'rootObject' to a .plist file. 'pathOrFile' may either be a\nfile name or a (writable) file object.", 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "writePlistToBytes", 
  "doc": "Return 'rootObject' as a plist-formatted bytes object.\n    ", 
  "module": "plistlib", 
  "file": "/usr/lib/python3.2/plistlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "POP3", 
  "doc": "This class supports both the minimal and optional command sets.\nArguments can be strings or integers (where appropriate)\n(e.g.: retr(1) and retr('1') both work equally well.\n\nMinimal Command Set:\n        USER name               user(name)\n        PASS string             pass_(string)\n        STAT                    stat()\n        LIST [msg]              list(msg = None)\n        RETR msg                retr(msg)\n        DELE msg                dele(msg)\n        NOOP                    noop()\n        RSET                    rset()\n        QUIT                    quit()\n\nOptional Commands (some servers support these):\n        RPOP name               rpop(name)\n        APOP name digest        apop(name, digest)\n        TOP msg n               top(msg, n)\n        UIDL [msg]              uidl(msg = None)\n\nRaises one exception: 'error_proto'.\n\nInstantiate with:\n        POP3(hostname, port=110)\n\nNB:     the POP protocol locks the mailbox from user\n        authorization until QUIT, so be sure to get in, suck\n        the messages, and quit, each time you access the\n        mailbox.\n\n        POP is a line-based protocol, which means large mail\n        messages consume lots of python cycles reading them\n        line-by-line.\n\n        If it's available on your mail server, use IMAP4\n        instead, it doesn't suffer from the two problems\n        above.", 
  "module": "poplib", 
  "file": "/usr/lib/python3.2/poplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "POP3_SSL", 
  "doc": "POP3 client class over SSL connection\n\nInstantiate with: POP3_SSL(hostname, port=995, keyfile=None, certfile=None)\n\n       hostname - the hostname of the pop3 over ssl server\n       port - port number\n       keyfile - PEM formatted file that countains your private key\n       certfile - PEM formatted certificate chain file\n\nSee the methods of the parent class POP3 for more documentation.", 
  "module": "poplib", 
  "file": "/usr/lib/python3.2/poplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error_proto", 
  "doc": null, 
  "module": "poplib", 
  "file": "/usr/lib/python3.2/poplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides some more Pythonic support for SSL.\n\nObject types:\n\n  SSLSocket -- subtype of socket.socket which does SSL over the socket\n\nExceptions:\n\n  SSLError -- exception raised for I/O errors\n\nFunctions:\n\n  cert_time_to_seconds -- convert time string used for certificate\n                          notBefore and notAfter functions to integer\n                          seconds past the Epoch (the time values\n                          returned from time.time())\n\n  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided\n                          by the server running on HOST at port PORT.  No\n                          validation of the certificate is performed.\n\nInteger constants:\n\nSSL_ERROR_ZERO_RETURN\nSSL_ERROR_WANT_READ\nSSL_ERROR_WANT_WRITE\nSSL_ERROR_WANT_X509_LOOKUP\nSSL_ERROR_SYSCALL\nSSL_ERROR_SSL\nSSL_ERROR_WANT_CONNECT\n\nSSL_ERROR_EOF\nSSL_ERROR_INVALID_ERROR_CODE\n\nThe following group define certificate requirements that one side is\nallowing/requiring from the other side:\n\nCERT_NONE - no certificates from the other side are required (or will\n            be looked at if provided)\nCERT_OPTIONAL - certificates are not required, but if provided will be\n                validated, and if validation fails, the connection will\n                also fail\nCERT_REQUIRED - certificates are required, and will be validated, and\n                if validation fails, the connection will also fail\n\nThe following constants identify various SSL protocol variants:\n\nPROTOCOL_SSLv2\nPROTOCOL_SSLv3\nPROTOCOL_SSLv23\nPROTOCOL_TLSv1", 
  "line": 0, 
  "type": "module", 
  "name": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py"
 }, 
 {
  "name": "_get_sep", 
  "doc": null, 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_resolve_link", 
  "doc": "Internal helper function.  Takes a path and follows symlinks\nuntil we either arrive at something that isn't a symlink, or\nencounter a path we've seen before (meaning that there's a loop).", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abspath", 
  "doc": "Return an absolute path.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "basename", 
  "doc": "Returns the final component of a pathname", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "commonprefix", 
  "doc": "Given a list of pathnames, returns the longest common leading component", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dirname", 
  "doc": "Returns the directory component of a pathname", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exists", 
  "doc": "Test whether a path exists.  Returns False for broken symbolic links", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expanduser", 
  "doc": "Expand ~ and ~user constructions.  If user or $HOME is unknown,\ndo nothing.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandvars", 
  "doc": "Expand shell variables of form $var and ${var}.  Unknown variables\nare left unchanged.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Path operations common to more than one OS\nDo not use directly.  The OS specific modules import the appropriate\nfunctions from this module themselves.", 
  "line": 0, 
  "type": "module", 
  "name": "genericpath", 
  "file": "/usr/lib/python3.2/genericpath.py"
 }, 
 {
  "name": "getatime", 
  "doc": "Return the last access time of a file, reported by os.stat().", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getctime", 
  "doc": "Return the metadata change time of a file, reported by os.stat().", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmtime", 
  "doc": "Return the last modification time of a file, reported by os.stat().", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsize", 
  "doc": "Return the size of a file, reported by os.stat().", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isabs", 
  "doc": "Test whether a path is absolute", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdir", 
  "doc": "Return true if the pathname refers to an existing directory.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfile", 
  "doc": "Test whether a path is a regular file", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/genericpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islink", 
  "doc": "Test whether a path is a symbolic link", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ismount", 
  "doc": "Test whether a path is a mount point", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lexists", 
  "doc": "Test whether a path exists.  Returns True for broken symbolic links", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normcase", 
  "doc": "Normalize case of pathname.  Has no effect under Posix", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normpath", 
  "doc": "Normalize path, eliminating double slashes, etc.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "realpath", 
  "doc": "Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "relpath", 
  "doc": "Return a relative version of a path", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "samefile", 
  "doc": "Test whether two pathnames reference the same actual file", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sameopenfile", 
  "doc": "Test whether two open file objects reference the same file", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "samestat", 
  "doc": "Test whether two stat buffers reference the same file", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\neverything after the final slash.  Either part may be empty.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitdrive", 
  "doc": "Split a pathname into drive and path. On Posix, drive is always\nempty.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitext", 
  "doc": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.", 
  "module": "posixpath", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "PrettyPrinter", 
  "doc": null, 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_OrderedDict", 
  "doc": "Dictionary that remembers insertion order", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_commajoin", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_id", 
  "doc": "id(object) -> integer\n\nReturn the identity of an object.  This is guaranteed to be unique among\nsimultaneously existing objects.  (Hint: it's the object's memory address.)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_len", 
  "doc": "len(object) -> integer\n\nReturn the number of items of a sequence or mapping.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_perfcheck", 
  "doc": null, 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_recursion", 
  "doc": null, 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_safe_key", 
  "doc": "Helper function for key functions when sorting unorderable objects.\n\nThe wrapped-object will fallback to an Py2.x style comparison for\nunorderable types (sorting first comparing the type name and then by\nthe obj ids).  Does not work recursively, so dict.items() must have\n_safe_key applied to both the key and the value.", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_safe_repr", 
  "doc": null, 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_safe_tuple", 
  "doc": "Helper function for comparing 2-tuples", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "name": "_type", 
  "doc": "type(object) -> the object's type\ntype(name, bases, dict) -> a new type", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "isreadable", 
  "doc": "Determine if saferepr(object) is readable by eval().", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isrecursive", 
  "doc": "Determine if object requires a recursive representation.", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pformat", 
  "doc": "Format a Python object into a pretty-printed representation.", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pprint", 
  "doc": "Pretty-print a Python object to a stream [default is sys.stdout].", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "saferepr", 
  "doc": "Version of repr() which can handle recursive data structures.", 
  "module": "pprint", 
  "file": "/usr/lib/python3.2/pprint.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "OptionParser", 
  "doc": "Class attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  usage : string\n    a usage string for your program.  Before it is displayed\n    to the user, \"%prog\" will be expanded to the name of\n    your program (self.prog or os.path.basename(sys.argv[0])).\n  prog : string\n    the name of the current program (to override\n    os.path.basename(sys.argv[0])).\n  description : string\n    A paragraph of text giving a brief overview of your program.\n    optparse reformats this paragraph to fit the current terminal\n    width and prints it when the user requests help (after usage,\n    but before the list of options).\n  epilog : string\n    paragraph of help text to print after option help\n\n  option_groups : [OptionGroup]\n    list of option groups in this parser (option groups are\n    irrelevant for parsing the command-line, but very useful\n    for generating help)\n\n  allow_interspersed_args : bool = true\n    if true, positional arguments may be interspersed with options.\n    Assuming -a and -b each take a single argument, the command-line\n      -ablah foo bar -bboo baz\n    will be interpreted the same as\n      -ablah -bboo -- foo bar baz\n    If this flag were false, that command line would be interpreted as\n      -ablah -- foo bar -bboo baz\n    -- ie. we stop processing options as soon as we see the first\n    non-option argument.  (This is the tradition followed by\n    Python's getopt module, Perl's Getopt::Std, and other argument-\n    parsing libraries, but it is generally annoying to users.)\n\n  process_default_values : bool = true\n    if true, option default values are processed similarly to option\n    values from the command line: that is, they are passed to the\n    type-checking function for the option's type (as long as the\n    default value is a string).  (This really only matters if you\n    have defined custom types; see SF bug #955889.)  Set it to false\n    to restore the behaviour of Optik 1.4.1 and earlier.\n\n  rargs : [string]\n    the argument list currently being parsed.  Only set when\n    parse_args() is active, and continually trimmed down as\n    we consume arguments.  Mainly there for the benefit of\n    callback options.\n  largs : [string]\n    the list of leftover arguments that we have skipped while\n    parsing options.  If allow_interspersed_args is false, this\n    list is always empty.\n  values : Values\n    the set of option values currently being accumulated.  Only\n    set when parse_args() is active.  Also mainly for callbacks.\n\nBecause of the 'rargs', 'largs', and 'values' attributes,\nOptionParser is not thread-safe.  If, for some perverse reason, you\nneed to parse command-line arguments simultaneously in different\nthreads, use different OptionParser instances.", 
  "module": "profile", 
  "file": "/usr/lib/python3.2/optparse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Profile", 
  "doc": "Profiler class.\n\nself.cur is always a tuple.  Each such tuple corresponds to a stack\nframe that is currently active (self.cur[-2]).  The following are the\ndefinitions of its members.  We use this external \"parallel stack\" to\navoid contaminating the program that we are profiling. (old profiler\nused to write into the frames local dictionary!!) Derived classes\ncan change the definition of some entries, as long as they leave\n[-2:] intact (frame and previous tuple).  In case an internal error is\ndetected, the -3 element is used as the function name.\n\n[ 0] = Time that needs to be charged to the parent frame's function.\n       It is used so that a function call will not have to access the\n       timing data for the parent frame.\n[ 1] = Total time spent in this frame's function, excluding time in\n       subfunctions (this latter is tallied in cur[2]).\n[ 2] = Total time spent in subfunctions, excluding time executing the\n       frame's function (this latter is tallied in cur[1]).\n[-3] = Name of the function that corresponds to this frame.\n[-2] = Actual frame that we correspond to (used to sync exception handling).\n[-1] = Our parent 6-tuple (corresponds to frame.f_back).\n\nTiming data for each function is stored as a 5-tuple in the dictionary\nself.timings[].  The index is always the name stored in self.cur[-3].\nThe following are the definitions of the members:\n\n[0] = The number of times this function was called, not counting direct\n      or indirect recursion,\n[1] = Number of times this function appears on the stack, minus one\n[2] = Total time spent internal to this function\n[3] = Cumulative time that this function was present on the stack.  In\n      non-recursive functions, this is the total execution time from start\n      to finish of each invocation of a function, including time spent in\n      all subfunctions.\n[4] = A dictionary indicating for each function name, the number of times\n      it was called by us.", 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_get_time_resource", 
  "doc": null, 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_time_times", 
  "doc": null, 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating point numbers.\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- write value to a string\nloads() -- read value from a string", 
  "line": 0, 
  "type": "module", 
  "name": "marshal", 
  "file": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "resgetrusage", 
  "doc": null, 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "resource", 
  "file": "/usr/lib/python3.2/lib-dynload/resource.cpython-32mu.so"
 }, 
 {
  "name": "run", 
  "doc": "Run statement under profiler optionally saving results in filename\n\nThis function takes a single argument that can be passed to the\n\"exec\" statement, and an optional file name.  In all cases this\nroutine attempts to \"exec\" its first argument and gather profiling\nstatistics from the execution. If no file name is present, then this\nfunction automatically prints a simple profiling report, sorted by the\nstandard name string (file/line/function-name) that is presented in\neach line.", 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "runctx", 
  "doc": "Run statement under profiler, supplying your own globals and locals,\noptionally saving results in filename.\n\nstatement and filename have the same semantics as profile.run", 
  "module": "profile", 
  "file": "/usr/lib/python3.2/profile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "Stats", 
  "doc": "This class is used for creating reports from data generated by the\nProfile class.  It is a \"friend\" of that class, and imports data either\nby direct access to members of Profile class, or by reading in a dictionary\nthat was emitted (via marshal) from the Profile class.\n\nThe big change from the previous Profiler (in terms of raw functionality)\nis that an \"add()\" method has been provided to combine Stats from\nseveral distinct profile runs.  Both the constructor and the add()\nmethod now take arbitrarily many file names as arguments.\n\nAll the print methods now take an argument that indicates how many lines\nto print.  If the arg is a floating point number between 0 and 1.0, then\nit is taken as a decimal percentage of the available lines to be printed\n(e.g., .1 means print 10% of all available lines).  If it is an integer,\nit is taken to mean the number of lines of data that you wish to have\nprinted.\n\nThe sort_stats() method now processes some additional options (i.e., in\naddition to the old -1, 0, 1, or 2).  It takes an arbitrary number of\nquoted strings to select the sort order.  For example sort_stats('time',\n'name') sorts on the major key of 'internal function time', and on the\nminor key of 'the name of the function'.  Look at the two tables in\nsort_stats() and get_sort_arg_defs(self) for more examples.\n\nAll methods return self, so you can string together commands like:\n    Stats('foo', 'goo').strip_dirs().sort_stats('calls').                            print_stats(5).print_callers(5)", 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TupleComp", 
  "doc": "This class provides a generic function for comparing any two tuples.\nEach instance records a list of tuple-indices (from most significant\nto least significant), and sort direction (ascending or decending) for\neach tuple-index.  The compare functions can then be used as the function\nargument to the system sort() function when a list of tuples need to be\nsorted in the instances order.", 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "add_callers", 
  "doc": "Combine two caller lists in a single list.", 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "add_func_stats", 
  "doc": "Add together all the stats for two profile entries.", 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cmp_to_key", 
  "doc": "Convert a cmp= function into a key= function", 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count_calls", 
  "doc": "Sum the caller statistics to get total number of calls received.", 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "f8", 
  "doc": null, 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "func_get_function_name", 
  "doc": null, 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "func_std_string", 
  "doc": null, 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "func_strip_path", 
  "doc": null, 
  "module": "pstats", 
  "file": "/usr/lib/python3.2/pstats.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating point numbers.\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- write value to a string\nloads() -- read value from a string", 
  "line": 0, 
  "type": "module", 
  "name": "marshal", 
  "file": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "_copy", 
  "doc": "Parent copy loop.\nCopies\n        pty master -> standard output   (master_read)\n        standard input -> pty master    (stdin_read)", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_open_terminal", 
  "doc": "Open pty master and return (master_fd, tty_name).\nSGI and generic BSD version, for when openpty() fails.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_read", 
  "doc": "Default read function.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_writen", 
  "doc": "Write all the data to a descriptor.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fork", 
  "doc": "fork() -> (pid, master_fd)\nFork and make the child a session leader with a controlling terminal.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "master_open", 
  "doc": "master_open() -> (master_fd, slave_name)\nOpen a pty master and return the fd, and the filename of the slave end.\nDeprecated, use openpty() instead.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "openpty", 
  "doc": "openpty() -> (master_fd, slave_fd)\nOpen a pty master/slave pair, using os.openpty() if possible.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "select", 
  "doc": "select(rlist, wlist, xlist[, timeout]) -> (rlist, wlist, xlist)\n\nWait until one or more file descriptors are ready for some kind of I/O.\nThe first three arguments are sequences of file descriptors to be waited for:\nrlist -- wait until ready for reading\nwlist -- wait until ready for writing\nxlist -- wait for an ``exceptional condition''\nIf only one kind of condition is required, pass [] for the other lists.\nA file descriptor is either a socket or file object, or a small integer\ngotten from a fileno() method call on one of those.\n\nThe optional 4th argument specifies a timeout in seconds; it may be\na floating point number to specify fractions of seconds.  If it is absent\nor None, the call will never time out.\n\nThe return value is a tuple of three lists corresponding to the first three\narguments; each contains the subset of the corresponding file descriptors\nthat are ready.\n\n*** IMPORTANT NOTICE ***\nOn Windows and OpenVMS, only sockets are supported; on Unix, all file\ndescriptors can be used.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "slave_open", 
  "doc": "slave_open(tty_name) -> slave_fd\nOpen the pty slave and acquire the controlling terminal, returning\nopened filedescriptor.\nDeprecated, use openpty() instead.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "spawn", 
  "doc": "Create a spawned process.", 
  "module": "pty", 
  "file": "/usr/lib/python3.2/pty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Terminal utilities.", 
  "line": 0, 
  "type": "module", 
  "name": "tty", 
  "file": "/usr/lib/python3.2/tty.py"
 }, 
 {
  "name": "PyCompileError", 
  "doc": "Exception raised when an error occurs while attempting to\ncompile the file.\n\nTo raise this exception, use\n\n    raise PyCompileError(exc_type,exc_value,file[,msg])\n\nwhere\n\n    exc_type:   exception type to be used in error message\n                type name can be accesses as class variable\n                'exc_type_name'\n\n    exc_value:  exception value to be used in error message\n                can be accesses as class variable 'exc_value'\n\n    file:       name of file being compiled to be used in error message\n                can be accesses as class variable 'file'\n\n    msg:        string message to be written as error message\n                If no value is given, a default exception message will be\n                given, consistent with 'standard' py_compile output.\n                message (or default) can be accesses as class variable\n                'msg'", 
  "module": "py_compile", 
  "file": "/usr/lib/python3.2/py_compile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "compile", 
  "doc": "Byte-compile one Python source file to Python bytecode.\n\n:param file: The source file name.\n:param cfile: The target byte compiled file name.  When not given, this\n    defaults to the PEP 3147 location.\n:param dfile: Purported file name, i.e. the file name that shows up in\n    error messages.  Defaults to the source file name.\n:param doraise: Flag indicating whether or not an exception should be\n    raised when a compile error is found.  If an exception occurs and this\n    flag is set to False, a string indicating the nature of the exception\n    will be printed, and the function will return to the caller. If an\n    exception occurs and this flag is set to True, a PyCompileError\n    exception will be raised.\n:param optimize: The optimization level for the compiler.  Valid values\n    are -1, 0, 1 and 2.  A value of -1 means to use the optimization\n    level of the current interpreter, as given by -O command line options.\n\n:return: Path to the resulting byte compiled file.\n\nNote that it isn't necessary to byte-compile Python modules for\nexecution efficiency -- Python itself byte-compiles a module when\nit is loaded, and if it can, writes out the bytecode to the\ncorresponding .pyc (or .pyo) file.\n\nHowever, if a Python installation is shared between users, it is a\ngood idea to byte-compile all modules upon installation, since\nother users may not be able to write in the source directories,\nand thus they won't be able to write the .pyc/.pyo file, and then\nthey would be byte-compiling every module each time it is loaded.\nThis can slow down program start-up considerably.\n\nSee compileall.py for a script/module that uses this module to\nbyte-compile all installed files (or all files in selected\ndirectories).", 
  "module": "py_compile", 
  "file": "/usr/lib/python3.2/py_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "main", 
  "doc": "Compile several source files.\n\nThe files named in 'args' (or on the command line, if 'args' is\nnot specified) are compiled and the resulting bytecode is cached\nin the normal manner.  This function does not search a directory\nstructure to locate source files; it only compiles files named\nexplicitly.  If '-' is the only parameter in args, the list of\nfiles is taken from standard input.", 
  "module": "py_compile", 
  "file": "/usr/lib/python3.2/py_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module contains functions that can read and write Python values in\na binary format. The format is specific to Python, but independent of\nmachine architecture issues.\n\nNot all Python object types are supported; in general, only objects\nwhose value is independent from a particular invocation of Python can be\nwritten and read by this module. The following types are supported:\nNone, integers, floating point numbers, strings, bytes, bytearrays,\ntuples, lists, sets, dictionaries, and code objects, where it\nshould be understood that tuples, lists and dictionaries are only\nsupported as long as the values contained therein are themselves\nsupported; and recursive lists and dictionaries should not be written\n(they will cause infinite loops).\n\nVariables:\n\nversion -- indicates the format that the module uses. Version 0 is the\n    historical format, version 1 shares interned strings and version 2\n    uses a binary format for floating point numbers.\n\nFunctions:\n\ndump() -- write value to a file\nload() -- read value from a file\ndumps() -- write value to a string\nloads() -- read value from a string", 
  "line": 0, 
  "type": "module", 
  "name": "marshal", 
  "file": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "name": "wr_long", 
  "doc": "Internal; write a 32-bit int to a file in little-endian order.", 
  "module": "py_compile", 
  "file": "/usr/lib/python3.2/py_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Class", 
  "doc": "Class to represent a Python class.", 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Function", 
  "doc": "Class to represent a top-level Python function", 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_getname", 
  "doc": null, 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getnamelist", 
  "doc": null, 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_main", 
  "doc": null, 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_readmodule", 
  "doc": "Do the hard work for readmodule[_ex].\n\nIf INPACKAGE is given, it must be the dotted name of the package in\nwhich we are searching for a submodule, and then PATH must be the\npackage search path; otherwise, we are searching for a top-level\nmodule, and PATH is combined with sys.path.", 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "itemgetter", 
  "doc": "itemgetter(item, ...) --> itemgetter object\n\nReturn a callable object that fetches the given item(s) from its operand.\nAfter, f=itemgetter(2), the call f(r) returns r[2].\nAfter, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "readmodule", 
  "doc": "Backwards compatible interface.\n\nCall readmodule_ex() and then only keep Class objects from the\nresulting dictionary.", 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "readmodule_ex", 
  "doc": "Read a module file and return a dictionary of classes.\n\nSearch for MODULE in PATH and sys.path, read and parse the\nmodule and return a dictionary with one entry for each class\nfound in the module.", 
  "module": "pyclbr", 
  "file": "/usr/lib/python3.2/pyclbr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "Doc", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ErrorDuringImport", 
  "doc": "Errors that occurred while trying to import something to document it.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HTMLDoc", 
  "doc": "Formatter class for HTML documentation.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HTMLRepr", 
  "doc": "Class for safely making an HTML representation of a Python object.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Helper", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ModuleScanner", 
  "doc": "An interruptible scanner that searches module synopses.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Repr", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/reprlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Scanner", 
  "doc": "A generic tree iterator.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextDoc", 
  "doc": "Formatter class for text documentation.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextRepr", 
  "doc": "Class for safely making a text representation of a Python object.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_PlainTextDoc", 
  "doc": "Subclass of TextDoc which overrides string styling", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_is_some_method", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_split_list", 
  "doc": "Split sequence s via predicate, and return pair ([true], [false]).\n\nThe return value is a 2-tuple of lists,\n    ([x for x in s if predicate(x)],\n     [x for x in s if not predicate(x)])", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_start_server", 
  "doc": "Start an HTTP server thread on a specific port.\n\nStart an HTML/text server thread, so HTML or text documents can be\nbrowsed dynamically and interactively with a Web browser.  Example use:\n\n    >>> import time\n    >>> import pydoc\n\n    Define a URL handler.  To determine what the client is asking\n    for, check the URL and content_type.\n\n    Then get or generate some text or HTML code and return it.\n\n    >>> def my_url_handler(url, content_type):\n    ...     text = 'the URL sent was: (%s, %s)' % (url, content_type)\n    ...     return text\n\n    Start server thread on port 0.\n    If you use port 0, the server will pick a random port number.\n    You can then use serverthread.port to get the port number.\n\n    >>> port = 0\n    >>> serverthread = pydoc._start_server(my_url_handler, port)\n\n    Check that the server is really started.  If it is, open browser\n    and get first page.  Use serverthread.url as the starting page.\n\n    >>> if serverthread.serving:\n    ...    import webbrowser\n\n    The next two lines are commented out so a browser doesn't open if\n    doctest is run on this module.\n\n    #...    webbrowser.open(serverthread.url)\n    #True\n\n    Let the server do its thing. We just need to monitor its status.\n    Use time.sleep so the loop doesn't hog the CPU.\n\n    >>> starttime = time.time()\n    >>> timeout = 1                    #seconds\n\n    This is a short timeout for testing purposes.\n\n    >>> while serverthread.serving:\n    ...     time.sleep(.01)\n    ...     if serverthread.serving and time.time() - starttime > timeout:\n    ...          serverthread.stop()\n    ...          break\n\n    Print any errors that may have occurred.\n\n    >>> print(serverthread.error)\n    None", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_url_handler", 
  "doc": "The pydoc url handler for use with the pydoc server.\n\nIf the content_type is 'text/css', the _pydoc.css style\nsheet is read and returned if it exits.\n\nIf the content_type is 'text/html', then the result of\nget_html_page(url) is returned.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "allmethods", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "apropos", 
  "doc": "Print all the one-line module summaries that contain a substring.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "browse", 
  "doc": "Start the enhanced pydoc Web server and open a Web browser.\n\nUse port '0' to start the server on an arbitrary port.\nSet open_browser to False to suppress opening a browser.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "classify_class_attrs", 
  "doc": "Wrap inspect.classify_class_attrs, with fixup for data descriptors.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "classname", 
  "doc": "Get a class name and qualify it with a module name if necessary.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cli", 
  "doc": "Command-line interface (looks at sys.argv to decide what to do).", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cram", 
  "doc": "Omit part of a string if needed to make it fit in a maximum length.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "deque", 
  "doc": "deque(iterable[, maxlen]) --> deque object\n\nBuild an ordered collection with optimized access from its endpoints.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "describe", 
  "doc": "Produce a short description of the given thing.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "doc", 
  "doc": "Display text documentation, given an object or a path to an object.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "extract_tb", 
  "doc": "Return list of up to limit pre-processed entries from traceback.\n\nThis is useful for alternate formatting of stack traces.  If\n'limit' is omitted or None, all entries are extracted.  A\npre-processed stack trace entry is a quadruple (filename, line\nnumber, function name, text) representing the information that is\nusually printed for a stack trace.  The text is a string with\nleading and trailing whitespace stripped; if the source is not\navailable it is None.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_exception_only", 
  "doc": "Format the exception part of a traceback.\n\nThe arguments are the exception type and value such as given by\nsys.last_type and sys.last_value. The return value is a list of\nstrings, each ending in a newline.\n\nNormally, the list contains a single string; however, for\nSyntaxError exceptions, it contains several lines that (when\nprinted) display detailed information about where the syntax\nerror occurred.\n\nThe message indicating which exception occurred is always the last\nstring in the list.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getdoc", 
  "doc": "Get the doc string or comments for an object.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpager", 
  "doc": "Decide what method to use for paging through text.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gui", 
  "doc": "Graphical interface (starts Web server and pops up a control window).", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "importfile", 
  "doc": "Import a Python source file or compiled file given its path.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "isdata", 
  "doc": "Check if an object is of a type that probably means it's data.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ispackage", 
  "doc": "Guess whether a path refers to a package directory.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ispath", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "locate", 
  "doc": "Locate an object by name or dotted path, importing as necessary.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "pager", 
  "doc": "The first time this is called, determine what kind of pager to use.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pathdirs", 
  "doc": "Convert sys.path into a list of absolute, existing, unique paths.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pipepager", 
  "doc": "Page through text by feeding it to another program.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Utilities to support packages.", 
  "line": 0, 
  "type": "module", 
  "name": "pkgutil", 
  "file": "/usr/lib/python3.2/pkgutil.py"
 }, 
 {
  "name": "plain", 
  "doc": "Remove boldface formatting from text.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "plainpager", 
  "doc": "Simply print unformatted text.  This is the ultimate fallback.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module tries to retrieve as much platform-identifying data as\npossible. It makes this information available via function APIs.\n\nIf called from the command line, it prints the platform\ninformation concatenated as single string to stdout. The output\nformat is useable as part of a filename.", 
  "line": 0, 
  "type": "module", 
  "name": "platform", 
  "file": "/usr/lib/python3.2/platform.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "render_doc", 
  "doc": "Render text documentation, given an object or a path to an object.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "Do a series of global replacements on a string.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resolve", 
  "doc": "Given an object or a path to an object, get the object and its name.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "safeimport", 
  "doc": "Import a module; handle errors; return None if the module isn't found.\n\nIf the module *is* found but an exception occurs, it's wrapped in an\nErrorDuringImport exception and reraised.  Unlike __import__, if a\npackage path is specified, the module at the end of the path is returned,\nnot the package at the beginning.  If the optional 'forceload' argument\nis 1, we reload the module from disk (unless it's a dynamic extension).", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "serve", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "source_synopsis", 
  "doc": null, 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitdoc", 
  "doc": "Split a doc string into a synopsis line (if any) and the rest.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "stripid", 
  "doc": "Remove the hexadecimal id from a Python object representation.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "synopsis", 
  "doc": "Get the one-line summary out of a module file.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "tempfilepager", 
  "doc": "Page through text by invoking a program on a temporary file.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "ttypager", 
  "doc": "Page through text on a text terminal.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "visiblename", 
  "doc": "Decide whether to show documentation on a variable.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "writedoc", 
  "doc": "Write HTML documentation to a file in the current directory.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "writedocs", 
  "doc": "Write out HTML documentation for all modules in a directory tree.", 
  "module": "pydoc", 
  "file": "/usr/lib/python3.2/pydoc.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "a2b_qp", 
  "doc": "Decode a string of qp-encoded data", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "b2a_qp", 
  "doc": "b2a_qp(data, quotetabs=0, istext=1, header=0) -> s; \n Encode a string using quoted-printable encoding. \n\nOn encoding, when istext is set, newlines are not encoded, and white \nspace at end of lines is.  When istext is not set, \\r and \\n (CR/LF) are \nboth encoded.  When quotetabs is set, space and tabs are encoded.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decode", 
  "doc": "Read 'input', apply quoted-printable decoding, and write to 'output'.\n'input' and 'output' are files with readline() and write() methods.\nIf 'header' is true, decode underscore as space (per RFC 1522).", 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decodestring", 
  "doc": null, 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "Read 'input', apply quoted-printable encoding, and write to 'output'.\n\n'input' and 'output' are files with readline() and write() methods.\nThe 'quotetabs' flag indicates whether embedded tabs and spaces should be\nquoted.  Note that line-ending tabs and spaces are always encoded, as per\nRFC 1521.\nThe 'header' flag indicates whether we are encoding spaces as _ as per\nRFC 1522.", 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encodestring", 
  "doc": null, 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ishex", 
  "doc": "Return true if the byte ordinal 'c' is a hexadecimal digit in ASCII.", 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "needsquoting", 
  "doc": "Decide whether a particular byte ordinal needs to be quoted.\n\nThe 'quotetabs' flag indicates whether embedded tabs and spaces should be\nquoted.  Note that line-ending tabs and spaces are always encoded, as per\nRFC 1521.", 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "quote", 
  "doc": "Quote a single character.", 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unhex", 
  "doc": "Get the integer value of a hexadecimal number.", 
  "module": "quopri", 
  "file": "/usr/lib/python3.2/quopri.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Random", 
  "doc": "Random number generator base class used by bound module functions.\n\nUsed to instantiate instances of Random to get generators that don't\nshare state.\n\nClass Random can also be subclassed if you want to use a different basic\ngenerator of your own devising: in that case, override the following\nmethods:  random(), seed(), getstate(), and setstate().\nOptionally, implement a getrandbits() method so that randrange()\ncan cover arbitrarily large ranges.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SystemRandom", 
  "doc": "Alternate random number generator using sources provided\nby the operating system (such as /dev/urandom on Unix or\nCryptGenRandom on Windows).\n\n Not available on all systems (see os.urandom() for details).", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_BuiltinMethodType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_MethodType", 
  "doc": "method(function, instance)\n\nCreate a bound instance method object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Sequence", 
  "doc": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Set", 
  "doc": "A set is a finite, iterable container.\n\nThis class provides concrete generic implementations of all\nmethods except for __contains__, __iter__ and __len__.\n\nTo override the comparisons (presumably for speed, as the\nsemantics are fixed), all you have to do is redefine __le__ and\nthen the other operations will automatically follow suit.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/_abcoll.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_acos", 
  "doc": "acos(x)\n\nReturn the arc cosine (measured in radians) of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ceil", 
  "doc": "ceil(x)\n\nReturn the ceiling of x as an int.\nThis is the smallest integral value >= x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_cos", 
  "doc": "cos(x)\n\nReturn the cosine of x (measured in radians).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_exp", 
  "doc": "exp(x)\n\nReturn e raised to the power of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_log", 
  "doc": "log(x[, base])\n\nReturn the logarithm of x to the given base.\nIf the base not specified, returns the natural logarithm (base e) of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Module implements the Mersenne Twister random number generator.", 
  "line": 0, 
  "type": "module", 
  "name": "_random", 
  "file": null
 }, 
 {
  "name": "_sha512", 
  "doc": "Returns a sha512 hash object; optionally initialized with a string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_sin", 
  "doc": "sin(x)\n\nReturn the sine of x (measured in radians).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_sqrt", 
  "doc": "sqrt(x)\n\nReturn the square root of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test", 
  "doc": null, 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test_generator", 
  "doc": null, 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_urandom", 
  "doc": "urandom(n) -> str\n\nReturn n random bytes suitable for cryptographic use.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_warn", 
  "doc": "Issue a warning, or maybe ignore it or raise an exception.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "betavariate", 
  "doc": "Beta distribution.\n\nConditions on the parameters are alpha > 0 and beta > 0.\nReturned values range between 0 and 1.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "choice", 
  "doc": "Choose a random element from a non-empty sequence.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expovariate", 
  "doc": "Exponential distribution.\n\nlambd is 1.0 divided by the desired mean.  It should be\nnonzero.  (The parameter would be called \"lambda\", but that is\na reserved word in Python.)  Returned values range from 0 to\npositive infinity if lambd is positive, and from negative\ninfinity to 0 if lambd is negative.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gammavariate", 
  "doc": "Gamma distribution.  Not the gamma function!\n\nConditions on the parameters are alpha > 0 and beta > 0.\n\nThe probability distribution function is:\n\n            x ** (alpha - 1) * math.exp(-x / beta)\n  pdf(x) =  --------------------------------------\n              math.gamma(alpha) * beta ** alpha", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gauss", 
  "doc": "Gaussian distribution.\n\nmu is the mean, and sigma is the standard deviation.  This is\nslightly faster than the normalvariate() function.\n\nNot thread-safe without a lock around calls.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getrandbits", 
  "doc": "getrandbits(k) -> x.  Generates a long int with k random bits.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getstate", 
  "doc": "Return internal state; can be passed to setstate() later.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lognormvariate", 
  "doc": "Log normal distribution.\n\nIf you take the natural logarithm of this distribution, you'll get a\nnormal distribution with mean mu and standard deviation sigma.\nmu can have any value, and sigma must be greater than zero.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "normalvariate", 
  "doc": "Normal distribution.\n\nmu is the mean, and sigma is the standard deviation.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "paretovariate", 
  "doc": "Pareto distribution.  alpha is the shape parameter.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "randint", 
  "doc": "Return random integer in range [a, b], including both end points.\n        ", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "random", 
  "doc": "random() -> x in the interval [0, 1).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "randrange", 
  "doc": "Choose a random item from range(start, stop[, step]).\n\nThis fixes the problem with randint() which includes the\nendpoint; in Python this is usually not what you want.\n\nDo not supply the 'int' argument.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sample", 
  "doc": "Chooses k unique random elements from a population sequence or set.\n\nReturns a new list containing elements from the population while\nleaving the original population unchanged.  The resulting list is\nin selection order so that all sub-slices will also be valid random\nsamples.  This allows raffle winners (the sample) to be partitioned\ninto grand prize and second place winners (the subslices).\n\nMembers of the population need not be hashable or unique.  If the\npopulation contains repeats, then each occurrence is a possible\nselection in the sample.\n\nTo choose a sample in a range of integers, use range as an argument.\nThis is especially fast and space efficient for sampling from a\nlarge population:   sample(range(10000000), 60)", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "seed", 
  "doc": "Initialize internal state from hashable object.\n\nNone or no argument seeds from current time or from an operating\nsystem specific randomness source if available.\n\nFor version 2 (the default), all of the bits are used if *a *is a str,\nbytes, or bytearray.  For version 1, the hash() of *a* is used instead.\n\nIf *a* is an int, all bits are used.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setstate", 
  "doc": "Restore internal state from object returned by getstate().", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "shuffle", 
  "doc": "x, random=random.random -> shuffle list x in place; return None.\n\nOptional arg random is a 0-argument function returning a random\nfloat in [0.0, 1.0); by default, the standard random.random.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "triangular", 
  "doc": "Triangular distribution.\n\nContinuous distribution bounded by given lower and upper limits,\nand having a given mode value in-between.\n\nhttp://en.wikipedia.org/wiki/Triangular_distribution", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "uniform", 
  "doc": "Get a random number in the range [a, b) or [a, b] depending on rounding.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "vonmisesvariate", 
  "doc": "Circular data distribution.\n\nmu is the mean angle, expressed in radians between 0 and 2*pi, and\nkappa is the concentration parameter, which must be greater than or\nequal to zero.  If kappa is equal to zero, this distribution reduces\nto a uniform random angle over the range 0 to 2*pi.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "weibullvariate", 
  "doc": "Weibull distribution.\n\nalpha is the scale parameter and beta is the shape parameter.", 
  "module": "random", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Scanner", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_compile", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_compile_repl", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_compile_typed", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/functools.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_expand", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_pattern_type", 
  "doc": "Compiled regular expression objects", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_pickle", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_subx", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compile", 
  "doc": "Compile a regular expression pattern, returning a pattern object.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Helper to provide extensibility for pickle.\n\nThis is only useful to add pickle support for extension types defined in\nC, not for instances of user-defined classes.", 
  "line": 0, 
  "type": "module", 
  "name": "copyreg", 
  "file": "/usr/lib/python3.2/copyreg.py"
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "re", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "escape", 
  "doc": "Escape all non-alphanumeric characters in pattern.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findall", 
  "doc": "Return a list of all non-overlapping matches in the string.\n\nIf one or more groups are present in the pattern, return a\nlist of groups; this will be a list of tuples if the pattern\nhas more than one group.\n\nEmpty matches are included in the result.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "finditer", 
  "doc": "Return an iterator over all non-overlapping matches in the\nstring.  For each match, the iterator returns a match object.\n\nEmpty matches are included in the result.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "functools.py - Tools for working with functions and callable objects", 
  "line": 0, 
  "type": "module", 
  "name": "functools", 
  "file": "/usr/lib/python3.2/functools.py"
 }, 
 {
  "name": "match", 
  "doc": "Try to apply the pattern at the start of the string, returning\na match object, or None if no match was found.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "purge", 
  "doc": "Clear the regular expression caches", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "search", 
  "doc": "Scan through string looking for a match to the pattern, returning\na match object, or None if no match was found.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "Split the source string by the occurrences of the pattern,\nreturning a list containing the resulting substrings.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Internal support module for sre", 
  "line": 0, 
  "type": "module", 
  "name": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py"
 }, 
 {
  "doc": "Internal support module for sre", 
  "line": 0, 
  "type": "module", 
  "name": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py"
 }, 
 {
  "name": "sub", 
  "doc": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the match object and must return\na replacement string to be used.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "subn", 
  "doc": "Return a 2-tuple containing (new_string, number).\nnew_string is the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in the source\nstring by the replacement repl.  number is the number of\nsubstitutions that were made. repl can be either a string or a\ncallable; if a string, backslash escapes in it are processed.\nIf it is a callable, it's passed the match object and must\nreturn a replacement string to be used.", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "template", 
  "doc": "Compile a template pattern, returning a pattern object", 
  "module": "re", 
  "file": "/usr/lib/python3.2/re.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Completer", 
  "doc": null, 
  "module": "rlcompleter", 
  "file": "/usr/lib/python3.2/rlcompleter.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Get members and documentation info about all known python modules.\n\nIf called as a script the data is written in JSON format to the given file\nso it's usable externally.\n\nWe get info and docs for modules, classes, functions.\n\nWe rely on the inspect module (loads the modules to get info !)", 
  "line": 0, 
  "type": "module", 
  "name": "__main__", 
  "file": "/home/tcolar/DEV/projects/perso/camembert/plugins/python/python/docinfo.py"
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "get_class_members", 
  "doc": null, 
  "module": "rlcompleter", 
  "file": "/usr/lib/python3.2/rlcompleter.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Importing this module enables command line editing using GNU readline.", 
  "line": 0, 
  "type": "module", 
  "name": "readline", 
  "file": "/usr/lib/python3.2/lib-dynload/readline.cpython-32mu.so"
 }, 
 {
  "name": "_ModifiedArgv0", 
  "doc": null, 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_TempModule", 
  "doc": "Temporarily replace a module in sys.modules with an empty namespace", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_get_code_from_file", 
  "doc": null, 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_filename", 
  "doc": null, 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_importer", 
  "doc": "Python version of PyImport_GetImporter C API function", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_main_module_details", 
  "doc": null, 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_module_details", 
  "doc": null, 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_run_code", 
  "doc": "Helper to run code in nominated namespace", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_run_module_as_main", 
  "doc": "Runs the designated module in the __main__ namespace\n\nNote that the executed module will have full access to the\n__main__ namespace. If this is not desirable, the run_module()\nfunction should be used to run the module code in a fresh namespace.\n\nAt the very least, these variables in __main__ will be overwritten:\n    __name__\n    __file__\n    __cached__\n    __loader__\n    __package__", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_run_module_code", 
  "doc": "Helper to run code in new namespace with sys modified", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_loader", 
  "doc": "Get a PEP 302 \"loader\" object for module_or_name\n\nIf the module or package is accessible via the normal import\nmechanism, a wrapper around the relevant part of that machinery\nis returned.  Returns None if the module cannot be found or imported.\nIf the named module is not already imported, its containing package\n(if any) is imported, in order to establish the package __path__.\n\nThis function uses iter_importers(), and is thus subject to the same\nlimitations regarding platform-specific special import locations such\nas the Windows registry.", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "name": "read_code", 
  "doc": null, 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/pkgutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "run_module", 
  "doc": "Execute a module's code without importing it\n\nReturns the resulting top level namespace dictionary", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "run_path", 
  "doc": "Execute code located at the specified filesystem location\n\nReturns the resulting top level namespace dictionary\n\nThe file path may refer directly to a Python script (i.e.\none that could be directly executed with execfile) or else\nit may refer to a zipfile or directory containing a top\nlevel __main__.py script.", 
  "module": "runpy", 
  "file": "/usr/lib/python3.2/runpy.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "Event", 
  "doc": null, 
  "module": "sched", 
  "file": "/usr/lib/python3.2/sched.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!", 
  "line": 0, 
  "type": "module", 
  "name": "heapq", 
  "file": "/usr/lib/python3.2/heapq.py"
 }, 
 {
  "name": "namedtuple", 
  "doc": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessable by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)", 
  "module": "sched", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "scheduler", 
  "doc": null, 
  "module": "sched", 
  "file": "/usr/lib/python3.2/sched.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BsdDbShelf", 
  "doc": "Shelf implementation using the \"BSD\" db interface.\n\nThis adds methods first(), next(), previous(), last() and\nset_location() that have no counterpart in [g]dbm databases.\n\nThe actual database must be opened using one of the \"bsddb\"\nmodules \"open\" routines (i.e. bsddb.hashopen, bsddb.btopen or\nbsddb.rnopen) and passed to the constructor.\n\nSee the module's __doc__ string for an overview of the interface.", 
  "module": "shelve", 
  "file": "/usr/lib/python3.2/shelve.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BytesIO", 
  "doc": "BytesIO([buffer]) -> object\n\nCreate a buffered I/O implementation using an in-memory bytes\nbuffer, ready for reading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DbfilenameShelf", 
  "doc": "Shelf implementation using the \"dbm\" generic dbm interface.\n\nThis is initialized with the filename for the dbm database.\nSee the module's __doc__ string for an overview of the interface.", 
  "module": "shelve", 
  "file": "/usr/lib/python3.2/shelve.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Pickler", 
  "doc": "Pickler(file, protocol=None)\nThis takes a binary file for writing a pickle data stream.\n\nThe optional protocol argument tells the pickler to use the\ngiven protocol; supported protocols are 0, 1, 2, 3.  The default\nprotocol is 3; a backward-incompatible protocol designed for\nPython 3.0.\n\nSpecifying a negative protocol version selects the highest\nprotocol version supported.  The higher the protocol used, the\nmore recent the version of Python needed to read the pickle\nproduced.\n\nThe file argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, a io.BytesIO instance, or any other custom object that\nmeets this interface.\n\nIf fix_imports is True and protocol is less than 3, pickle will try to\nmap the new Python 3.x names to the old module names used in Python\n2.x, so that the pickle data stream is readable with Python 2.x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Shelf", 
  "doc": "Base class for shelf implementations.\n\nThis is initialized with a dictionary-like object.\nSee the module's __doc__ string for an overview of the interface.", 
  "module": "shelve", 
  "file": "/usr/lib/python3.2/shelve.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Unpickler", 
  "doc": "Unpickler(file, *, encoding='ASCII', errors='strict')\nThis takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nproto argument is needed.\n\nThe file-like object must have two methods, a read() method\nthat takes an integer argument, and a readline() method that\nrequires no arguments.  Both methods should return bytes.\nThus file-like object can be a binary file object opened for\nreading, a BytesIO object, or any other custom object that\nmeets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatiblity support for pickle stream\ngenerated by Python 2.x.  If *fix_imports* is True, pickle will try to\nmap the old Python 2.x names to the new names used in Python 3.x.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2.x; these default to 'ASCII' and\n'strict', respectively.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_ClosedDict", 
  "doc": "Marker for a closed dict.  Access attempts raise a ValueError.", 
  "module": "shelve", 
  "file": "/usr/lib/python3.2/shelve.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "name": "open", 
  "doc": "Open a persistent dictionary for reading and writing.\n\nThe filename parameter is the base filename for the underlying\ndatabase.  As a side-effect, an extension may be added to the\nfilename and more than one file may be created.  The optional flag\nparameter has the same interpretation as the flag parameter of\ndbm.open(). The optional protocol parameter specifies the\nversion of the pickle protocol (0, 1, or 2).\n\nSee the module's __doc__ string for an overview of the interface.", 
  "module": "shelve", 
  "file": "/usr/lib/python3.2/shelve.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "StringIO", 
  "doc": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "deque", 
  "doc": "deque(iterable[, maxlen]) --> deque object\n\nBuild an ordered collection with optimized access from its endpoints.", 
  "module": "shlex", 
  "file": "/usr/lib/python3.2/collections.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "shlex", 
  "doc": "A lexical analyzer class for simple shell-like syntaxes.", 
  "module": "shlex", 
  "file": "/usr/lib/python3.2/shlex.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": null, 
  "module": "shlex", 
  "file": "/usr/lib/python3.2/shlex.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ExecError", 
  "doc": "Raised when a command could not be executed", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ReadError", 
  "doc": "Raised when an archive cannot be read", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RegistryError", 
  "doc": "Raised when a registery operation with the archiving\nand unpacking registeries fails", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SpecialFileError", 
  "doc": "Raised when trying to do a kind of operation (e.g. copying) which is\nnot supported on a special file (e.g. a named pipe)", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_basename", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_call_external_zip", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_check_unpack_options", 
  "doc": "Checks what gets registered as an unpacker.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_destinsrc", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ensure_directory", 
  "doc": "Ensure that the parent directory of `path` exists", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_find_unpack_format", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_gid", 
  "doc": "Returns a gid, given a group name.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_uid", 
  "doc": "Returns an uid, given a user name.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_make_tarball", 
  "doc": "Create a (possibly compressed) tar file from all the files under\n'base_dir'.\n\n'compress' must be \"gzip\" (the default), \"bzip2\", or None.\n\n'owner' and 'group' can be used to define an owner and a group for the\narchive that is being built. If not provided, the current owner and group\nwill be used.\n\nThe output tar file will be named 'base_name' +  \".tar\", possibly plus\nthe appropriate compression extension (\".gz\", or \".bz2\").\n\nReturns the output filename.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_make_zipfile", 
  "doc": "Create a zip file from all the files under 'base_dir'.\n\nThe output zip file will be named 'base_name' + \".zip\".  Uses either the\n\"zipfile\" Python module (if available) or the InfoZIP \"zip\" utility\n(if installed and found on the default search path).  If neither tool is\navailable, raises ExecError.  Returns the name of the output zip\nfile.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_samefile", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unpack_tarfile", 
  "doc": "Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir`\n    ", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unpack_zipfile", 
  "doc": "Unpack zip `filename` to `extract_dir`\n    ", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abspath", 
  "doc": "Return an absolute path.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The python bz2 module provides a comprehensive interface for\nthe bz2 compression library. It implements a complete file\ninterface, one shot (de)compression functions, and types for\nsequential (de)compression.", 
  "line": 0, 
  "type": "module", 
  "name": "bz2", 
  "file": "/usr/lib/python3.2/lib-dynload/bz2.cpython-32mu.so"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "name": "copy", 
  "doc": "Copy data and mode bits (\"cp src dst\").\n\nThe destination may be a directory.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "copy2", 
  "doc": "Copy data and all stat info (\"cp -p src dst\").\n\nThe destination may be a directory.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "copyfile", 
  "doc": "Copy data from src to dst", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "copyfileobj", 
  "doc": "copy data from file-like object fsrc to file-like object fdst", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "copymode", 
  "doc": "Copy mode bits from src to dst", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "copystat", 
  "doc": "Copy all stat info (mode bits, atime, mtime, flags) from src to dst", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "copytree", 
  "doc": "Recursively copy a directory tree.\n\nThe destination directory must not already exist.\nIf exception(s) occur, an Error is raised with a list of reasons.\n\nIf the optional symlinks flag is true, symbolic links in the\nsource tree result in symbolic links in the destination tree; if\nit is false, the contents of the files pointed to by symbolic\nlinks are copied. If the file pointed by the symlink doesn't\nexist, an exception will be added in the list of errors raised in\nan Error exception at the end of the copy process.\n\nYou can set the optional ignore_dangling_symlinks flag to true if you\nwant to silence this exception. Notice that this has no effect on\nplatforms that don't support os.symlink.\n\nThe optional ignore argument is a callable. If given, it\nis called with the `src` parameter, which is the directory\nbeing visited by copytree(), and `names` which is the list of\n`src` contents, as returned by os.listdir():\n\n    callable(src, names) -> ignored_names\n\nSince copytree() is called recursively, the callable will be\ncalled once for each directory that is copied. It returns a\nlist of names relative to the `src` directory that should\nnot be copied.\n\nThe optional copy_function argument is a callable that will be used\nto copy each file. It will be called with the source path and the\ndestination path as arguments. By default, copy2() is used, but any\nfunction that supports the same signature (like copy()) can be used.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "Filename matching with shell patterns.\n\nfnmatch(FILENAME, PATTERN) matches according to the local convention.\nfnmatchcase(FILENAME, PATTERN) always takes case in account.\n\nThe functions operate by translating the pattern into a regular\nexpression.  They cache the compiled regular expressions for speed.\n\nThe function translate(PATTERN) returns a regular expression\ncorresponding to PATTERN.  (It does not compile it.)", 
  "line": 0, 
  "type": "module", 
  "name": "fnmatch", 
  "file": "/usr/lib/python3.2/fnmatch.py"
 }, 
 {
  "name": "get_archive_formats", 
  "doc": "Returns a list of supported formats for archiving and unarchiving.\n\nEach element of the returned sequence is a tuple (name, description)", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_unpack_formats", 
  "doc": "Returns a list of supported formats for unpacking.\n\nEach element of the returned sequence is a tuple\n(name, extensions, description)", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getgrnam", 
  "doc": "getgrnam(name) -> tuple\nReturn the group database entry for the given group name.  If\nname is not valid, raise KeyError.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getpwnam", 
  "doc": "getpwnam(name) -> (pw_name,pw_passwd,pw_uid,\n                    pw_gid,pw_gecos,pw_dir,pw_shell)\nReturn the password database entry for the given user name.\nSee help(pwd) for more on password database entries.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ignore_patterns", 
  "doc": "Function that can be used as copytree() ignore parameter.\n\nPatterns is a sequence of glob-style patterns\nthat are used to exclude files", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "make_archive", 
  "doc": "Create an archive file (eg. zip or tar).\n\n'base_name' is the name of the file to create, minus any format-specific\nextension; 'format' is the archive format: one of \"zip\", \"tar\", \"bztar\"\nor \"gztar\".\n\n'root_dir' is a directory that will be the root directory of the\narchive; ie. we typically chdir into 'root_dir' before creating the\narchive.  'base_dir' is the directory where we start archiving from;\nie. 'base_dir' will be the common prefix of all files and\ndirectories in the archive.  'root_dir' and 'base_dir' both default\nto the current directory.  Returns the name of the archive file.\n\n'owner' and 'group' are used when creating a tar archive. By default,\nuses the current owner and group.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "move", 
  "doc": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command.\n\nIf the destination is a directory or a symlink to a directory, the source\nis moved inside the directory. The destination path must not already\nexist.\n\nIf the destination already exists but is not a directory, it may be\noverwritten depending on os.rename() semantics.\n\nIf the destination is on our current filesystem, then rename() is used.\nOtherwise, src is copied to the destination and then removed.\nA lot more could be done here...  A look at a mv.c shows a lot of\nthe issues this implementation glosses over.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "register_archive_format", 
  "doc": "Registers an archive format.\n\nname is the name of the format. function is the callable that will be\nused to create archives. If provided, extra_args is a sequence of\n(name, value) tuples that will be passed as arguments to the callable.\ndescription can be provided to describe the format, and will be returned\nby the get_archive_formats() function.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_unpack_format", 
  "doc": "Registers an unpack format.\n\n`name` is the name of the format. `extensions` is a list of extensions\ncorresponding to the format.\n\n`function` is the callable that will be\nused to unpack archives. The callable will receive archives to unpack.\nIf it's unable to handle an archive, it needs to raise a ReadError\nexception.\n\nIf provided, `extra_args` is a sequence of\n(name, value) tuples that will be passed as arguments to the callable.\ndescription can be provided to describe the format, and will be returned\nby the get_unpack_formats() function.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rmtree", 
  "doc": "Recursively delete a directory tree.\n\nIf ignore_errors is set, errors are ignored; otherwise, if onerror\nis set, it is called to handle the error with arguments (func,\npath, exc_info) where func is os.listdir, os.remove, or os.rmdir;\npath is the argument to that function that caused it to fail; and\nexc_info is a tuple returned by sys.exc_info().  If ignore_errors\nis false and onerror is None, an exception is raised.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Read from and write to tar format archives.", 
  "line": 0, 
  "type": "module", 
  "name": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py"
 }, 
 {
  "name": "unpack_archive", 
  "doc": "Unpack an archive.\n\n`filename` is the name of the archive.\n\n`extract_dir` is the name of the target directory, where the archive\nis unpacked. If not provided, the current working directory is used.\n\n`format` is the archive format: one of \"zip\", \"tar\", or \"gztar\". Or any\nother registered format. If not provided, unpack_archive will use the\nfilename extension and see if an unpacker was registered for that\nextension.\n\nIn case none is found, a ValueError is raised.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unregister_archive_format", 
  "doc": null, 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unregister_unpack_format", 
  "doc": "Removes the pack format from the registery.", 
  "module": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_Helper", 
  "doc": "Define the builtin 'help'.\nThis is a wrapper around pydoc.help (with a twist).", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Printer", 
  "doc": "interactive prompt objects for printing the license text, a list of\ncontributors and the copyright notice.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_init_pathinfo", 
  "doc": "Return a set containing all existing directory entries from sys.path", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_script", 
  "doc": null, 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "abs_paths", 
  "doc": "Set all module __file__ and __cached__ attributes to an absolute path", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "addpackage", 
  "doc": "Process a .pth file within the site-packages directory:\nFor each line in the file, either combine it with sitedir to a path\nand add that to known_paths, or execute it if it starts with 'import '.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "addsitedir", 
  "doc": "Add 'sitedir' argument to sys.path if missing and handle .pth files in\n'sitedir'", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "addsitepackages", 
  "doc": "Add site-packages (and possibly site-python) to sys.path", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "addusersitepackages", 
  "doc": "Add a per user site-package to sys.path\n\nEach user has its own python directory with site-packages in the\nhome directory.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "aliasmbcs", 
  "doc": "On Windows, some default encodings are not provided by Python,\nwhile they are always available as \"mbcs\" in each locale. Make\nthem usable by aliasing to \"mbcs\" in such a case.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "check_enableusersite", 
  "doc": "Check if user site directory is safe for inclusion\n\nThe function tests for the command line flag (including environment var),\nprocess uid/gid equal to effective uid/gid.\n\nNone: Disabled for security reasons\nFalse: Disabled by user (command line option)\nTrue: Safe and enabled", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execsitecustomize", 
  "doc": "Run custom site specific code, if available.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "execusercustomize", 
  "doc": "Run custom user specific code, if available.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsitepackages", 
  "doc": "Returns a list containing all global site-packages directories\n(and possibly site-python).\n\nFor each directory present in the global ``PREFIXES``, this function\nwill find its `site-packages` subdirectory depending on the system\nenvironment, and will return a list of full paths.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getuserbase", 
  "doc": "Returns the `user base` directory path.\n\nThe `user base` directory can be used to store data. If the global\nvariable ``USER_BASE`` is not initialized yet, this function will also set\nit.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getusersitepackages", 
  "doc": "Returns the user-specific site-packages directory path.\n\nIf the global variable ``USER_SITE`` is not initialized yet, this\nfunction will also set it.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "makepath", 
  "doc": null, 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "removeduppaths", 
  "doc": "Remove duplicate entries from sys.path along with making them\nabsolute", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setBEGINLIBPATH", 
  "doc": "The OS/2 EMX port has optional extension modules that do double duty\nas DLLs (and must use the .DLL file extension) for other extensions.\nThe library search path needs to be amended so these will be found\nduring module import.  Use BEGINLIBPATH so that these are at the start\nof the library search path.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setcopyright", 
  "doc": "Set 'copyright' and 'credits' in builtins", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sethelper", 
  "doc": null, 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setquit", 
  "doc": "Define new builtins 'quit' and 'exit'.\n\nThese are objects which make the interpreter exit when called.\nThe repr of each object contains a hint at how it works.", 
  "module": "site", 
  "file": "/usr/lib/python3.2/site.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "name": "DebuggingServer", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Devnull", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MailmanProxy", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Options", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PureProxy", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPChannel", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPServer", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "A class supporting chat-style (command/response) protocols.\n\nThis class adds support for 'chat' style protocols - where one side\nsends a 'command', and the other sends a response (examples would be\nthe common internet protocols - smtp, nntp, ftp, etc..).\n\nThe handle_read() method looks at the input stream for the current\n'terminator' (usually '\\r\\n' for single-line responses, '\\r\\n.\\r\\n'\nfor multi-line output), calling self.found_terminator() on its\nreceipt.\n\nfor example:\nSay you build an async nntp client using this class.  At the start\nof the connection, you'll have self.terminator set to '\\r\\n', in\norder to process the single-line greeting.  Just before issuing a\n'LIST' command you'll set it to '\\r\\n.\\r\\n'.  The output of the LIST\ncommand will be accumulated (using your own 'collect_incoming_data'\nmethod) up to the terminator, and then control will be returned to\nyou - by calling your self.found_terminator() method.", 
  "line": 0, 
  "type": "module", 
  "name": "asynchat", 
  "file": "/usr/lib/python3.2/asynchat.py"
 }, 
 {
  "doc": "Basic infrastructure for asynchronous socket service clients and servers.\n\nThere are only two ways to have a program on a single processor do \"more\nthan one thing at a time\".  Multi-threaded programming is the simplest and\nmost popular way to do it, but there is another very different technique,\nthat lets you have nearly all the advantages of multi-threading, without\nactually using multiple threads. it's really only practical if your program\nis largely I/O bound. If your program is CPU bound, then pre-emptive\nscheduled threads are probably what you really need. Network servers are\nrarely CPU-bound, however.\n\nIf your operating system supports the select() system call in its I/O\nlibrary (and nearly all do), then you can use it to juggle multiple\ncommunication channels at once; doing other work while your I/O is taking\nplace in the \"background.\"  Although this strategy can seem strange and\ncomplex, especially at first, it is in many ways easier to understand and\ncontrol than multi-threaded programming. The module documented here solves\nmany of the difficult problems for you, making the task of building\nsophisticated high-performance network servers and clients a snap.", 
  "line": 0, 
  "type": "module", 
  "name": "asyncore", 
  "file": "/usr/lib/python3.2/asyncore.py"
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "Parser for command line options.\n\nThis module helps scripts to parse the command line arguments in\nsys.argv.  It supports the same conventions as the Unix getopt()\nfunction (including the special meanings of arguments of the form `-'\nand `--').  Long options similar to those supported by GNU software\nmay be used as well via an optional third argument.  This module\nprovides two functions and an exception:\n\ngetopt() -- Parse command line options\ngnu_getopt() -- Like getopt(), but allow option and non-option arguments\nto be intermixed.\nGetoptError -- exception (class) raised with 'opt' attribute, which is the\noption involved with the exception.", 
  "line": 0, 
  "type": "module", 
  "name": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py"
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "parseargs", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "usage", 
  "doc": null, 
  "module": "smtpd", 
  "file": "/usr/lib/python3.2/smtpd.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "warn", 
  "doc": "Issue a warning, or maybe ignore it or raise an exception.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "LMTP", 
  "doc": "LMTP - Local Mail Transfer Protocol\n\nThe LMTP protocol, which is very similar to ESMTP, is heavily based\non the standard SMTP client. It's common to use Unix sockets for LMTP,\nso our connect() method must support that as well as a regular\nhost:port server. To specify a Unix socket, you must use an absolute\npath as the host, starting with a '/'.\n\nAuthentication is supported, using the regular SMTP mechanism. When\nusing a Unix socket, LMTP generally don't support or require any\nauthentication, but your mileage might vary.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTP", 
  "doc": "This class manages a connection to an SMTP or ESMTP server.\nSMTP Objects:\n    SMTP objects have the following attributes:\n        helo_resp\n            This is the message given by the server in response to the\n            most recent HELO command.\n\n        ehlo_resp\n            This is the message given by the server in response to the\n            most recent EHLO command. This is usually multiline.\n\n        does_esmtp\n            This is a True value _after you do an EHLO command_, if the\n            server supports ESMTP.\n\n        esmtp_features\n            This is a dictionary, which, if the server supports ESMTP,\n            will _after you do an EHLO command_, contain the names of the\n            SMTP service extensions this server supports, and their\n            parameters (if any).\n\n            Note, all extension names are mapped to lower case in the\n            dictionary.\n\n    See each method's docstrings for details.  In general, there is a\n    method of the same name to perform each SMTP command.  There is also a\n    method called 'sendmail' that will do an entire mail transaction.\n    ", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPAuthenticationError", 
  "doc": "Authentication error.\n\nMost probably the server didn't accept the username/password\ncombination provided.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPConnectError", 
  "doc": "Error during connection establishment.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPDataError", 
  "doc": "The SMTP server didn't accept the data.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPException", 
  "doc": "Base class for all exceptions raised by this module.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPHeloError", 
  "doc": "The server refused our HELO reply.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPRecipientsRefused", 
  "doc": "All recipient addresses refused.\n\nThe errors for each recipient are accessible through the attribute\n'recipients', which is a dictionary of exactly the same sort as\nSMTP.sendmail() returns.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPResponseException", 
  "doc": "Base class for all exceptions that include an SMTP error code.\n\nThese exceptions are generated in some instances when the SMTP\nserver returns an error code.  The error code is stored in the\n`smtp_code' attribute of the error, and the `smtp_error' attribute\nis set to the error message.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPSenderRefused", 
  "doc": "Sender address refused.\n\nIn addition to the attributes set by on all SMTPResponseException\nexceptions, this sets `sender' to the string that the SMTP refused.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTPServerDisconnected", 
  "doc": "Not connected to any SMTP server.\n\nThis exception is raised when the server unexpectedly disconnects,\nor when an attempt is made to use the SMTP instance before\nconnecting it to a server.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SMTP_SSL", 
  "doc": "This is a subclass derived from SMTP that connects over an SSL encrypted\nsocket (to use this class you need a socket module that was compiled with SSL\nsupport). If host is not specified, '' (the local host) is used. If port is\nomitted, the standard SMTP-over-SSL port (465) is used. keyfile and certfile\nare also optional - they can contain a PEM formatted private key and\ncertificate chain file for the SSL connection.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SSLFakeFile", 
  "doc": "A fake file like object that really wraps a SSLObject.\n\nIt only supports what is needed in smtplib.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_addr_only", 
  "doc": null, 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_fix_eols", 
  "doc": null, 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_quote_periods", 
  "doc": null, 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "RFC 3548: Base16, Base32, Base64 Data Encodings", 
  "line": 0, 
  "type": "module", 
  "name": "base64", 
  "file": "/usr/lib/python3.2/base64.py"
 }, 
 {
  "doc": "Generic (shallow and deep) copying operations.\n\nInterface summary:\n\n        import copy\n\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\n\nFor module specific errors, copy.Error is raised.\n\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\n\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\n\nPython's deep copy operation avoids these problems by:\n\n a) keeping a table of objects already copied during the current\n    copying pass\n\n b) letting user-defined classes override the copying operation or the\n    set of components copied\n\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\n\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods.", 
  "line": 0, 
  "type": "module", 
  "name": "copy", 
  "file": "/usr/lib/python3.2/copy.py"
 }, 
 {
  "doc": "A package for parsing, handling, and generating email messages.", 
  "line": 0, 
  "type": "module", 
  "name": "email", 
  "file": "/usr/lib/python3.2/email/__init__.py"
 }, 
 {
  "name": "encode_base64", 
  "doc": "Encode a string with base64.\n\nEach line will be wrapped at, at most, maxlinelen characters (defaults to\n76 characters).\n\nEach line of encoded text will end with eol, which defaults to \"\\n\".  Set\nthis to \"\\r\\n\" if you will be using the result of this function directly\nin an email.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/email/base64mime.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "HMAC (Keyed-Hashing for Message Authentication) Python module.\n\nImplements the HMAC algorithm as described by RFC 2104.", 
  "line": 0, 
  "type": "module", 
  "name": "hmac", 
  "file": "/usr/lib/python3.2/hmac.py"
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "quoteaddr", 
  "doc": "Quote a subset of the email addresses defined by RFC 821.\n\nShould be able to handle anything email.utils.parseaddr can handle.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "quotedata", 
  "doc": "Quote data for email.\n\nDouble leading '.', and change Unix newline '\\n', or Mac '\\r' into\nInternet CRLF end-of-line.", 
  "module": "smtplib", 
  "file": "/usr/lib/python3.2/smtplib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides some more Pythonic support for SSL.\n\nObject types:\n\n  SSLSocket -- subtype of socket.socket which does SSL over the socket\n\nExceptions:\n\n  SSLError -- exception raised for I/O errors\n\nFunctions:\n\n  cert_time_to_seconds -- convert time string used for certificate\n                          notBefore and notAfter functions to integer\n                          seconds past the Epoch (the time values\n                          returned from time.time())\n\n  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided\n                          by the server running on HOST at port PORT.  No\n                          validation of the certificate is performed.\n\nInteger constants:\n\nSSL_ERROR_ZERO_RETURN\nSSL_ERROR_WANT_READ\nSSL_ERROR_WANT_WRITE\nSSL_ERROR_WANT_X509_LOOKUP\nSSL_ERROR_SYSCALL\nSSL_ERROR_SSL\nSSL_ERROR_WANT_CONNECT\n\nSSL_ERROR_EOF\nSSL_ERROR_INVALID_ERROR_CODE\n\nThe following group define certificate requirements that one side is\nallowing/requiring from the other side:\n\nCERT_NONE - no certificates from the other side are required (or will\n            be looked at if provided)\nCERT_OPTIONAL - certificates are not required, but if provided will be\n                validated, and if validation fails, the connection will\n                also fail\nCERT_REQUIRED - certificates are required, and will be validated, and\n                if validation fails, the connection will also fail\n\nThe following constants identify various SSL protocol variants:\n\nPROTOCOL_SSLv2\nPROTOCOL_SSLv3\nPROTOCOL_SSLv23\nPROTOCOL_TLSv1", 
  "line": 0, 
  "type": "module", 
  "name": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py"
 }, 
 {
  "name": "get_long_be", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_long_le", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_short_be", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_short_le", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_8svx", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_aifc", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_au", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_hcom", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_sndr", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_sndt", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_voc", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_wav", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "testall", 
  "doc": null, 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "what", 
  "doc": "Guess the type of a sound file.", 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "whathdr", 
  "doc": "Recognize sound headers.", 
  "module": "sndhdr", 
  "file": "/usr/lib/python3.2/sndhdr.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "SocketIO", 
  "doc": "Raw I/O implementation for stream sockets.\n\nThis class supports the makefile() method on sockets.  It provides\nthe raw I/O interface on top of a socket object.", 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SocketType", 
  "doc": "socket([family[, type[, proto]]]) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\n_accept() -- accept connection, returning new socket fd and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\n_dup() -- return a new socket fd duplicated from fileno()\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten(n) -- start listening for incoming connections\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(0 | 1) -- set or clear the blocking I/O flag\nsetsockopt(level, optname, value) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_realsocket", 
  "doc": "socket([family[, type[, proto]]]) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\n_accept() -- accept connection, returning new socket fd and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\n_dup() -- return a new socket fd duplicated from fileno()\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten(n) -- start listening for incoming connections\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(0 | 1) -- set or clear the blocking I/O flag\nsetsockopt(level, optname, value) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Implementation module for socket operations.\n\nSee the socket module for documentation.", 
  "line": 0, 
  "type": "module", 
  "name": "_socket", 
  "file": null
 }, 
 {
  "name": "create_connection", 
  "doc": "Connect to *address* and return the socket object.\n\nConvenience function.  Connect to *address* (a 2-tuple ``(host,\nport)``) and return the socket object.  Passing the optional\n*timeout* parameter will set the timeout on the socket instance\nbefore attempting to connect.  If no *timeout* is supplied, the\nglobal default timeout setting returned by :func:`getdefaulttimeout`\nis used.  If *source_address* is set it must be a tuple of (host, port)\nfor the socket to bind as a source address before making the connection.\nAn host of '' or port 0 tells the OS to use the default.", 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dup", 
  "doc": "dup(integer) -> integer\n\nDuplicate an integer socket file descriptor.  This is like os.dup(), but for\nsockets; on some platforms os.dup() won't work for socket file descriptors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "fromfd", 
  "doc": "fromfd(fd, family, type[, proto]) -> socket object\n\nCreate a socket object from a duplicate of the given file\ndescriptor.  The remaining arguments are the same as for socket().", 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gaierror", 
  "doc": null, 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "getaddrinfo", 
  "doc": "getaddrinfo(host, port [, family, socktype, proto, flags])\n    -> list of (family, socktype, proto, canonname, sockaddr)\n\nResolve host and port into addrinfo struct.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getdefaulttimeout", 
  "doc": "getdefaulttimeout() -> timeout\n\nReturns the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getfqdn", 
  "doc": "Get fully qualified domain name from name.\n\nAn empty argument is interpreted as meaning the local host.\n\nFirst the hostname returned by gethostbyaddr() is checked, then\npossibly existing aliases. In case no FQDN is available, hostname\nfrom gethostname() is returned.", 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gethostbyaddr", 
  "doc": "gethostbyaddr(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gethostbyname", 
  "doc": "gethostbyname(host) -> address\n\nReturn the IP address (a string of the form '255.255.255.255') for a host.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gethostbyname_ex", 
  "doc": "gethostbyname_ex(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gethostname", 
  "doc": "gethostname() -> string\n\nReturn the current host name.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getnameinfo", 
  "doc": "getnameinfo(sockaddr, flags) --> (host, port)\n\nGet host and port for a sockaddr.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getprotobyname", 
  "doc": "getprotobyname(name) -> integer\n\nReturn the protocol number for the named protocol.  (Rarely used.)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getservbyname", 
  "doc": "getservbyname(servicename[, protocolname]) -> integer\n\nReturn a port number from a service name and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getservbyport", 
  "doc": "getservbyport(port[, protocolname]) -> string\n\nReturn the service name from a port number and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "herror", 
  "doc": null, 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "htonl", 
  "doc": "htonl(integer) -> integer\n\nConvert a 32-bit integer from host to network byte order.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "htons", 
  "doc": "htons(integer) -> integer\n\nConvert a 16-bit integer from host to network byte order.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "inet_aton", 
  "doc": "inet_aton(string) -> bytes giving packed 32-bit IP representation\n\nConvert an IP address in string format (123.45.67.89) to the 32-bit packed\nbinary format used in low-level network functions.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "inet_ntoa", 
  "doc": "inet_ntoa(packed_ip) -> ip_address_string\n\nConvert an IP address from 32-bit packed binary format to string format", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "inet_ntop", 
  "doc": "inet_ntop(af, packed_ip) -> string formatted IP address\n\nConvert a packed IP address of the given family to string format.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "inet_pton", 
  "doc": "inet_pton(af, ip) -> packed IP address string\n\nConvert an IP address from string format to a packed string suitable\nfor use with low-level network functions.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "ntohl", 
  "doc": "ntohl(integer) -> integer\n\nConvert a 32-bit integer from network to host byte order.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ntohs", 
  "doc": "ntohs(integer) -> integer\n\nConvert a 16-bit integer from network to host byte order.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "setdefaulttimeout", 
  "doc": "setdefaulttimeout(timeout)\n\nSet the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "socket", 
  "doc": "A subclass of _socket.socket adding the makefile() method.", 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "socketpair", 
  "doc": "socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n\nCreate a pair of socket objects from the sockets returned by the platform\nsocketpair() function.\nThe arguments are the same as for socket() except the default family is\nAF_UNIX if defined on the platform; otherwise, the default is AF_INET.", 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "timeout", 
  "doc": null, 
  "module": "socket", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Binary", 
  "doc": "memoryview(object)\n\nCreate a new memoryview object which references the given object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Cache", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Connection", 
  "doc": "SQLite database connection object.", 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Cursor", 
  "doc": "SQLite database cursor class.", 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DataError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DatabaseError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Date", 
  "doc": "date(year, month, day) --> date object", 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DateFromTicks", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/dbapi2.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IntegrityError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InterfaceError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InternalError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NotSupportedError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OperationalError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptimizedUnicode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PrepareProtocol", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ProgrammingError", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Row", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Statement", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Time", 
  "doc": "time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --> a time object\n\nAll arguments are optional. tzinfo may be None, or an instance of\na tzinfo subclass. The remaining arguments may be ints or longs.", 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TimeFromTicks", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/dbapi2.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Timestamp", 
  "doc": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints or longs.", 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/datetime.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TimestampFromTicks", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/dbapi2.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Warning", 
  "doc": null, 
  "module": "sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "adapt", 
  "doc": "adapt(obj, protocol, alternate) -> adapt obj to given protocol. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "complete_statement", 
  "doc": "complete_statement(sql)\n\nChecks if a string contains a complete SQL statement. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "connect", 
  "doc": "connect(database[, timeout, isolation_level, detect_types, factory])\n\nOpens a connection to the SQLite database file *database*. You can use\n\":memory:\" to open a database connection to a database that resides in\nRAM instead of on disk.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Fast implementation of the datetime type.", 
  "line": 0, 
  "type": "module", 
  "name": "datetime", 
  "file": "/usr/lib/python3.2/datetime.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "dbapi2", 
  "file": "/usr/lib/python3.2/sqlite3/dbapi2.py"
 }, 
 {
  "name": "enable_callback_tracebacks", 
  "doc": "enable_callback_tracebacks(flag)\n\nEnable or disable callback functions throwing errors to stderr.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "enable_shared_cache", 
  "doc": "enable_shared_cache(do_enable)\n\nEnable or disable shared cache mode for the calling thread.\nExperimental/Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_adapter", 
  "doc": "register_adapter(type, callable)\n\nRegisters an adapter with pysqlite's adapter registry. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_converter", 
  "doc": "register_converter(typename, callable)\n\nRegisters a converter with pysqlite. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "_code", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_compile", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_compile_charset", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_compile_info", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_identityfunction", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_mk_bitmap", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_optimize_charset", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_optimize_unicode", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_simple", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_sre", 
  "file": null
 }, 
 {
  "name": "compile", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "isstring", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_compile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "makedict", 
  "doc": null, 
  "module": "sre_compile", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Internal support module for sre", 
  "line": 0, 
  "type": "module", 
  "name": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "sre_constants", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "makedict", 
  "doc": null, 
  "module": "sre_constants", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Pattern", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SubPattern", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Tokenizer", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_class_escape", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_escape", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_sub", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_sub_cond", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "expand_template", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fix_flags", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isident", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isname", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "makedict", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_constants.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_template", 
  "doc": null, 
  "module": "sre_parse", 
  "file": "/usr/lib/python3.2/sre_parse.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "CertificateError", 
  "doc": null, 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DER_cert_to_PEM_cert", 
  "doc": "Takes a certificate in binary DER format and returns the\nPEM version of it as a string.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "PEM_cert_to_DER_cert", 
  "doc": "Takes a certificate in ASCII PEM format and returns the\nDER-encoded version of it as a byte sequence", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RAND_add", 
  "doc": "RAND_add(string, entropy)\n\nMix string into the OpenSSL PRNG state.  entropy (a float) is a lower\nbound on the entropy contained in string.  See RFC 1750.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RAND_egd", 
  "doc": "RAND_egd(path) -> bytes\n\nQueries the entropy gather daemon (EGD) on the socket named by 'path'.\nReturns number of bytes read.  Raises SSLError if connection to EGD\nfails or if it does provide enough data to seed PRNG.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RAND_status", 
  "doc": "RAND_status() -> 0 or 1\n\nReturns 1 if the OpenSSL PRNG has been seeded with enough data and 0 if not.\nIt is necessary to seed the PRNG with RAND_add() on some platforms before\nusing the ssl() function.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "SSLContext", 
  "doc": "An SSLContext holds various SSL-related configuration options and\ndata, such as certificates and possibly a private key.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SSLError", 
  "doc": null, 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SSLSocket", 
  "doc": "This class implements a subtype of socket.socket that wraps\nthe underlying OS socket in an SSL context when necessary, and\nprovides read and write methods over that channel.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_SSLContext", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_dnsname_to_pat", 
  "doc": null, 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getnameinfo", 
  "doc": "getnameinfo(sockaddr, flags) --> (host, port)\n\nGet host and port for a sockaddr.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Implementation module for SSL socket operations.  See the socket module\nfor documentation.", 
  "line": 0, 
  "type": "module", 
  "name": "_ssl", 
  "file": null
 }, 
 {
  "doc": "RFC 3548: Base16, Base32, Base64 Data Encodings", 
  "line": 0, 
  "type": "module", 
  "name": "base64", 
  "file": "/usr/lib/python3.2/base64.py"
 }, 
 {
  "name": "cert_time_to_seconds", 
  "doc": "Takes a date-time string in standard ASN1_print form\n(\"MON DAY 24HOUR:MINUTE:SEC YEAR TIMEZONE\") and return\na Python time value in seconds past the epoch.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "name": "get_protocol_name", 
  "doc": null, 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_server_certificate", 
  "doc": "Retrieve the certificate from the server at the specified address,\nand return it as a PEM-encoded string.\nIf 'ca_certs' is specified, validate the server cert against it.\nIf 'ssl_version' is specified, use it in the connection attempt.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "match_hostname", 
  "doc": "Verify that *cert* (in decoded format as returned by\nSSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 rules\nare mostly followed, but IP addresses are not accepted for *hostname*.\n\nCertificateError is raised on failure. On success, the function\nreturns nothing.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "socket", 
  "doc": "A subclass of _socket.socket adding the makefile() method.", 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "socket_error", 
  "doc": null, 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/socket.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Text wrapping and filling.", 
  "line": 0, 
  "type": "module", 
  "name": "textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py"
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "name": "wrap_socket", 
  "doc": null, 
  "module": "ssl", 
  "file": "/usr/lib/python3.2/ssl.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_IFMT", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_IMODE", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISBLK", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISCHR", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISDIR", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISFIFO", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISLNK", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISREG", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "S_ISSOCK", 
  "doc": null, 
  "module": "stat", 
  "file": "/usr/lib/python3.2/stat.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Formatter", 
  "doc": null, 
  "module": "string", 
  "file": "/usr/lib/python3.2/string.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Template", 
  "doc": "A string class for supporting $-substitutions.", 
  "module": "string", 
  "file": "/usr/lib/python3.2/string.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_TemplateMetaclass", 
  "doc": null, 
  "module": "string", 
  "file": "/usr/lib/python3.2/string.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_multimap", 
  "doc": "Helper class for combining multiple mappings.\n\nUsed by .{safe_,}substitute() to combine the mapping and keyword\narguments.", 
  "module": "string", 
  "file": "/usr/lib/python3.2/string.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "_re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "string helper module", 
  "line": 0, 
  "type": "module", 
  "name": "_string", 
  "file": null
 }, 
 {
  "name": "capwords", 
  "doc": "capwords(s [,sep]) -> string\n\nSplit the argument into words using split, capitalize each\nword using capitalize, and join the capitalized words using\njoin.  If the optional second argument sep is absent or None,\nruns of whitespace characters are replaced by a single space\nand leading and trailing whitespace are removed, otherwise\nsep is used to split and join the words.", 
  "module": "string", 
  "file": "/usr/lib/python3.2/string.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_a1", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_b1", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c11", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c11_c12", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c12", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c21", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c21_c22", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c22", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c3", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c4", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c5", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c6", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c7", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c8", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_c9", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_d1", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "in_table_d2", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "map_table_b2", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "map_table_b3", 
  "doc": null, 
  "module": "stringprep", 
  "file": "/usr/lib/python3.2/stringprep.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Struct", 
  "doc": "Struct(fmt) --> compiled struct object\n\nReturn a new Struct object which writes and reads binary data according to\nthe format string fmt.  See help(struct) for more on format strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_clearcache", 
  "doc": "Clear the internal cache.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "calcsize", 
  "doc": "calcsize(fmt) -> integer\n\nReturn size in bytes of the struct described by the format string fmt.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "struct", 
  "file": "/usr/lib/python3.2/struct.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "pack", 
  "doc": "pack(fmt, v1, v2, ...) -> bytes\n\nReturn a bytes object containing the values v1, v2, ... packed according\nto the format string fmt.  See help(struct) for more on format strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pack_into", 
  "doc": "pack_into(fmt, buffer, offset, v1, v2, ...)\n\nPack the values v1, v2, ... according to the format string fmt and write\nthe packed bytes into the writable buffer buf starting at offset.  Note\nthat the offset is a required argument.  See help(struct) for more\non format strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unpack", 
  "doc": "unpack(fmt, buffer) -> (v1, v2, ...)\n\nReturn a tuple containing values unpacked according to the format string\nfmt.  Requires len(buffer) == calcsize(fmt). See help(struct) for more\non format strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unpack_from", 
  "doc": "unpack_from(fmt, buffer, offset=0) -> (v1, v2, ...)\n\nReturn a tuple containing values unpacked according to the format string\nfmt.  Requires len(buffer[offset:]) >= calcsize(fmt).  See help(struct)\nfor more on format strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "CalledProcessError", 
  "doc": "This exception is raised when a process run by check_call() or\ncheck_output() returns a non-zero exit status.\nThe exit status will be stored in the returncode attribute;\ncheck_output() will also store the output in the output attribute.", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Popen", 
  "doc": null, 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_cleanup", 
  "doc": null, 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_create_pipe", 
  "doc": "cloexec_pipe() -> (read_end, write_end)\n\nCreate a pipe whose ends have the cloexec flag set.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_demo_posix", 
  "doc": null, 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_demo_windows", 
  "doc": null, 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_eintr_retry_call", 
  "doc": null, 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "A POSIX helper for the subprocess module.", 
  "line": 0, 
  "type": "module", 
  "name": "_posixsubprocess", 
  "file": null
 }, 
 {
  "name": "_set_cloexec", 
  "doc": null, 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "call", 
  "doc": "Run command with arguments.  Wait for command to complete, then\nreturn the returncode attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\nretcode = call([\"ls\", \"-l\"])", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "check_call", 
  "doc": "Run command with arguments.  Wait for command to complete.  If\nthe exit code was zero then return, otherwise raise\nCalledProcessError.  The CalledProcessError object will have the\nreturn code in the returncode attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\ncheck_call([\"ls\", \"-l\"])", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "check_output", 
  "doc": "Run command with arguments and return its output as a byte string.\n\nIf the exit code was non-zero it raises a CalledProcessError.  The\nCalledProcessError object will have the return code in the returncode\nattribute and output in the output attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\n>>> check_output([\"ls\", \"-l\", \"/dev/null\"])\nb'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n\nThe stdout argument is not allowed as it is used internally.\nTo capture standard error in the result, use stderr=STDOUT.\n\n>>> check_output([\"/bin/sh\", \"-c\",\n...               \"ls -l non_existent_file ; exit 0\"],\n...              stderr=STDOUT)\nb'ls: non_existent_file: No such file or directory\\n'", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "This module performs file control and I/O control on file \ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.", 
  "line": 0, 
  "type": "module", 
  "name": "fcntl", 
  "file": null
 }, 
 {
  "doc": "This module provides access to the garbage collector for reference cycles.\n\nenable() -- Enable automatic garbage collection.\ndisable() -- Disable automatic garbage collection.\nisenabled() -- Returns true if automatic collection is enabled.\ncollect() -- Do a full collection right now.\nget_count() -- Return the current collection counts.\nset_debug() -- Set debugging flags.\nget_debug() -- Get debugging flags.\nset_threshold() -- Set the collection thresholds.\nget_threshold() -- Return the current the collection thresholds.\nget_objects() -- Return a list of all objects tracked by the collector.\nis_tracked() -- Returns true if a given object is tracked.\nget_referrers() -- Return the list of objects that refer to an object.\nget_referents() -- Return the list of objects that an object refers to.", 
  "line": 0, 
  "type": "module", 
  "name": "gc", 
  "file": null
 }, 
 {
  "name": "getoutput", 
  "doc": "Return output (stdout or stderr) of executing cmd in a shell.\n\nLike getstatusoutput(), except the exit status is ignored and the return\nvalue is a string containing the command's output.  Example:\n\n>>> import subprocess\n>>> subprocess.getoutput('ls /bin/ls')\n'/bin/ls'", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getstatusoutput", 
  "doc": "Return (status, output) of executing cmd in a shell.\n\nExecute the string 'cmd' in a shell with os.popen() and return a 2-tuple\n(status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the\nreturned output will contain output or error messages.  A trailing newline\nis stripped from the output.  The exit status for the command can be\ninterpreted according to the rules for the C function wait().  Example:\n\n>>> import subprocess\n>>> subprocess.getstatusoutput('ls /bin/ls')\n(0, '/bin/ls')\n>>> subprocess.getstatusoutput('cat /bin/junk')\n(256, 'cat: /bin/junk: No such file or directory')\n>>> subprocess.getstatusoutput('/bin/junk')\n(256, 'sh: /bin/junk: not found')", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "list2cmdline", 
  "doc": "Translate a sequence of arguments into a command line\nstring, using the same rules as the MS C runtime:\n\n1) Arguments are delimited by white space, which is either a\n   space or a tab.\n\n2) A string surrounded by double quotation marks is\n   interpreted as a single argument, regardless of white space\n   contained within.  A quoted string can be embedded in an\n   argument.\n\n3) A double quotation mark preceded by a backslash is\n   interpreted as a literal double quotation mark.\n\n4) Backslashes are interpreted literally, unless they\n   immediately precede a double quotation mark.\n\n5) If backslashes immediately precede a double quotation mark,\n   every pair of backslashes is interpreted as a literal\n   backslash.  If the number of backslashes is odd, the last\n   backslash escapes the next double quotation mark as\n   described in rule 3.", 
  "module": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Create portable serialized representations of Python objects.\n\nSee module copyreg for a mechanism for registering custom picklers.\nSee module pickletools source for extensive comments.\n\nClasses:\n\n    Pickler\n    Unpickler\n\nFunctions:\n\n    dump(object, file)\n    dumps(object) -> string\n    load(file) -> object\n    loads(string) -> object\n\nMisc variables:\n\n    __version__\n    format_version\n    compatible_formats", 
  "line": 0, 
  "type": "module", 
  "name": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py"
 }, 
 {
  "doc": "This module supports asynchronous I/O on multiple file descriptors.\n\n*** IMPORTANT NOTICE ***\nOn Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors.", 
  "line": 0, 
  "type": "module", 
  "name": "select", 
  "file": null
 }, 
 {
  "doc": "This module provides mechanisms to use signal handlers in Python.\n\nFunctions:\n\nalarm() -- cause SIGALRM after a specified time [Unix only]\nsetitimer() -- cause a signal (described below) after a specified\n               float time and the timer may restart then [Unix only]\ngetitimer() -- get current value of timer [Unix only]\nsignal() -- set the action for a given signal\ngetsignal() -- get the signal action for a given signal\npause() -- wait until a signal arrives [Unix only]\ndefault_int_handler() -- default SIGINT handler\n\nsignal constants:\nSIG_DFL -- used to refer to the system default handler\nSIG_IGN -- used to ignore the signal\nNSIG -- number of defined signals\nSIGINT, SIGTERM, etc. -- signal numbers\n\nitimer constants:\nITIMER_REAL -- decrements in real time, and delivers SIGALRM upon\n               expiration\nITIMER_VIRTUAL -- decrements only when the process is executing,\n               and delivers SIGVTALRM upon expiration\nITIMER_PROF -- decrements both when the process is executing and\n               when the system is executing on behalf of the process.\n               Coupled with ITIMER_VIRTUAL, this timer is usually\n               used to profile the time spent by the application\n               in user and kernel space. SIGPROF is delivered upon\n               expiration.\n\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.", 
  "line": 0, 
  "type": "module", 
  "name": "signal", 
  "file": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Extract, format and print information about Python stack traces.", 
  "line": 0, 
  "type": "module", 
  "name": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py"
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "Au_read", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Au_write", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_read_u32", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_write_u32", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "openfp", 
  "doc": null, 
  "module": "sunau", 
  "file": "/usr/lib/python3.2/sunau.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "symbol", 
  "file": "/usr/lib/python3.2/symbol.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Class", 
  "doc": null, 
  "module": "symtable", 
  "file": "/usr/lib/python3.2/symtable.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Function", 
  "doc": null, 
  "module": "symtable", 
  "file": "/usr/lib/python3.2/symtable.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Symbol", 
  "doc": null, 
  "module": "symtable", 
  "file": "/usr/lib/python3.2/symtable.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SymbolTable", 
  "doc": null, 
  "module": "symtable", 
  "file": "/usr/lib/python3.2/symtable.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SymbolTableFactory", 
  "doc": null, 
  "module": "symtable", 
  "file": "/usr/lib/python3.2/symtable.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_symtable", 
  "file": null
 }, 
 {
  "name": "symtable", 
  "doc": null, 
  "module": "symtable", 
  "file": "/usr/lib/python3.2/symtable.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Weak reference support for Python.\n\nThis module is an implementation of PEP 205:\n\nhttp://www.python.org/dev/peps/pep-0205/", 
  "line": 0, 
  "type": "module", 
  "name": "weakref", 
  "file": "/usr/lib/python3.2/weakref.py"
 }, 
 {
  "name": "_expand_vars", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_extend_dict", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_default_scheme", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getuserbase", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_init_non_posix", 
  "doc": "Initialize the module as appropriate for NT", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_init_posix", 
  "doc": "Initialize the module as appropriate for POSIX systems.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_main", 
  "doc": "Display all information sysconfig detains.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_parse_makefile", 
  "doc": "Parse a Makefile-style file.\n\nA dictionary containing name/value pairs is returned.  If an\noptional dictionary is passed in as the second argument, it is\nused instead of a new dictionary.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_print_dict", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_safe_realpath", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_subst_vars", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_config_h_filename", 
  "doc": "Return the path of pyconfig.h.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_config_var", 
  "doc": "Return the value of a single variable using the dictionary returned by\n'get_config_vars()'.\n\nEquivalent to get_config_vars().get(name)", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_config_vars", 
  "doc": "With no arguments, return a dictionary of all configuration\nvariables relevant for the current platform.\n\nOn Unix, this means every variable defined in Python's installed Makefile;\nOn Windows and Mac OS it's a much smaller set.\n\nWith arguments, return a list of values that result from looking up\neach argument in the configuration variable dictionary.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_makefile_filename", 
  "doc": "Return the path of the Makefile.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_path", 
  "doc": "Return a path corresponding to the scheme.\n\n``scheme`` is the install scheme name.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_path_names", 
  "doc": "Return a tuple containing the paths names.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_paths", 
  "doc": "Return a mapping containing an install scheme.\n\n``scheme`` is the install scheme name. If not provided, it will\nreturn the default scheme for the current platform.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_platform", 
  "doc": "Return a string that identifies the current platform.\n\nThis is used mainly to distinguish platform-specific build directories and\nplatform-specific built distributions.  Typically includes the OS name\nand version and the architecture (as supplied by 'os.uname()'),\nalthough the exact information included depends on the OS; eg. for IRIX\nthe architecture isn't particularly important (IRIX only runs on SGI\nhardware), but for Linux the kernel version isn't particularly\nimportant.\n\nExamples of returned values:\n   linux-i586\n   linux-alpha (?)\n   solaris-2.6-sun4u\n   irix-5.3\n   irix64-6.2\n\nWindows will return one of:\n   win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)\n   win-ia64 (64bit Windows on Itanium)\n   win32 (all others - specifically, sys.platform is returned)\n\nFor other non-POSIX platforms, currently just returns 'sys.platform'.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_python_version", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_scheme_names", 
  "doc": "Return a tuple containing the schemes names.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "is_python_build", 
  "doc": null, 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "parse_config_h", 
  "doc": "Parse a config.h-style file.\n\nA dictionary containing name/value pairs is returned.  If an\noptional dictionary is passed in as the second argument, it is\nused instead of a new dictionary.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/sysconfig.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "realpath", 
  "doc": "Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.", 
  "module": "sysconfig", 
  "file": "/usr/lib/python3.2/posixpath.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "NannyNag", 
  "doc": "Raised by tokeneater() if detecting an ambiguous indent.\nCaptured and handled in check().", 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Whitespace", 
  "doc": null, 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "check", 
  "doc": "check(file_or_dir)\n\nIf file_or_dir is a directory and not a symbolic link, then recursively\ndescend the directory tree named by file_or_dir, checking all .py files\nalong the way. If file_or_dir is an ordinary Python source file, it is\nchecked for whitespace related problems. The diagnostic messages are\nwritten to standard output using the print statement.", 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "errprint", 
  "doc": null, 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_witnesses", 
  "doc": null, 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Parser for command line options.\n\nThis module helps scripts to parse the command line arguments in\nsys.argv.  It supports the same conventions as the Unix getopt()\nfunction (including the special meanings of arguments of the form `-'\nand `--').  Long options similar to those supported by GNU software\nmay be used as well via an optional third argument.  This module\nprovides two functions and an exception:\n\ngetopt() -- Parse command line options\ngnu_getopt() -- Like getopt(), but allow option and non-option arguments\nto be intermixed.\nGetoptError -- exception (class) raised with 'opt' attribute, which is the\noption involved with the exception.", 
  "line": 0, 
  "type": "module", 
  "name": "getopt", 
  "file": "/usr/lib/python3.2/getopt.py"
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "process_tokens", 
  "doc": null, 
  "module": "tabnanny", 
  "file": "/usr/lib/python3.2/tabnanny.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "CompressionError", 
  "doc": "Exception for unavailable compression methods.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "EOFHeaderError", 
  "doc": "Exception for end of file headers.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "EmptyHeaderError", 
  "doc": "Exception for empty headers.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ExFileObject", 
  "doc": "File-like object for reading an archive member.\nIs returned by TarFile.extractfile().", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ExtractError", 
  "doc": "General exception for extract errors.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "HeaderError", 
  "doc": "Base exception for header errors.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InvalidHeaderError", 
  "doc": "Exception for invalid headers.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ReadError", 
  "doc": "Exception for unreadble tar archives.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StreamError", 
  "doc": "Exception for unsupported operations on stream-like TarFiles.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SubsequentHeaderError", 
  "doc": "Exception for missing and invalid extended headers.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TarError", 
  "doc": "Base exception.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TarFile", 
  "doc": "The TarFile Class provides an interface to tar archives.\n    ", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TarInfo", 
  "doc": "Informational class which holds the details about an\narchive member given by a tar header block.\nTarInfo objects are returned by TarFile.getmember(),\nTarFile.getmembers() and TarFile.gettarinfo() and are\nusually created internally.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TarIter", 
  "doc": "Iterator Class.\n\nfor tarinfo in TarFile(...):\n    suite...", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TruncatedHeaderError", 
  "doc": "Exception for truncated headers.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_BZ2Proxy", 
  "doc": "Small proxy class that enables external file object\nsupport for \"r:bz2\" and \"w:bz2\" modes. This is actually\na workaround for a limitation in bz2 module's BZ2File\nclass which (unlike gzip.GzipFile) has no support for\na file object argument.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_FileInFile", 
  "doc": "A thin wrapper around an existing file object that\nprovides a part of its data as an individual file\nobject.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_LowLevelFile", 
  "doc": "Low-level file object. Supports reading and writing.\nIt is used instead of a regular file object for streaming\naccess.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Stream", 
  "doc": "Class that serves as an adapter between TarFile and\na stream-like object.  The stream-like object only\nneeds to have a read() or write() method and is accessed\nblockwise.  Use of gzip or bzip2 compression is possible.\nA stream-like object could be for example: sys.stdin,\nsys.stdout, a socket, a tape device etc.\n\n_Stream is intended to be used only internally.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StreamProxy", 
  "doc": "Small proxy class that enables transparent compression\ndetection for the Stream interface (mode 'r|*').", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_open", 
  "doc": "open(file, mode='r', buffering=-1, encoding=None,\n     errors=None, newline=None, closefd=True) -> file object\n\nOpen file and return a stream.  Raise IOError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), and 'a' for appending (which on some Unix systems,\nmeans that all writes append to the end of the file regardless of the\ncurrent seek position). In text mode, if encoding is not specified the\nencoding used is platform dependent. (For reading and writing raw\nbytes use binary mode and leave encoding unspecified.) The available\nmodes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n'U'       universal newline mode (for backwards compatibility; unneeded\n          for new code)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register for a list of the permitted\nencoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '', no translation takes place. If newline is any of the\n  other legal values, any '\\n' characters written are translated to\n  the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bltn_open", 
  "doc": "Open a tar archive for reading, writing or appending. Return\nan appropriate TarFile class.\n\nmode:\n'r' or 'r:*' open for reading with transparent compression\n'r:'         open for reading exclusively uncompressed\n'r:gz'       open for reading with gzip compression\n'r:bz2'      open for reading with bzip2 compression\n'a' or 'a:'  open for appending, creating the file if necessary\n'w' or 'w:'  open for writing without compression\n'w:gz'       open for writing with gzip compression\n'w:bz2'      open for writing with bzip2 compression\n\n'r|*'        open a stream of tar blocks with transparent compression\n'r|'         open an uncompressed stream of tar blocks for reading\n'r|gz'       open a gzip compressed stream of tar blocks\n'r|bz2'      open a bzip2 compressed stream of tar blocks\n'w|'         open an uncompressed stream for writing\n'w|gz'       open a gzip compressed stream for writing\n'w|bz2'      open a bzip2 compressed stream for writing", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "calc_chksums", 
  "doc": "Calculate the checksum for a member's header by summing up all\ncharacters except for the chksum field which is treated as if\nit was filled with spaces. According to the GNU tar sources,\nsome tars (Sun and NeXT) calculate chksum with signed char,\nwhich will be different if there are chars in the buffer with\nthe high bit set. So we calculate two checksums, unsigned and\nsigned.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Generic (shallow and deep) copying operations.\n\nInterface summary:\n\n        import copy\n\n        x = copy.copy(y)        # make a shallow copy of y\n        x = copy.deepcopy(y)    # make a deep copy of y\n\nFor module specific errors, copy.Error is raised.\n\nThe difference between shallow and deep copying is only relevant for\ncompound objects (objects that contain other objects, like lists or\nclass instances).\n\n- A shallow copy constructs a new compound object and then (to the\n  extent possible) inserts *the same objects* into it that the\n  original contains.\n\n- A deep copy constructs a new compound object and then, recursively,\n  inserts *copies* into it of the objects found in the original.\n\nTwo problems often exist with deep copy operations that don't exist\nwith shallow copy operations:\n\n a) recursive objects (compound objects that, directly or indirectly,\n    contain a reference to themselves) may cause a recursive loop\n\n b) because deep copy copies *everything* it may copy too much, e.g.\n    administrative data structures that should be shared even between\n    copies\n\nPython's deep copy operation avoids these problems by:\n\n a) keeping a table of objects already copied during the current\n    copying pass\n\n b) letting user-defined classes override the copying operation or the\n    set of components copied\n\nThis version does not copy types like module, class, function, method,\nnor stack trace, stack frame, nor file, socket, window, nor array, nor\nany similar types.\n\nClasses can use the same interfaces to control copying that they use\nto control pickling: they can define methods called __getinitargs__(),\n__getstate__() and __setstate__().  See the documentation for module\n\"pickle\" for information on these methods.", 
  "line": 0, 
  "type": "module", 
  "name": "copy", 
  "file": "/usr/lib/python3.2/copy.py"
 }, 
 {
  "name": "copyfileobj", 
  "doc": "Copy length bytes from fileobj src to fileobj dst.\nIf length is None, copy the entire content.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "name": "filemode", 
  "doc": "Convert a file's mode to a string of the form\n-rwxrwxrwx.\nUsed by TarFile.list()", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Access to the Unix group database.\n\nGroup entries are reported as 4-tuples containing the following fields\nfrom the group database, in order:\n\n  name   - name of the group\n  passwd - group password (encrypted); often empty\n  gid    - numeric ID of the group\n  mem    - list of members\n\nThe gid is an integer, name and password are strings.  (Note that most\nusers are not explicitly listed as members of the groups they are in\naccording to the password database.  Check both databases to get\ncomplete membership information.)", 
  "line": 0, 
  "type": "module", 
  "name": "grp", 
  "file": null
 }, 
 {
  "name": "is_tarfile", 
  "doc": "Return True if name points to a tar archive that we\nare able to handle, else return False.", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "itn", 
  "doc": "Convert a python number to a number field.\n    ", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nti", 
  "doc": "Convert a number field to a python number.\n    ", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nts", 
  "doc": "Convert a null-terminated bytes object to a string.\n    ", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": "Open a tar archive for reading, writing or appending. Return\nan appropriate TarFile class.\n\nmode:\n'r' or 'r:*' open for reading with transparent compression\n'r:'         open for reading exclusively uncompressed\n'r:gz'       open for reading with gzip compression\n'r:bz2'      open for reading with bzip2 compression\n'a' or 'a:'  open for appending, creating the file if necessary\n'w' or 'w:'  open for writing without compression\n'w:gz'       open for writing with gzip compression\n'w:bz2'      open for writing with bzip2 compression\n\n'r|*'        open a stream of tar blocks with transparent compression\n'r|'         open an uncompressed stream of tar blocks for reading\n'r|gz'       open a gzip compressed stream of tar blocks\n'r|bz2'      open a bzip2 compressed stream of tar blocks\n'w|'         open an uncompressed stream for writing\n'w|gz'       open a gzip compressed stream for writing\n'w|bz2'      open a bzip2 compressed stream for writing", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to the Unix password database.\nIt is available on all Unix versions.\n\nPassword database entries are reported as 7-tuples containing the following\nitems from the password database (see `<pwd.h>'), in order:\npw_name, pw_passwd, pw_uid, pw_gid, pw_gecos, pw_dir, pw_shell.\nThe uid and gid items are integers, all others are strings. An\nexception is raised if the entry asked for cannot be found.", 
  "line": 0, 
  "type": "module", 
  "name": "pwd", 
  "file": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "Utility functions for copying and archiving files and directory trees.\n\nXXX The functions here don't copy the resource fork or other metadata on Mac.", 
  "line": 0, 
  "type": "module", 
  "name": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py"
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "name": "stn", 
  "doc": "Convert a string to a null-terminated bytes object.\n    ", 
  "module": "tarfile", 
  "file": "/usr/lib/python3.2/tarfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "Telnet", 
  "doc": "Telnet interface class.\n\nAn instance of this class represents a connection to a telnet\nserver.  The instance is initially not connected; the open()\nmethod must be used to establish a connection.  Alternatively, the\nhost name and optional port number can be passed to the\nconstructor, too.\n\nDon't try to reopen an already connected instance.\n\nThis class has many read_*() methods.  Note that some of them\nraise EOFError when the end of the connection is read, because\nthey can return an empty string for other reasons.  See the\nindividual doc strings.\n\nread_until(expected, [timeout])\n    Read until the expected string has been seen, or a timeout is\n    hit (default is no timeout); may block.\n\nread_all()\n    Read all data until EOF; may block.\n\nread_some()\n    Read at least one byte or EOF; may block.\n\nread_very_eager()\n    Read all data available already queued or on the socket,\n    without blocking.\n\nread_eager()\n    Read either data already queued or some data available on the\n    socket, without blocking.\n\nread_lazy()\n    Read all data in the raw queue (processing it first), without\n    doing any socket I/O.\n\nread_very_lazy()\n    Reads all data in the cooked queue, without doing any socket\n    I/O.\n\nread_sb_data()\n    Reads available data between SB ... SE sequence. Don't block.\n\nset_option_negotiation_callback(callback)\n    Each time a telnet option is read on the input flow, this callback\n    (if set) is called with the following parameters :\n    callback(telnet socket, command, option)\n        option will be chr(0) when there is no option.\n    No other action is done afterwards by telnetlib.", 
  "module": "telnetlib", 
  "file": "/usr/lib/python3.2/telnetlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module supports asynchronous I/O on multiple file descriptors.\n\n*** IMPORTANT NOTICE ***\nOn Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors.", 
  "line": 0, 
  "type": "module", 
  "name": "select", 
  "file": null
 }, 
 {
  "doc": "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nInteger constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.", 
  "line": 0, 
  "type": "module", 
  "name": "socket", 
  "file": "/usr/lib/python3.2/socket.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": "Test program for telnetlib.\n\nUsage: python telnetlib.py [-d] ... [host [port]]\n\nDefault host is localhost; default port is 23.", 
  "module": "telnetlib", 
  "file": "/usr/lib/python3.2/telnetlib.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "NamedTemporaryFile", 
  "doc": "Create and return a temporary file.\nArguments:\n'prefix', 'suffix', 'dir' -- as for mkstemp.\n'mode' -- the mode argument to io.open (default \"w+b\").\n'buffering' -- the buffer size argument to io.open (default -1).\n'encoding' -- the encoding argument to io.open (default None)\n'newline' -- the newline argument to io.open (default None)\n'delete' -- whether the file is deleted on close (default True).\nThe file is created as mkstemp() would do it.\n\nReturns an object with a file-like interface; the name of the file\nis accessible as file.name.  The file will be automatically deleted\nwhen it is closed unless the 'delete' argument is set to False.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "SpooledTemporaryFile", 
  "doc": "Temporary file wrapper, specialized to switch from\nStringIO to a real file when it exceeds a certain size or\nwhen a fileno is needed.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TemporaryDirectory", 
  "doc": "Create and return a temporary directory.  This has the same\nbehavior as mkdtemp but can be used as a context manager.  For\nexample:\n\n    with TemporaryDirectory() as tmpdir:\n        ...\n\nUpon exiting the context, the directory and everthing contained\nin it are removed.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TemporaryFile", 
  "doc": "Create and return a temporary file.\nArguments:\n'prefix', 'suffix', 'dir' -- as for mkstemp.\n'mode' -- the mode argument to io.open (default \"w+b\").\n'buffering' -- the buffer size argument to io.open (default -1).\n'encoding' -- the encoding argument to io.open (default None)\n'newline' -- the newline argument to io.open (default None)\nThe file is created as mkstemp() would do it.\n\nReturns an object with a file-like interface.  The file has no\nname, and will cease to exist when it is closed.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_Random", 
  "doc": "Random number generator base class used by bound module functions.\n\nUsed to instantiate instances of Random to get generators that don't\nshare state.\n\nClass Random can also be subclassed if you want to use a different basic\ngenerator of your own devising: in that case, override the following\nmethods:  random(), seed(), getstate(), and setstate().\nOptionally, implement a getrandbits() method so that randrange()\ncan cover arbitrarily large ranges.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/random.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_RandomNameSequence", 
  "doc": "An instance of _RandomNameSequence generates an endless\nsequence of unpredictable strings which can safely be incorporated\ninto file names.  Each string is six characters long.  Multiple\nthreads can safely use the same instance at the same time.\n\n_RandomNameSequence is an iterator.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_TemporaryFileWrapper", 
  "doc": "Temporary file wrapper\n\nThis class provides a wrapper around files opened for\ntemporary use.  In particular, it seeks to automatically\nremove the file when it is no longer needed.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_allocate_lock", 
  "doc": "allocate_lock() -> lock object\n(allocate() is an obsolete synonym)\n\nCreate a new lock object.  See help(LockType) for information about locks.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_candidate_tempdir_list", 
  "doc": "Generate a list of candidate temporary directories which\n_get_default_tempdir will try.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "_errno", 
  "file": null
 }, 
 {
  "name": "_exists", 
  "doc": null, 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module performs file control and I/O control on file \ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.", 
  "line": 0, 
  "type": "module", 
  "name": "_fcntl", 
  "file": null
 }, 
 {
  "name": "_get_candidate_names", 
  "doc": "Common setup sequence for all user-callable interfaces.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_default_tempdir", 
  "doc": "Calculate the default directory to use for temporary files.\nThis routine should be called exactly once.\n\nWe determine whether or not a candidate temp dir is usable by\ntrying to create and write to a file in that directory.  If this\nis successful, the test file is deleted.  To prevent denial of\nservice, the name of the test file must be randomized.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "_io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "_mkstemp_inner", 
  "doc": "Code common to mkstemp, TemporaryFile, and NamedTemporaryFile.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "_os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "_set_cloexec", 
  "doc": null, 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_stat", 
  "doc": "lstat(path) -> stat result\n\nLike stat(path), but do not follow symbolic links.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "doc": "This module provides primitive operations to write multi-threaded programs.\nThe 'threading' module provides a more convenient interface.", 
  "line": 0, 
  "type": "module", 
  "name": "_thread", 
  "file": null
 }, 
 {
  "doc": "Python part of the warnings subsystem.", 
  "line": 0, 
  "type": "module", 
  "name": "_warnings", 
  "file": "/usr/lib/python3.2/warnings.py"
 }, 
 {
  "name": "gettempdir", 
  "doc": "Accessor for tempfile.tempdir.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gettempprefix", 
  "doc": "Accessor for tempdir.template.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mkdtemp", 
  "doc": "User-callable function to create and return a unique temporary\ndirectory.  The return value is the pathname of the directory.\n\nArguments are as for mkstemp, except that the 'text' argument is\nnot accepted.\n\nThe directory is readable, writable, and searchable only by the\ncreating user.\n\nCaller is responsible for deleting the directory when done with it.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mkstemp", 
  "doc": "User-callable function to create and return a unique temporary\nfile.  The return value is a pair (fd, name) where fd is the\nfile descriptor returned by os.open, and name is the filename.\n\nIf 'suffix' is specified, the file name will end with that suffix,\notherwise there will be no suffix.\n\nIf 'prefix' is specified, the file name will begin with that prefix,\notherwise a default prefix is used.\n\nIf 'dir' is specified, the file will be created in that directory,\notherwise a default directory is used.\n\nIf 'text' is specified and true, the file is opened in text\nmode.  Else (the default) the file is opened in binary mode.  On\nsome operating systems, this makes no difference.\n\nThe file is readable and writable only by the creating user ID.\nIf the operating system uses permission bits to indicate whether a\nfile is executable, the file is executable by no one. The file\ndescriptor is not inherited by children of this process.\n\nCaller is responsible for deleting the file when done with it.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mktemp", 
  "doc": "User-callable function to return a unique temporary file name.  The\nfile is not created.\n\nArguments are as for mkstemp, except that the 'text' argument is\nnot accepted.\n\nThis function is unsafe and should not be used.  The file name\nrefers to a file that did not exist at some point, but by the time\nyou get around to creating it, someone else may have beaten you to\nthe punch.", 
  "module": "tempfile", 
  "file": "/usr/lib/python3.2/tempfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "TextWrapper", 
  "doc": "Object for wrapping/filling text.  The public interface consists of\nthe wrap() and fill() methods; the other methods are just there for\nsubclasses to override in order to tweak the default behaviour.\nIf you want to completely replace the main wrapping algorithm,\nyou'll probably have to override _wrap_chunks().\n\nSeveral instance attributes control various aspects of wrapping:\n  width (default: 70)\n    the maximum width of wrapped lines (unless break_long_words\n    is false)\n  initial_indent (default: \"\")\n    string that will be prepended to the first line of wrapped\n    output.  Counts towards the line's width.\n  subsequent_indent (default: \"\")\n    string that will be prepended to all lines save the first\n    of wrapped output; also counts towards each line's width.\n  expand_tabs (default: true)\n    Expand tabs in input text to spaces before further processing.\n    Each tab will become 1 .. 8 spaces, depending on its position in\n    its line.  If false, each tab is treated as a single character.\n  replace_whitespace (default: true)\n    Replace all whitespace characters in the input text by spaces\n    after tab expansion.  Note that if expand_tabs is false and\n    replace_whitespace is true, every tab will be converted to a\n    single space!\n  fix_sentence_endings (default: false)\n    Ensure that sentence-ending punctuation is always followed\n    by two spaces.  Off by default because the algorithm is\n    (unavoidably) imperfect.\n  break_long_words (default: true)\n    Break words longer than 'width'.  If false, those words will not\n    be broken, and some lines might be longer than 'width'.\n  break_on_hyphens (default: true)\n    Allow breaking hyphenated words. If true, wrapping will occur\n    preferably on whitespaces and right after hyphens part of\n    compound words.\n  drop_whitespace (default: true)\n    Drop leading and trailing whitespace from lines.", 
  "module": "textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "dedent", 
  "doc": "Remove any common leading whitespace from every line in `text`.\n\nThis can be used to make triple-quoted strings line up with the left\nedge of the display, while still presenting them in the source code\nin indented form.\n\nNote that tabs and spaces are both treated as whitespace, but they\nare not equal: the lines \"  hello\" and \"    hello\" are\nconsidered to have no common leading whitespace.  (This behaviour is\nnew in Python 2.5; older versions of this module incorrectly\nexpanded tabs before searching for common leading whitespace.)", 
  "module": "textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fill", 
  "doc": "Fill a single paragraph of text, returning a new string.\n\nReformat the single paragraph in 'text' to fit in lines of no more\nthan 'width' columns, and return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are expanded and other\nwhitespace characters converted to space.  See TextWrapper class for\navailable keyword args to customize wrapping behaviour.", 
  "module": "textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "A collection of string constants.\n\nPublic module variables:\n\nwhitespace -- a string containing all ASCII whitespace\nascii_lowercase -- a string containing all ASCII lowercase letters\nascii_uppercase -- a string containing all ASCII uppercase letters\nascii_letters -- a string containing all ASCII letters\ndigits -- a string containing all ASCII decimal digits\nhexdigits -- a string containing all ASCII hexadecimal digits\noctdigits -- a string containing all ASCII octal digits\npunctuation -- a string containing all ASCII punctuation characters\nprintable -- a string containing all ASCII characters considered printable", 
  "line": 0, 
  "type": "module", 
  "name": "string", 
  "file": "/usr/lib/python3.2/string.py"
 }, 
 {
  "name": "wrap", 
  "doc": "Wrap a single paragraph of text, returning a list of wrapped lines.\n\nReformat the single paragraph in 'text' so it fits in lines of no\nmore than 'width' columns, and return a list of wrapped lines.  By\ndefault, tabs in 'text' are expanded with string.expandtabs(), and\nall other whitespace characters (including newline) are converted to\nspace.  See TextWrapper class for available keyword args to customize\nwrapping behaviour.", 
  "module": "textwrap", 
  "file": "/usr/lib/python3.2/textwrap.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Barrier", 
  "doc": "Barrier.  Useful for synchronizing a fixed number of threads\nat known synchronization points.  Threads block on 'wait()' and are\nsimultaneously once they have all made that call.", 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BoundedSemaphore", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BrokenBarrierError", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Condition", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Event", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Lock", 
  "doc": "allocate_lock() -> lock object\n(allocate() is an obsolete synonym)\n\nCreate a new lock object.  See help(LockType) for information about locks.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "RLock", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Semaphore", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Thread", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ThreadError", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Timer", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WeakSet", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/_weakrefset.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_BoundedSemaphore", 
  "doc": "Semaphore that checks that # releases is <= # acquires", 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_CRLock", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Condition", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_DummyThread", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Event", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_MainThread", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_PyRLock", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_RLock", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Semaphore", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Timer", 
  "doc": "Call a function after a specified number of seconds:\n\nt = Timer(30.0, f, args=[], kwargs={})\nt.start()\nt.cancel() # stop the timer's action if it's still waiting", 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Verbose", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_after_fork", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_allocate_lock", 
  "doc": "allocate_lock() -> lock object\n(allocate() is an obsolete synonym)\n\nCreate a new lock object.  See help(LockType) for information about locks.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_enumerate", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_exc", 
  "doc": "Like print_exc() but return a string.", 
  "module": "threading", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_get_ident", 
  "doc": "get_ident() -> integer\n\nReturn a non-zero integer that uniquely identifies the current thread\namongst other threads that exist simultaneously.\nThis may be used to identify per-thread resources.\nEven though on some platforms threads identities may appear to be\nallocated consecutive numbers starting at 1, this behavior should not\nbe relied upon, and the number should be seen purely as a magic cookie.\nA thread's identity may be reused for another thread after it exits.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_newname", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_pickSomeNonDaemonThread", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_shutdown", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_sleep", 
  "doc": "sleep(seconds)\n\nDelay execution for a given number of seconds.  The argument may be\na floating point number for subsecond precision.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_start_new_thread", 
  "doc": "start_new_thread(function, args[, kwargs])\n(start_new() is an obsolete synonym)\n\nStart a new thread and return its identifier.  The thread will call the\nfunction with positional arguments from the tuple args and keyword arguments\ntaken from the optional dictionary kwargs.  The thread exits when the\nfunction returns; the return value is ignored.  The thread will also exit\nwhen the function raises an unhandled exception; a stack trace will be\nprinted unless the exception is SystemExit.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "_sys", 
  "file": null
 }, 
 {
  "name": "_time", 
  "doc": "time() -> floating point number\n\nReturn the current time in seconds since the Epoch.\nFractions of a second may be present if the system clock provides them.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "activeCount", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "active_count", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "currentThread", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "current_thread", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "enumerate", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "local", 
  "doc": "Thread-local data", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "setprofile", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "settrace", 
  "doc": null, 
  "module": "threading", 
  "file": "/usr/lib/python3.2/threading.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "stack_size", 
  "doc": "stack_size([size]) -> size\n\nReturn the thread stack size used when creating new threads.  The\noptional size argument specifies the stack size (in bytes) to be used\nfor subsequently created threads, and must be 0 (use platform or\nconfigured default) or a positive integer value of at least 32,768 (32k).\nIf changing the thread stack size is unsupported, a ThreadError\nexception is raised.  If the specified size is invalid, a ValueError\nexception is raised, and the stack size is unmodified.  32k bytes\n currently the minimum supported stack size value to guarantee\nsufficient stack space for the interpreter itself.\n\nNote that some platforms may have particular restrictions on values for\nthe stack size, such as requiring a minimum stack size larger than 32kB or\nrequiring allocation in multiples of the system memory page size\n- platform documentation should be referred to for more information\n(4kB pages are common; using multiples of 4096 for the stack size is\nthe suggested approach in the absence of more specific information).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Timer", 
  "doc": "Class for timing execution speed of small code snippets.\n\nThe constructor takes a statement to be timed, an additional\nstatement used for setup, and a timer function.  Both statements\ndefault to 'pass'; the timer function is platform-dependent (see\nmodule doc string).\n\nTo measure the execution time of the first statement, use the\ntimeit() method.  The repeat() method is a convenience to call\ntimeit() multiple times and return a list of results.\n\nThe statements may contain newlines, as long as they don't contain\nmulti-line string literals.", 
  "module": "timeit", 
  "file": "/usr/lib/python3.2/timeit.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_template_func", 
  "doc": "Create a timer function. Used if the \"statement\" is a callable.", 
  "module": "timeit", 
  "file": "/usr/lib/python3.2/timeit.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "default_timer", 
  "doc": "time() -> floating point number\n\nReturn the current time in seconds since the Epoch.\nFractions of a second may be present if the system clock provides them.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to the garbage collector for reference cycles.\n\nenable() -- Enable automatic garbage collection.\ndisable() -- Disable automatic garbage collection.\nisenabled() -- Returns true if automatic collection is enabled.\ncollect() -- Do a full collection right now.\nget_count() -- Return the current collection counts.\nset_debug() -- Set debugging flags.\nget_debug() -- Get debugging flags.\nset_threshold() -- Set the collection thresholds.\nget_threshold() -- Return the current the collection thresholds.\nget_objects() -- Return a list of all objects tracked by the collector.\nis_tracked() -- Returns true if a given object is tracked.\nget_referrers() -- Return the list of objects that refer to an object.\nget_referents() -- Return the list of objects that an object refers to.", 
  "line": 0, 
  "type": "module", 
  "name": "gc", 
  "file": null
 }, 
 {
  "doc": "Functional tools for creating and using iterators.\n\nInfinite iterators:\ncount([n]) --> n, n+1, n+2, ...\ncycle(p) --> p0, p1, ... plast, p0, p1, ...\nrepeat(elem [,n]) --> elem, elem, elem, ... endlessly or up to n times\n\nIterators terminating on the shortest input sequence:\naccumulate(p, start=0) --> p0, p0+p1, p0+p1+p2\nchain(p, q, ...) --> p0, p1, ... plast, q0, q1, ... \ncompress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...\ndropwhile(pred, seq) --> seq[n], seq[n+1], starting when pred fails\ngroupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)\nfilterfalse(pred, seq) --> elements of seq where pred(elem) is False\nislice(seq, [start,] stop [, step]) --> elements from\n       seq[start:stop:step]\nstarmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...\ntee(it, n=2) --> (it1, it2 , ... itn) splits one iterator into n\ntakewhile(pred, seq) --> seq[0], seq[1], until pred fails\nzip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ... \n\nCombinatoric generators:\nproduct(p, q, ... [repeat=1]) --> cartesian product\npermutations(p[, r])\ncombinations(p, r)\ncombinations_with_replacement(p, r)", 
  "line": 0, 
  "type": "module", 
  "name": "itertools", 
  "file": null
 }, 
 {
  "name": "main", 
  "doc": "Main program, used when run as a script.\n\nThe optional 'args' argument specifies the command line to be parsed,\ndefaulting to sys.argv[1:].\n\nThe return value is an exit code to be passed to sys.exit(); it\nmay be None to indicate success.\n\nWhen an exception happens during timing, a traceback is printed to\nstderr and the return value is 1.  Exceptions at other times\n(including the template compilation) are not caught.\n\n'_wrap_timer' is an internal interface used for unit testing.  If it\nis not None, it must be a callable that accepts a timer function\nand returns another timer function (used for unit testing).", 
  "module": "timeit", 
  "file": "/usr/lib/python3.2/timeit.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reindent", 
  "doc": "Helper to reindent a multi-line statement.", 
  "module": "timeit", 
  "file": "/usr/lib/python3.2/timeit.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "repeat", 
  "doc": "Convenience function to create Timer object and call repeat method.", 
  "module": "timeit", 
  "file": "/usr/lib/python3.2/timeit.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "timeit", 
  "doc": "Convenience function to create Timer object and call timeit method.", 
  "module": "timeit", 
  "file": "/usr/lib/python3.2/timeit.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ISEOF", 
  "doc": null, 
  "module": "token", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ISNONTERMINAL", 
  "doc": null, 
  "module": "token", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ISTERMINAL", 
  "doc": null, 
  "module": "token", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_main", 
  "doc": null, 
  "module": "token", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ISEOF", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ISNONTERMINAL", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ISTERMINAL", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/token.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "StopTokenizing", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextIOWrapper", 
  "doc": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding.\n\nerrors determines the strictness of encoding and decoding (see the\ncodecs.register) and defaults to \"strict\".\n\nnewline can be None, '', '\\n', '\\r', or '\\r\\n'.  It controls the\nhandling of line endings. If it is None, universal newlines is\nenabled.  With this enabled, on input, the lines endings '\\n', '\\r',\nor '\\r\\n' are translated to '\\n' before being returned to the\ncaller. Conversely, on output, '\\n' is translated to the system\ndefault line seperator, os.linesep. If newline is any other of its\nlegal values, that newline becomes the newline when the file is read\nand it is returned untranslated. On output, '\\n' is converted to the\nnewline.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TokenError", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TokenInfo", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Untokenizer", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_get_normal_name", 
  "doc": "Imitates get_normal_name in tokenizer.c.", 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_tokenize", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "any", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "name": "detect_encoding", 
  "doc": "The detect_encoding() function is used to detect the encoding that should\nbe used to decode a Python source file.  It requires one argment, readline,\nin the same way as the tokenize() generator.\n\nIt will call readline a maximum of twice, and return the encoding used\n(as a string) and a list of any lines (left as bytes) it has read in.\n\nIt detects the encoding from the presence of a utf-8 bom or an encoding\ncookie as specified in pep-0263.  If both a bom and a cookie are present,\nbut disagree, a SyntaxError will be raised.  If the encoding cookie is an\ninvalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n'utf-8-sig' is returned.\n\nIf no encoding is specified, then the default of 'utf-8' will be returned.", 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "generate_tokens", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "group", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lookup", 
  "doc": "lookup(encoding) -> CodecInfo\n\nLooks up a codec tuple in the Python codec registry and returns\na CodecInfo object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maybe", 
  "doc": null, 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": "Open a file in read only mode using the encoding detected by\ndetect_encoding().", 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "tokenize", 
  "doc": "The tokenize() generator requires one argment, readline, which\nmust be a callable object which provides the same interface as the\nreadline() method of built-in file objects.  Each call to the function\nshould return one line of input as bytes.  Alternately, readline\ncan be a callable function terminating with StopIteration:\n    readline = open(myfile, 'rb').__next__  # Example of alternate readline\n\nThe generator produces 5-tuples with these members: the token type; the\ntoken string; a 2-tuple (srow, scol) of ints specifying the row and\ncolumn where the token begins in the source; a 2-tuple (erow, ecol) of\nints specifying the row and column where the token ends in the source;\nand the line on which the token was found.  The line passed is the\nlogical line; continuation lines are included.\n\nThe first token sequence will always be an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "untokenize", 
  "doc": "Transform tokens back into Python source code.\nIt returns a bytes object, encoded using the ENCODING\ntoken, which is the first token sequence output by tokenize.\n\nEach element returned by the iterable must be a token sequence\nwith at least two elements, a token number and token value.  If\nonly two tokens are passed, the resulting output is poor.\n\nRound-trip invariant for full input:\n    Untokenized source will match input source exactly\n\nRound-trip invariant for limited intput:\n    # Output bytes will tokenize the back to the input\n    t1 = [tok[:2] for tok in tokenize(f.readline)]\n    newcode = untokenize(t1)\n    readline = BytesIO(newcode).readline\n    t2 = [tok[:2] for tok in tokenize(readline)]\n    assert t1 == t2", 
  "module": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "CoverageResults", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Ignore", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Trace", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Ignore", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_err_exit", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_find_executable_linenos", 
  "doc": "Return dict where keys are line numbers in the line number table.", 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_find_lines", 
  "doc": "Return lineno dict for all code objects reachable from code.", 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_find_lines_from_code", 
  "doc": "Return dict where keys are lines in the line number table.", 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_find_strings", 
  "doc": "Return a dict of possible docstring positions.\n\nThe dict maps line numbers to strings.  There is an entry for\nline that contains only a string or a part of a triple-quoted\nstring.", 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_fullmodname", 
  "doc": "Return a plausible module name for the path.", 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_modname", 
  "doc": "Return a plausible module name for the patch.", 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_settrace", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unsettrace", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_usage", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_warn", 
  "doc": "Issue a warning, or maybe ignore it or raise an exception.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Disassembler of Python byte code into mnemonics.", 
  "line": 0, 
  "type": "module", 
  "name": "dis", 
  "file": "/usr/lib/python3.2/dis.py"
 }, 
 {
  "name": "find_executable_linenos", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find_lines", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find_lines_from_code", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find_strings", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "fullmodname", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to the garbage collector for reference cycles.\n\nenable() -- Enable automatic garbage collection.\ndisable() -- Disable automatic garbage collection.\nisenabled() -- Returns true if automatic collection is enabled.\ncollect() -- Do a full collection right now.\nget_count() -- Return the current collection counts.\nset_debug() -- Set debugging flags.\nget_debug() -- Get debugging flags.\nset_threshold() -- Set the collection thresholds.\nget_threshold() -- Return the current the collection thresholds.\nget_objects() -- Return a list of all objects tracked by the collector.\nis_tracked() -- Returns true if a given object is tracked.\nget_referrers() -- Return the list of objects that refer to an object.\nget_referents() -- Return the list of objects that an object refers to.", 
  "line": 0, 
  "type": "module", 
  "name": "gc", 
  "file": null
 }, 
 {
  "doc": "Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargspec(), getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python-3000 features\n    formatargspec(), formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback", 
  "line": 0, 
  "type": "module", 
  "name": "inspect", 
  "file": "/usr/lib/python3.2/inspect.py"
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "modname", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Create portable serialized representations of Python objects.\n\nSee module copyreg for a mechanism for registering custom picklers.\nSee module pickletools source for extensive comments.\n\nClasses:\n\n    Pickler\n    Unpickler\n\nFunctions:\n\n    dump(object, file)\n    dumps(object) -> string\n    load(file) -> object\n    loads(string) -> object\n\nMisc variables:\n\n    __version__\n    format_version\n    compatible_formats", 
  "line": 0, 
  "type": "module", 
  "name": "pickle", 
  "file": "/usr/lib/python3.2/pickle.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "Thread module emulating a subset of Java's threading model.", 
  "line": 0, 
  "type": "module", 
  "name": "threading", 
  "file": "/usr/lib/python3.2/threading.py"
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "Token constants (from \"token.h\").", 
  "line": 0, 
  "type": "module", 
  "name": "token", 
  "file": "/usr/lib/python3.2/token.py"
 }, 
 {
  "doc": "Tokenization help for Python programs.\n\ntokenize(readline) is a generator that breaks a stream of bytes into\nPython tokens.  It decodes the bytes according to PEP-0263 for\ndetermining source file encoding.\n\nIt accepts a readline-like method which is called repeatedly to get the\nnext line of input (or b\"\" for EOF).  It generates 5-tuples with these\nmembers:\n\n    the token type (see token.py)\n    the token (a string)\n    the starting (row, column) indices of the token (a 2-tuple of ints)\n    the ending (row, column) indices of the token (a 2-tuple of ints)\n    the original line (string)\n\nIt is designed to match the working of the Python tokenizer exactly, except\nthat it produces COMMENT tokens for comments and gives type OP for all\noperators.  Additionally, all token lists start with an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.", 
  "line": 0, 
  "type": "module", 
  "name": "tokenize", 
  "file": "/usr/lib/python3.2/tokenize.py"
 }, 
 {
  "name": "usage", 
  "doc": null, 
  "module": "trace", 
  "file": "/usr/lib/python3.2/trace.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_format_final_exc_line", 
  "doc": null, 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_iter_chain", 
  "doc": null, 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_print", 
  "doc": null, 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_some_str", 
  "doc": null, 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "extract_stack", 
  "doc": "Extract the raw traceback from the current stack frame.\n\nThe return value has the same format as for extract_tb().  The\noptional 'f' and 'limit' arguments have the same meaning as for\nprint_stack().  Each item in the list is a quadruple (filename,\nline number, function name, text), and the entries are in order\nfrom oldest to newest stack frame.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "extract_tb", 
  "doc": "Return list of up to limit pre-processed entries from traceback.\n\nThis is useful for alternate formatting of stack traces.  If\n'limit' is omitted or None, all entries are extracted.  A\npre-processed stack trace entry is a quadruple (filename, line\nnumber, function name, text) representing the information that is\nusually printed for a stack trace.  The text is a string with\nleading and trailing whitespace stripped; if the source is not\navailable it is None.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_exc", 
  "doc": "Like print_exc() but return a string.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_exception", 
  "doc": "Format a stack trace and the exception information.\n\nThe arguments have the same meaning as the corresponding arguments\nto print_exception().  The return value is a list of strings, each\nending in a newline and some containing internal newlines.  When\nthese lines are concatenated and printed, exactly the same text is\nprinted as does print_exception().", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_exception_only", 
  "doc": "Format the exception part of a traceback.\n\nThe arguments are the exception type and value such as given by\nsys.last_type and sys.last_value. The return value is a list of\nstrings, each ending in a newline.\n\nNormally, the list contains a single string; however, for\nSyntaxError exceptions, it contains several lines that (when\nprinted) display detailed information about where the syntax\nerror occurred.\n\nThe message indicating which exception occurred is always the last\nstring in the list.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_list", 
  "doc": "Format a list of traceback entry tuples for printing.\n\nGiven a list of tuples as returned by extract_tb() or\nextract_stack(), return a list of strings ready for printing.\nEach string in the resulting list corresponds to the item with the\nsame index in the argument list.  Each string ends in a newline;\nthe strings may contain internal newlines as well, for those items\nwhose source text line is not None.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_stack", 
  "doc": "Shorthand for 'format_list(extract_stack(f, limit))'.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_tb", 
  "doc": "A shorthand for 'format_list(extract_stack(f, limit)).", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "print_exc", 
  "doc": "Shorthand for 'print_exception(*sys.exc_info(), limit, file)'.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_exception", 
  "doc": "Print exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\nThis differs from print_tb() in the following ways: (1) if\ntraceback is not None, it prints a header \"Traceback (most recent\ncall last):\"; (2) it prints the exception type and value after the\nstack trace; (3) if type is SyntaxError and value has the\nappropriate format, it prints the line where the syntax error\noccurred with a caret on the next line indicating the approximate\nposition of the error.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_last", 
  "doc": "This is a shorthand for 'print_exception(sys.last_type,\nsys.last_value, sys.last_traceback, limit, file)'.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_list", 
  "doc": "Print the list of tuples as returned by extract_tb() or\nextract_stack() as a formatted stack trace to the given file.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_stack", 
  "doc": "Print a stack trace from its invocation point.\n\nThe optional 'f' argument can be used to specify an alternate\nstack frame at which to start. The optional 'limit' and 'file'\narguments have the same meaning as for print_exception().", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "print_tb", 
  "doc": "Print up to 'limit' stack trace entries from the traceback 'tb'.\n\nIf 'limit' is omitted or None, all entries are printed.  If 'file'\nis omitted or None, the output goes to sys.stderr; otherwise\n'file' should be an open file or file-like object with a write()\nmethod.", 
  "module": "traceback", 
  "file": "/usr/lib/python3.2/traceback.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "tty", 
  "file": "/usr/lib/python3.2/lib-dynload/termios.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "setcbreak", 
  "doc": "Put terminal into a cbreak mode.", 
  "module": "tty", 
  "file": "/usr/lib/python3.2/tty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setraw", 
  "doc": "Put terminal into a raw mode.", 
  "module": "tty", 
  "file": "/usr/lib/python3.2/tty.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcdrain", 
  "doc": "tcdrain(fd) -> None\n\nWait until all output written to file descriptor fd has been transmitted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcflow", 
  "doc": "tcflow(fd, action) -> None\n\nSuspend or resume input or output on file descriptor fd.\nThe action argument can be termios.TCOOFF to suspend output,\ntermios.TCOON to restart output, termios.TCIOFF to suspend input,\nor termios.TCION to restart input.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcflush", 
  "doc": "tcflush(fd, queue) -> None\n\nDiscard queued data on file descriptor fd.\nThe queue selector specifies which queue: termios.TCIFLUSH for the input\nqueue, termios.TCOFLUSH for the output queue, or termios.TCIOFLUSH for\nboth queues. ", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcgetattr", 
  "doc": "tcgetattr(fd) -> list_of_attrs\n\nGet the tty attributes for file descriptor fd, as follows:\n[iflag, oflag, cflag, lflag, ispeed, ospeed, cc] where cc is a list\nof the tty special characters (each a string of length 1, except the items\nwith indices VMIN and VTIME, which are integers when these fields are\ndefined).  The interpretation of the flags and the speeds as well as the\nindexing in the cc array must be done using the symbolic constants defined\nin this module.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcsendbreak", 
  "doc": "tcsendbreak(fd, duration) -> None\n\nSend a break on file descriptor fd.\nA zero duration sends a break for 0.25-0.5 seconds; a nonzero duration\nhas a system dependent meaning.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcsetattr", 
  "doc": "tcsetattr(fd, when, attributes) -> None\n\nSet the tty attributes for file descriptor fd.\nThe attributes to be set are taken from the attributes argument, which\nis a list like the one returned by tcgetattr(). The when argument\ndetermines when the attributes are changed: termios.TCSANOW to\nchange immediately, termios.TCSADRAIN to change after transmitting all\nqueued output, or termios.TCSAFLUSH to change after transmitting all\nqueued output and discarding all queued input. ", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BuiltinFunctionType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BuiltinMethodType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "CodeType", 
  "doc": "code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,\n      constants, names, varnames, filename, name, firstlineno,\n      lnotab[, freevars[, cellvars]])\n\nCreate a code object.  Not for the faint of heart.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FrameType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FunctionType", 
  "doc": "function(code, globals[, name[, argdefs[, closure]]])\n\nCreate a function object from a code object and a dictionary.\nThe optional name string overrides the name from the code object.\nThe optional argdefs tuple specifies the default argument values.\nThe optional closure tuple supplies the bindings for free variables.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "GeneratorType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "GetSetDescriptorType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LambdaType", 
  "doc": "function(code, globals[, name[, argdefs[, closure]]])\n\nCreate a function object from a code object and a dictionary.\nThe optional name string overrides the name from the code object.\nThe optional argdefs tuple specifies the default argument values.\nThe optional closure tuple supplies the bindings for free variables.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MemberDescriptorType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MethodType", 
  "doc": "method(function, instance)\n\nCreate a bound instance method object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ModuleType", 
  "doc": "module(name[, doc])\n\nCreate a module object.\nThe name must be a string; the optional doc argument can have any type.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TracebackType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BaseTestSuite", 
  "doc": "A simple test suite that doesn't provide class or module shared fixtures.\n    ", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/suite.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FunctionTestCase", 
  "doc": "A test case that wraps a test function.\n\nThis is useful for slipping pre-existing test functions into the\nunittest framework. Optionally, set-up and tidy-up functions can be\nsupplied. As with TestCase, the tidy-up ('tearDown') function will\nalways be called if the set-up ('setUp') function ran successfully.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SkipTest", 
  "doc": "Raise this exception in a test to skip it.\n\nUsually you can use TestResult.skip() or one of the skipping decorators\ninstead of raising this directly.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TestCase", 
  "doc": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TestLoader", 
  "doc": "This class is responsible for loading tests according to various criteria\nand returning them wrapped in a TestSuite", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/loader.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TestProgram", 
  "doc": "A command-line program that runs a set of tests; this is primarily\nfor making test modules conveniently executable.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/main.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TestResult", 
  "doc": "Holder for test result information.\n\nTest results are automatically managed by the TestCase and TestSuite\nclasses, and do not need to be explicitly manipulated by writers of tests.\n\nEach instance holds the total number of tests run, and collections of\nfailures and errors that occurred among those test runs. The collections\ncontain tuples of (testcase, exceptioninfo), where exceptioninfo is the\nformatted traceback of the error that occurred.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/result.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TestSuite", 
  "doc": "A test suite is a composite test consisting of a number of TestCases.\n\nFor use, create an instance of TestSuite, then add test case instances.\nWhen all tests have been added, the suite can be passed to a test\nrunner, such as TextTestRunner. It will run the individual test cases\nin the order in which they were added, aggregating the results. When\nsubclassing, do not forget to call the base class constructor.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/suite.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextTestResult", 
  "doc": "A test result class that can print formatted text results to a stream.\n\nUsed by TextTestRunner.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/runner.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "TextTestRunner", 
  "doc": "A test runner class that displays results in textual form.\n\nIt prints out the names of tests as they are run, errors as they\noccur, and a summary of the results at the end of the test run.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/runner.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_TextTestResult", 
  "doc": "A test result class that can print formatted text results to a stream.\n\nUsed by TextTestRunner.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/runner.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Test case implementation", 
  "line": 0, 
  "type": "module", 
  "name": "case", 
  "file": "/usr/lib/python3.2/unittest/case.py"
 }, 
 {
  "name": "expectedFailure", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findTestCases", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/loader.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getTestCaseNames", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/loader.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "installHandler", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/signals.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Loading unittests.", 
  "line": 0, 
  "type": "module", 
  "name": "loader", 
  "file": "/usr/lib/python3.2/unittest/loader.py"
 }, 
 {
  "name": "main", 
  "doc": "A command-line program that runs a set of tests; this is primarily\nfor making test modules conveniently executable.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/main.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "makeSuite", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/loader.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "registerResult", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/signals.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "removeHandler", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/signals.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "removeResult", 
  "doc": null, 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/signals.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Test result object", 
  "line": 0, 
  "type": "module", 
  "name": "result", 
  "file": "/usr/lib/python3.2/unittest/result.py"
 }, 
 {
  "doc": "Running tests", 
  "line": 0, 
  "type": "module", 
  "name": "runner", 
  "file": "/usr/lib/python3.2/unittest/runner.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "signals", 
  "file": "/usr/lib/python3.2/unittest/signals.py"
 }, 
 {
  "name": "skip", 
  "doc": "Unconditionally skip a test.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "skipIf", 
  "doc": "Skip a test if the condition is true.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "skipUnless", 
  "doc": "Skip a test unless the condition is true.", 
  "module": "unittest", 
  "file": "/usr/lib/python3.2/unittest/case.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "TestSuite", 
  "line": 0, 
  "type": "module", 
  "name": "suite", 
  "file": "/usr/lib/python3.2/unittest/suite.py"
 }, 
 {
  "doc": "Various utility functions.", 
  "line": 0, 
  "type": "module", 
  "name": "util", 
  "file": "/usr/lib/python3.2/unittest/util.py"
 }, 
 {
  "doc": "Parse (absolute and relative) URLs.\n\nurlparse module is based upon the following RFC specifications.\n\nRFC 3986 (STD66): \"Uniform Resource Identifiers\" by T. Berners-Lee, R. Fielding\nand L.  Masinter, January 2005.\n\nRFC 2732 : \"Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter\nand L.Masinter, December 1999.\n\nRFC 2396:  \"Uniform Resource Identifiers (URI)\": Generic Syntax by T.\nBerners-Lee, R. Fielding, and L. Masinter, August 1998.\n\nRFC 2368: \"The mailto URL scheme\", by P.Hoffman , L Masinter, J. Zawinski, July 1998.\n\nRFC 1808: \"Relative Uniform Resource Locators\", by R. Fielding, UC Irvine, June\n1995.\n\nRFC 1738: \"Uniform Resource Locators (URL)\" by T. Berners-Lee, L. Masinter, M.\nMcCahill, December 1994\n\nRFC 3986 is considered the current standard and any future changes to\nurlparse module should conform with it.  The urlparse module is\ncurrently not entirely compliant with this RFC due to defacto\nscenarios for parsing, and for backward compatibility purposes, some\nparsing quirks from older RFCs are retained. The testcases in\ntest_urlparse.py provides a good indicator of parsing behavior.", 
  "line": 0, 
  "type": "module", 
  "name": "parse", 
  "file": "/usr/lib/python3.2/urllib/parse.py"
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "uu", 
  "file": "/usr/lib/python3.2/uu.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Conversion between binary data and ASCII", 
  "line": 0, 
  "type": "module", 
  "name": "binascii", 
  "file": null
 }, 
 {
  "name": "decode", 
  "doc": "Decode uuencoded file", 
  "module": "uu", 
  "file": "/usr/lib/python3.2/uu.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "Uuencode file", 
  "module": "uu", 
  "file": "/usr/lib/python3.2/uu.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": "uuencode/uudecode main program", 
  "module": "uu", 
  "file": "/usr/lib/python3.2/uu.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "UUID", 
  "doc": "Instances of the UUID class represent UUIDs as specified in RFC 4122.\nUUID objects are immutable, hashable, and usable as dictionary keys.\nConverting a UUID to a string with str() yields something in the form\n'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\nfive possible forms: a similar string of hexadecimal digits, or a tuple\nof six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n48-bit values respectively) as an argument named 'fields', or a string\nof 16 bytes (with all the integer fields in big-endian order) as an\nargument named 'bytes', or a string of 16 bytes (with the first three\nfields in little-endian order) as an argument named 'bytes_le', or a\nsingle 128-bit integer as an argument named 'int'.\n\nUUIDs have these read-only attributes:\n\n    bytes       the UUID as a 16-byte string (containing the six\n                integer fields in big-endian byte order)\n\n    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                and time_hi_version in little-endian byte order)\n\n    fields      a tuple of the six integer fields of the UUID,\n                which are also available as six individual attributes\n                and two derived attributes:\n\n        time_low                the first 32 bits of the UUID\n        time_mid                the next 16 bits of the UUID\n        time_hi_version         the next 16 bits of the UUID\n        clock_seq_hi_variant    the next 8 bits of the UUID\n        clock_seq_low           the next 8 bits of the UUID\n        node                    the last 48 bits of the UUID\n\n        time                    the 60-bit timestamp\n        clock_seq               the 14-bit sequence number\n\n    hex         the UUID as a 32-character hexadecimal string\n\n    int         the UUID as a 128-bit integer\n\n    urn         the UUID as a URN as specified in RFC 4122\n\n    variant     the UUID variant (one of the constants RESERVED_NCS,\n                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n    version     the UUID version number (1 through 5, meaningful only\n                when the variant is RFC_4122)", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_find_mac", 
  "doc": null, 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ifconfig_getnode", 
  "doc": "Get the hardware address on Unix by running ifconfig.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ipconfig_getnode", 
  "doc": "Get the hardware address on Windows by running ipconfig.exe.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_netbios_getnode", 
  "doc": "Get the hardware address on Windows using NetBIOS calls.\nSee http://support.microsoft.com/kb/118623 for details.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_random_getnode", 
  "doc": "Get a random node ID, with eighth bit set as suggested by RFC 4122.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_unixdll_getnode", 
  "doc": "Get the hardware address on Unix using ctypes.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_windll_getnode", 
  "doc": "Get the hardware address on Windows using ctypes.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bytes_", 
  "doc": "bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "create and manipulate C data types in Python", 
  "line": 0, 
  "type": "module", 
  "name": "ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py"
 }, 
 {
  "name": "getnode", 
  "doc": "Get the hardware address as a 48-bit positive integer.\n\nThe first time this runs, it may launch a separate program, which could\nbe quite slow.  If all attempts to obtain the hardware address fail, we\nchoose a random 48-bit number with its eighth bit set to 1 as recommended\nin RFC 4122.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "int_", 
  "doc": "int(x[, base]) -> integer\n\nConvert a string or number to an integer, if possible.  A floating\npoint argument will be truncated towards zero (this does not include a\nstring representation of a floating point number!)  When converting a\nstring, use the optional base.  It is an error to supply a base when\nconverting a non-string.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "uuid1", 
  "doc": "Generate a UUID from a host ID, sequence number, and the current time.\nIf 'node' is not given, getnode() is used to obtain the hardware\naddress.  If 'clock_seq' is given, it is used as the sequence number;\notherwise a random 14-bit sequence number is chosen.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "uuid3", 
  "doc": "Generate a UUID from the MD5 hash of a namespace UUID and a name.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "uuid4", 
  "doc": "Generate a random UUID.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "uuid5", 
  "doc": "Generate a UUID from the SHA-1 hash of a namespace UUID and a name.", 
  "module": "uuid", 
  "file": "/usr/lib/python3.2/uuid.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "WarningMessage", 
  "doc": "Holds the result of a single showwarning() call.", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_OptionError", 
  "doc": "Exception used by option processing helpers.", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_getaction", 
  "doc": null, 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_getcategory", 
  "doc": null, 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_processoptions", 
  "doc": null, 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_setoption", 
  "doc": null, 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "catch_warnings", 
  "doc": "A context manager that copies and restores the warnings filter upon\nexiting the context.\n\nThe 'record' argument specifies whether warnings should be captured by a\ncustom implementation of warnings.showwarning() and be appended to a list\nreturned by the context manager. Otherwise None is returned by the context\nmanager. The objects appended to the list are arguments whose attributes\nmirror the arguments to showwarning().\n\nThe 'module' argument is to specify an alternative module to the module\nnamed 'warnings' and imported under that name. This argument is only useful\nwhen testing the warnings module itself.", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "filterwarnings", 
  "doc": "Insert an entry into the list of warnings filters (at the front).\n\n'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n            or \"once\"\n'message' -- a regex that the warning message must match\n'category' -- a class that the warning must be a subclass of\n'module' -- a regex that the module name must match\n'lineno' -- an integer line number, 0 matches all warnings\n'append' -- if true, append to the list of filters", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "formatwarning", 
  "doc": "Function to format a warning the standard way.", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Cache lines from files.\n\nThis is intended to read lines from modules imported -- hence if a filename\nis not found, it will look down the module search path for a file by\nthat name.", 
  "line": 0, 
  "type": "module", 
  "name": "linecache", 
  "file": "/usr/lib/python3.2/linecache.py"
 }, 
 {
  "name": "resetwarnings", 
  "doc": "Clear the list of warning filters, so that no filters are active.", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "showwarning", 
  "doc": "Hook to write a warning to a file; replace if you like.", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "simplefilter", 
  "doc": "Insert a simple entry into the list of warnings filters (at the front).\n\nA simple filter matches all modules and messages.\n'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n            or \"once\"\n'category' -- a class that the warning must be a subclass of\n'lineno' -- an integer line number, 0 matches all warnings\n'append' -- if true, append to the list of filters", 
  "module": "warnings", 
  "file": "/usr/lib/python3.2/warnings.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "warn", 
  "doc": "Issue a warning, or maybe ignore it or raise an exception.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "warn_explicit", 
  "doc": "Low-level inferface to warnings functionality.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Chunk", 
  "doc": null, 
  "module": "wave", 
  "file": "/usr/lib/python3.2/chunk.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "wave", 
  "file": "/usr/lib/python3.2/wave.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Wave_read", 
  "doc": "Variables used in this class:\n\nThese variables are available to the user though appropriate\nmethods of this class:\n_file -- the open file with methods read(), close(), and seek()\n          set through the __init__() method\n_nchannels -- the number of audio channels\n          available through the getnchannels() method\n_nframes -- the number of audio frames\n          available through the getnframes() method\n_sampwidth -- the number of bytes per audio sample\n          available through the getsampwidth() method\n_framerate -- the sampling frequency\n          available through the getframerate() method\n_comptype -- the AIFF-C compression type ('NONE' if AIFF)\n          available through the getcomptype() method\n_compname -- the human-readable AIFF-C compression type\n          available through the getcomptype() method\n_soundpos -- the position in the audio stream\n          available through the tell() method, set through the\n          setpos() method\n\nThese variables are used internally only:\n_fmt_chunk_read -- 1 iff the FMT chunk has been read\n_data_seek_needed -- 1 iff positioned correctly in audio\n          file for readframes()\n_data_chunk -- instantiation of a chunk class for the DATA chunk\n_framesize -- size of one frame in the file", 
  "module": "wave", 
  "file": "/usr/lib/python3.2/wave.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Wave_write", 
  "doc": "Variables used in this class:\n\nThese variables are user settable through appropriate methods\nof this class:\n_file -- the open file with methods write(), close(), tell(), seek()\n          set through the __init__() method\n_comptype -- the AIFF-C compression type ('NONE' in AIFF)\n          set through the setcomptype() or setparams() method\n_compname -- the human-readable AIFF-C compression type\n          set through the setcomptype() or setparams() method\n_nchannels -- the number of audio channels\n          set through the setnchannels() or setparams() method\n_sampwidth -- the number of bytes per audio sample\n          set through the setsampwidth() or setparams() method\n_framerate -- the sampling frequency\n          set through the setframerate() or setparams() method\n_nframes -- the number of audio frames written to the header\n          set through the setnframes() or setparams() method\n\nThese variables are used internally only:\n_datalength -- the size of the audio samples written to the header\n_nframeswritten -- the number of frames actually written\n_datawritten -- the size of the audio samples actually written", 
  "module": "wave", 
  "file": "/usr/lib/python3.2/wave.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 
  "line": 0, 
  "type": "module", 
  "name": "builtins", 
  "file": null
 }, 
 {
  "name": "open", 
  "doc": null, 
  "module": "wave", 
  "file": "/usr/lib/python3.2/wave.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "openfp", 
  "doc": null, 
  "module": "wave", 
  "file": "/usr/lib/python3.2/wave.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "name": "CallableProxyType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "KeyedRef", 
  "doc": "Specialized reference that includes a key corresponding to the value.\n\nThis is used in the WeakValueDictionary to avoid having to create\na function object for each key stored in the mapping.  A shared\ncallback object can use the 'key' attribute of a KeyedRef instead\nof getting a reference to the key from an enclosing scope.", 
  "module": "weakref", 
  "file": "/usr/lib/python3.2/weakref.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ProxyType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ReferenceType", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "WeakKeyDictionary", 
  "doc": "Mapping class that references keys weakly.\n\nEntries in the dictionary will be discarded when there is no\nlonger a strong reference to the key. This can be used to\nassociate additional data with an object owned by other parts of\nan application without adding attributes to those objects. This\ncan be especially useful with objects that override attribute\naccesses.", 
  "module": "weakref", 
  "file": "/usr/lib/python3.2/weakref.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "WeakSet", 
  "doc": null, 
  "module": "weakref", 
  "file": "/usr/lib/python3.2/_weakrefset.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "WeakValueDictionary", 
  "doc": "Mapping class that references values weakly.\n\nEntries in the dictionary will be discarded when no strong\nreference to the value exists anymore", 
  "module": "weakref", 
  "file": "/usr/lib/python3.2/weakref.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_IterationGuard", 
  "doc": null, 
  "module": "weakref", 
  "file": "/usr/lib/python3.2/_weakrefset.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "collections", 
  "file": "/usr/lib/python3.2/collections.py"
 }, 
 {
  "name": "getweakrefcount", 
  "doc": "getweakrefcount(object) -- return the number of weak references\nto 'object'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getweakrefs", 
  "doc": "getweakrefs(object) -- return a list of all weak reference objects\nthat point to 'object'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "proxy", 
  "doc": "proxy(object[, callback]) -- create a proxy object that weakly\nreferences 'object'.  'callback', if given, is called with a\nreference to the proxy when 'object' is about to be finalized.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ref", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BackgroundBrowser", 
  "doc": "Class for all browsers which are to be started in the\nbackground.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BaseBrowser", 
  "doc": "Parent class for all browsers. Do not use directly.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Elinks", 
  "doc": "Launcher class for Elinks browsers.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Galeon", 
  "doc": "Launcher class for Galeon/Epiphany browsers.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "GenericBrowser", 
  "doc": "Class for all browsers started with a command\nand without remote functionality.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Grail", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Konqueror", 
  "doc": "Controller for the KDE File Manager (kfm, or Konqueror).\n\nSee the output of ``kfmclient --commands``\nfor more information on the Konqueror remote-control interface.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Mozilla", 
  "doc": "Launcher class for Mozilla/Netscape browsers.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Netscape", 
  "doc": "Launcher class for Mozilla/Netscape browsers.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Opera", 
  "doc": "Launcher class for Opera browser.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnixBrowser", 
  "doc": "Parent class for all Unix browsers with remote functionality.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_iscommand", 
  "doc": "Return True if cmd is executable or can be found on the executable\nsearch path.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_isexecutable", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_synthesize", 
  "doc": "Attempt to synthesize a controller base on existing controllers.\n\nThis is useful to create a controller when a user specifies a path to\nan entry in the BROWSER environment variable -- we can copy a general\ncontroller to operate using a specific installation of the desired\nbrowser in this way.\n\nIf we can't create a controller in this way, or if there is no\nexecutable for the requested browser, return [None, None].", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get", 
  "doc": "Return a browser launcher instance appropriate for the environment.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open_new", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "open_new_tab", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "register", 
  "doc": "Register a browser connector and, optionally, connection.", 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_X_browsers", 
  "doc": null, 
  "module": "webbrowser", 
  "file": "/usr/lib/python3.2/webbrowser.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "A lexical analyzer class for simple shell-like syntaxes.", 
  "line": 0, 
  "type": "module", 
  "name": "shlex", 
  "file": "/usr/lib/python3.2/shlex.py"
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "doc": "subprocess - Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.  This module\nintends to replace several other, older modules and functions, like:\n\nos.system\nos.spawn*\n\nInformation about how the subprocess module can be used to replace these\nmodules and functions can be found below.\n\n\n\nUsing the subprocess module\n===========================\nThis module defines one class called Popen:\n\nclass Popen(args, bufsize=0, executable=None,\n            stdin=None, stdout=None, stderr=None,\n            preexec_fn=None, close_fds=True, shell=False,\n            cwd=None, env=None, universal_newlines=False,\n            startupinfo=None, creationflags=0,\n            restore_signals=True, start_new_session=False, pass_fds=()):\n\n\nArguments are:\n\nargs should be a string, or a sequence of program arguments.  The\nprogram to execute is normally the first item in the args sequence or\nstring, but can be explicitly set by using the executable argument.\n\nOn POSIX, with shell=False (default): In this case, the Popen class\nuses os.execvp() to execute the child program.  args should normally\nbe a sequence.  A string will be treated as a sequence with the string\nas the only item (the program to execute).\n\nOn POSIX, with shell=True: If args is a string, it specifies the\ncommand string to execute through the shell.  If args is a sequence,\nthe first item specifies the command string, and any additional items\nwill be treated as additional shell arguments.\n\nOn Windows: the Popen class uses CreateProcess() to execute the child\nprogram, which operates on strings.  If args is a sequence, it will be\nconverted to a string using the list2cmdline method.  Please note that\nnot all MS Windows applications interpret the command line the same\nway: The list2cmdline is designed for applications using the same\nrules as the MS C runtime.\n\nbufsize, if given, has the same meaning as the corresponding argument\nto the built-in open() function: 0 means unbuffered, 1 means line\nbuffered, any other positive value means use a buffer of\n(approximately) that size.  A negative bufsize means to use the system\ndefault, which usually means fully buffered.  The default value for\nbufsize is 0 (unbuffered).\n\nstdin, stdout and stderr specify the executed programs' standard\ninput, standard output and standard error file handles, respectively.\nValid values are PIPE, an existing file descriptor (a positive\ninteger), an existing file object, and None.  PIPE indicates that a\nnew pipe to the child should be created.  With None, no redirection\nwill occur; the child's file handles will be inherited from the\nparent.  Additionally, stderr can be STDOUT, which indicates that the\nstderr data from the applications should be captured into the same\nfile handle as for stdout.\n\nOn POSIX, if preexec_fn is set to a callable object, this object will be\ncalled in the child process just before the child is executed.  The use\nof preexec_fn is not thread safe, using it in the presence of threads\ncould lead to a deadlock in the child process before the new executable\nis executed.\n\nIf close_fds is true, all file descriptors except 0, 1 and 2 will be\nclosed before the child process is executed.  The default for close_fds\nvaries by platform:  Always true on POSIX.  True when stdin/stdout/stderr\nare None on Windows, false otherwise.\n\npass_fds is an optional sequence of file descriptors to keep open between the\nparent and child.  Providing any pass_fds implicitly sets close_fds to true.\n\nif shell is true, the specified command will be executed through the\nshell.\n\nIf cwd is not None, the current directory will be changed to cwd\nbefore the child is executed.\n\nOn POSIX, if restore_signals is True all signals that Python sets to\nSIG_IGN are restored to SIG_DFL in the child process before the exec.\nCurrently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals.  This\nparameter does nothing on Windows.\n\nOn POSIX, if start_new_session is True, the setsid() system call will be made\nin the child process prior to executing the command.\n\nIf env is not None, it defines the environment variables for the new\nprocess.\n\nIf universal_newlines is true, the file objects stdout and stderr are\nopened as a text files, but lines may be terminated by any of '\\n',\nthe Unix end-of-line convention, '\\r', the old Macintosh convention or\n'\\r\\n', the Windows convention.  All of these external representations\nare seen as '\\n' by the Python program.  Note: This feature is only\navailable if Python is built with universal newline support (the\ndefault).  Also, the newlines attribute of the file objects stdout,\nstdin and stderr are not updated by the communicate() method.\n\nThe startupinfo and creationflags, if given, will be passed to the\nunderlying CreateProcess() function.  They can specify things such as\nappearance of the main window and priority for the new process.\n(Windows only)\n\n\nThis module also defines some shortcut functions:\n\ncall(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> retcode = subprocess.call([\"ls\", \"-l\"])\n\ncheck_call(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete.  If the\n    exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> subprocess.check_call([\"ls\", \"-l\"])\n    0\n\ngetstatusoutput(cmd):\n    Return (status, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple\n    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the\n    returned output will contain output or error messages. A trailing newline\n    is stripped from the output. The exit status for the command can be\n    interpreted according to the rules for the C function wait().  Example:\n\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (256, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (256, 'sh: /bin/junk: not found')\n\ngetoutput(cmd):\n    Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n\ncheck_output(*popenargs, **kwargs):\n    Run command with arguments and return its output as a byte string.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> output = subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n\n\nExceptions\n----------\nExceptions raised in the child process, before the new program has\nstarted to execute, will be re-raised in the parent.  Additionally,\nthe exception object will have one extra attribute called\n'child_traceback', which is a string containing traceback information\nfrom the childs point of view.\n\nThe most common exception raised is OSError.  This occurs, for\nexample, when trying to execute a non-existent file.  Applications\nshould prepare for OSErrors.\n\nA ValueError will be raised if Popen is called with invalid arguments.\n\ncheck_call() and check_output() will raise CalledProcessError, if the\ncalled process returns a non-zero return code.\n\n\nSecurity\n--------\nUnlike some other popen functions, this implementation will never call\n/bin/sh implicitly.  This means that all characters, including shell\nmetacharacters, can safely be passed to child processes.\n\n\nPopen objects\n=============\nInstances of the Popen class have the following methods:\n\npoll()\n    Check if child process has terminated.  Returns returncode\n    attribute.\n\nwait()\n    Wait for child process to terminate.  Returns returncode attribute.\n\ncommunicate(input=None)\n    Interact with process: Send data to stdin.  Read data from stdout\n    and stderr, until end-of-file is reached.  Wait for process to\n    terminate.  The optional input argument should be a string to be\n    sent to the child process, or None, if no data should be sent to\n    the child.\n\n    communicate() returns a tuple (stdout, stderr).\n\n    Note: The data read is buffered in memory, so do not use this\n    method if the data size is large or unlimited.\n\nThe following attributes are also available:\n\nstdin\n    If the stdin argument is PIPE, this attribute is a file object\n    that provides input to the child process.  Otherwise, it is None.\n\nstdout\n    If the stdout argument is PIPE, this attribute is a file object\n    that provides output from the child process.  Otherwise, it is\n    None.\n\nstderr\n    If the stderr argument is PIPE, this attribute is file object that\n    provides error output from the child process.  Otherwise, it is\n    None.\n\npid\n    The process ID of the child process.\n\nreturncode\n    The child return code.  A None value indicates that the process\n    hasn't terminated yet.  A negative value -N indicates that the\n    child was terminated by signal N (POSIX only).\n\n\nReplacing older functions with the subprocess module\n====================================================\nIn this section, \"a ==> b\" means that b can be used as a replacement\nfor a.\n\nNote: All functions in this section fail (more or less) silently if\nthe executed program cannot be found; this module raises an OSError\nexception.\n\nIn the following examples, we assume that the subprocess module is\nimported with \"from subprocess import *\".\n\n\nReplacing /bin/sh shell backquote\n---------------------------------\noutput=`mycmd myarg`\n==>\noutput = Popen([\"mycmd\", \"myarg\"], stdout=PIPE).communicate()[0]\n\n\nReplacing shell pipe line\n-------------------------\noutput=`dmesg | grep hda`\n==>\np1 = Popen([\"dmesg\"], stdout=PIPE)\np2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\n\n\nReplacing os.system()\n---------------------\nsts = os.system(\"mycmd\" + \" myarg\")\n==>\np = Popen(\"mycmd\" + \" myarg\", shell=True)\npid, sts = os.waitpid(p.pid, 0)\n\nNote:\n\n* Calling the program through the shell is usually not required.\n\n* It's easier to look at the returncode attribute than the\n  exitstatus.\n\nA more real-world example would look like this:\n\ntry:\n    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n    if retcode < 0:\n        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n    else:\n        print(\"Child returned\", retcode, file=sys.stderr)\nexcept OSError as e:\n    print(\"Execution failed:\", e, file=sys.stderr)\n\n\nReplacing os.spawn*\n-------------------\nP_NOWAIT example:\n\npid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\npid = Popen([\"/bin/mycmd\", \"myarg\"]).pid\n\n\nP_WAIT example:\n\nretcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\nretcode = call([\"/bin/mycmd\", \"myarg\"])\n\n\nVector example:\n\nos.spawnvp(os.P_NOWAIT, path, args)\n==>\nPopen([path] + args[1:])\n\n\nEnvironment example:\n\nos.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n==>\nPopen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})", 
  "line": 0, 
  "type": "module", 
  "name": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "name": "BytesIO", 
  "doc": "BytesIO([buffer]) -> object\n\nCreate a buffered I/O implementation using an in-memory bytes\nbuffer, ready for reading and writing.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ConversionError", 
  "doc": null, 
  "module": "xdrlib", 
  "file": "/usr/lib/python3.2/xdrlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": "Exception class for this module. Use:\n\nexcept xdrlib.Error, var:\n    # var has the Error instance for the exception\n\nPublic ivars:\n    msg -- contains the message", 
  "module": "xdrlib", 
  "file": "/usr/lib/python3.2/xdrlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Packer", 
  "doc": "Pack various data representations into a buffer.", 
  "module": "xdrlib", 
  "file": "/usr/lib/python3.2/xdrlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Unpacker", 
  "doc": "Unpacks various data representations from the given buffer.", 
  "module": "xdrlib", 
  "file": "/usr/lib/python3.2/xdrlib.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "Python interfaces to XML parsers.\n\nThis package contains one module:\n\nexpat -- Python wrapper for James Clark's Expat parser, with namespace\n         support.", 
  "line": 0, 
  "type": "module", 
  "name": "parsers", 
  "file": "/usr/lib/python3.2/xml/parsers/__init__.py"
 }, 
 {
  "name": "BadZipFile", 
  "doc": null, 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BadZipfile", 
  "doc": null, 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LargeZipFile", 
  "doc": "Raised when writing a zipfile, the zipfile requires ZIP64 extensions\nand those extensions are disabled.", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PyZipFile", 
  "doc": "Class to create ZIP archives with Python library files and packages.", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ZipExtFile", 
  "doc": "File-like object for reading an archive member.\nIs returned by ZipFile.open().", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ZipFile", 
  "doc": "Class with methods to open, read, write, close, list zip files.\n\nz = ZipFile(file, mode=\"r\", compression=ZIP_STORED, allowZip64=False)\n\nfile: Either the path to the file, or a file-like object.\n      If it is a path, the file will be opened and closed by ZipFile.\nmode: The mode can be either read \"r\", write \"w\" or append \"a\".\ncompression: ZIP_STORED (no compression) or ZIP_DEFLATED (requires zlib).\nallowZip64: if True ZipFile will create files with ZIP64 extensions when\n            needed, otherwise it will raise an exception when this would\n            be necessary.", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ZipInfo", 
  "doc": "Class with attributes describing each file in the ZIP archive.", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_EndRecData", 
  "doc": "Return data from the \"End of Central Directory\" record, or None.\n\nThe data is a list of the nine items in the ZIP \"End of central dir\"\nrecord followed by a tenth item, the file seek offset of this record.", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_EndRecData64", 
  "doc": "Read the ZIP64 end-of-archive records and use that to update endrec", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_ZipDecrypter", 
  "doc": "Class to handle decryption of files stored within a ZIP archive.\n\nZIP supports a password-based form of encryption. Even though known\nplaintext attacks have been found against it, it is still useful\nto be able to get data out of such a file.\n\nUsage:\n    zd = _ZipDecrypter(mypwd)\n    plain_char = zd(cypher_char)\n    plain_text = map(zd, cypher_text)", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_check_zipfile", 
  "doc": null, 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Conversion between binary data and ASCII", 
  "line": 0, 
  "type": "module", 
  "name": "binascii", 
  "file": null
 }, 
 {
  "name": "crc32", 
  "doc": "crc32(string[, start]) -- Compute a CRC-32 checksum of string.\n\nAn optional starting value can be specified.  The returned checksum is\nan integer.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module provides the components needed to build your own\n__import__ function.  Undocumented functions are obsolete.", 
  "line": 0, 
  "type": "module", 
  "name": "imp", 
  "file": null
 }, 
 {
  "doc": "The io module provides the Python interfaces to stream handling. The\nbuiltin open function is defined in this module.\n\nAt the top of the I/O hierarchy is the abstract base class IOBase. It\ndefines the basic interface to a stream. Note, however, that there is no\nseparation between reading and writing to streams; implementations are\nallowed to throw an IOError if they do not support a given operation.\n\nExtending IOBase is RawIOBase which deals simply with the reading and\nwriting of raw bytes to a stream. FileIO subclasses RawIOBase to provide\nan interface to OS files.\n\nBufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\nsubclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\nstreams that are readable, writable, and both respectively.\nBufferedRandom provides a buffered interface to random access\nstreams. BytesIO is a simple stream of in-memory bytes.\n\nAnother IOBase subclass, TextIOBase, deals with the encoding and decoding\nof streams into text. TextIOWrapper, which extends it, is a buffered text\ninterface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\nis a in-memory stream for text.\n\nArgument names are not part of the specification, and only the arguments\nof open() are intended to be used as keyword arguments.\n\ndata:\n\nDEFAULT_BUFFER_SIZE\n\n   An int containing the default buffer size used by the module's buffered\n   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n   possible.", 
  "line": 0, 
  "type": "module", 
  "name": "io", 
  "file": "/usr/lib/python3.2/io.py"
 }, 
 {
  "name": "is_zipfile", 
  "doc": "Quickly see if a file is a ZIP file by checking the magic number.\n\nThe filename argument may be a file or file-like object too.", 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "main", 
  "doc": null, 
  "module": "zipfile", 
  "file": "/usr/lib/python3.2/zipfile.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "Utility functions for copying and archiving files and directory trees.\n\nXXX The functions here don't copy the resource fork or other metadata on Mac.", 
  "line": 0, 
  "type": "module", 
  "name": "shutil", 
  "file": "/usr/lib/python3.2/shutil.py"
 }, 
 {
  "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *", 
  "line": 0, 
  "type": "module", 
  "name": "stat", 
  "file": "/usr/lib/python3.2/stat.py"
 }, 
 {
  "doc": "Functions to convert between Python values and C structs.\nPython bytes objects are used to hold the data representing the C struct\nand also as format strings (explained below) to describe the layout of data\nin the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n  @: native order, size & alignment (default)\n  =: native order, std. size & alignment\n  <: little-endian, std. size & alignment\n  >: big-endian, std. size & alignment\n  !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n  ?: _Bool (requires C99; if not available, char is used instead)\n  h:short; H:unsigned short; i:int; I:unsigned int;\n  l:long; L:unsigned long; f:float; d:double.\nSpecial cases (preceding decimal count indicates length):\n  s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n  P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n  q:long long; Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.", 
  "line": 0, 
  "type": "module", 
  "name": "struct", 
  "file": "/usr/lib/python3.2/struct.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "doc": "This module provides various functions to manipulate time values.\n\nThere are two standard representations of time.  One is the number\nof seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\nor a floating point number (to represent fractions of seconds).\nThe Epoch is system-defined; on Unix, it is generally January 1st, 1970.\nThe actual value can be retrieved by calling gmtime(0).\n\nThe other representation is a tuple of 9 integers giving local time.\nThe tuple items are:\n  year (four digits, e.g. 1998)\n  month (1-12)\n  day (1-31)\n  hours (0-23)\n  minutes (0-59)\n  seconds (0-59)\n  weekday (0-6, Monday is 0)\n  Julian day (day in the year, 1-366)\n  DST (Daylight Savings Time) flag (-1, 0 or 1)\nIf the DST flag is 0, the time is given in the regular time zone;\nif it is 1, the time is given in the DST time zone;\nif it is -1, mktime() should guess based on the date and time.\n\nVariables:\n\ntimezone -- difference in seconds between UTC and local standard time\naltzone -- difference in  seconds between UTC and local DST time\ndaylight -- whether local time should reflect DST\ntzname -- tuple of (standard time zone name, DST time zone name)\n\nFunctions:\n\ntime() -- return current time in seconds since the Epoch as a float\nclock() -- return CPU time since process start as a float\nsleep() -- delay for a number of seconds given as a float\ngmtime() -- convert seconds since Epoch to UTC tuple\nlocaltime() -- convert seconds since Epoch to local time tuple\nasctime() -- convert time tuple to string\nctime() -- convert time in seconds to string\nmktime() -- convert local time tuple to seconds since Epoch\nstrftime() -- convert time tuple to string according to format specification\nstrptime() -- parse string to time tuple according to format specification\ntzset() -- change the local timezone", 
  "line": 0, 
  "type": "module", 
  "name": "time", 
  "file": null
 }, 
 {
  "doc": "The functions in this module allow compression and decompression using the\nzlib library, which is based on GNU zip.\n\nadler32(string[, start]) -- Compute an Adler-32 checksum.\ncompress(string[, level]) -- Compress string, with compression level in 1-9.\ncompressobj([level]) -- Return a compressor object.\ncrc32(string[, start]) -- Compute a CRC-32 checksum.\ndecompress(string,[wbits],[bufsize]) -- Decompresses a compressed string.\ndecompressobj([wbits]) -- Return a decompressor object.\n\n'wbits' is window buffer size.\nCompressor objects support compress() and flush() methods; decompressor\nobjects support decompress() and flush().", 
  "line": 0, 
  "type": "module", 
  "name": "zlib", 
  "file": null
 }, 
 {
  "name": "__ASMNAME", 
  "doc": null, 
  "module": "DLFCN", 
  "file": "/usr/lib/python3.2/plat-linux2/DLFCN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__P", 
  "doc": null, 
  "module": "DLFCN", 
  "file": "/usr/lib/python3.2/plat-linux2/DLFCN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__PMT", 
  "doc": null, 
  "module": "DLFCN", 
  "file": "/usr/lib/python3.2/plat-linux2/DLFCN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__STRING", 
  "doc": null, 
  "module": "DLFCN", 
  "file": "/usr/lib/python3.2/plat-linux2/DLFCN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__attribute__", 
  "doc": null, 
  "module": "DLFCN", 
  "file": "/usr/lib/python3.2/plat-linux2/DLFCN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__attribute_format_arg__", 
  "doc": null, 
  "module": "DLFCN", 
  "file": "/usr/lib/python3.2/plat-linux2/DLFCN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "CMSG_FIRSTHDR", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "FD_ZERO", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_LINKLOCAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_LOOPBACK", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_MC_GLOBAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_MC_LINKLOCAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_MC_NODELOCAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_MC_ORGLOCAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_MC_SITELOCAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_SITELOCAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_UNSPECIFIED", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_V4COMPAT", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN6_IS_ADDR_V4MAPPED", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "INT16_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "INT32_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "INT64_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "INT8_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "INTMAX_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_BADCLASS", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_CLASSA", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_CLASSB", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_CLASSC", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_CLASSD", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_EXPERIMENTAL", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "IN_MULTICAST", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "UINT16_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "UINT32_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "UINT64_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "UINT8_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "UINTMAX_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__ASMNAME", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__INT64_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__P", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__PMT", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__SOCKADDR_COMMON", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__STRING", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__UINT64_C", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__attribute__", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__attribute_format_arg__", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__bswap_16", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__bswap_32", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__bswap_64", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__bswap_constant_16", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__bswap_constant_32", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__bswap_constant_64", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "htonl", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "htons", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "major", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "minor", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ntohl", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ntohs", 
  "doc": null, 
  "module": "IN", 
  "file": "/usr/lib/python3.2/plat-linux2/IN.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "FD_ZERO", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__ASMNAME", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__FDELT", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__FD_ZERO", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__P", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__PMT", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__STRING", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__attribute__", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__attribute_format_arg__", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__isleap", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sigemptyset", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sigfillset", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sigisemptyset", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sigmask", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "major", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "minor", 
  "doc": null, 
  "module": "TYPES", 
  "file": "/usr/lib/python3.2/plat-linux2/TYPES.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcodec", 
  "doc": "", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcodec", 
  "doc": "", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcodec", 
  "doc": "", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcodec", 
  "doc": "", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcodec", 
  "doc": "", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getcodec", 
  "doc": "", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Dialect", 
  "doc": "CSV dialect\n\nThe Dialect type records CSV parsing and generation options.", 
  "module": "_csv", 
  "file": "/usr/lib/python3.2/lib-dynload/_csv.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "_csv", 
  "file": "/usr/lib/python3.2/lib-dynload/_csv.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "field_size_limit", 
  "doc": "Sets an upper limit on parsed fields.\n    csv.field_size_limit([limit])\n\nReturns old limit. If limit is not given, no new limit is set and\nthe old limit is returned", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_dialect", 
  "doc": "Return the dialect instance associated with name.\ndialect = csv.get_dialect(name)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "list_dialects", 
  "doc": "Return a list of all know dialect names.\nnames = csv.list_dialects()", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reader", 
  "doc": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)\n\nThe \"iterable\" argument can be any object that returns a line\nof input for each iteration, such as a file object or a list.  The\noptional \"dialect\" parameter is discussed below.  The function\nalso accepts optional keyword arguments which override settings\nprovided by the dialect.\n\nThe returned object is an iterator.  Each iteration returns a row\nof the CSV file (which can span multiple input lines):", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_dialect", 
  "doc": "Create a mapping from a string name to a dialect class.\ndialect = csv.register_dialect(name, dialect)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unregister_dialect", 
  "doc": "Delete the name/dialect mapping associated with a string name.\ncsv.unregister_dialect(name)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "writer", 
  "doc": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)\n\n    [or]\n\n    csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    csv_writer.writerows(rows)\n\nThe \"fileobj\" argument can be any object that supports the file API.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ArgumentError", 
  "doc": null, 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/ctypes/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Array", 
  "doc": "XXX to be provided", 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "CFuncPtr", 
  "doc": "Function Pointer", 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "POINTER", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "PyObj_FromPtr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Py_DECREF", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Py_INCREF", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Structure", 
  "doc": "Structure base class", 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Union", 
  "doc": "Union base class", 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Pointer", 
  "doc": "XXX to be provided", 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_SimpleCData", 
  "doc": "XXX to be provided", 
  "module": "_ctypes", 
  "file": "/usr/lib/python3.2/lib-dynload/_ctypes.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_unpickle", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "addressof", 
  "doc": "addressof(C instance) -> integer\nReturn the address of the C instance internal buffer", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "alignment", 
  "doc": "alignment(C type) -> integer\nalignment(C instance) -> integer\nReturn the alignment requirements of a C instance", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "buffer_info", 
  "doc": "Return buffer interface information", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "byref", 
  "doc": "byref(C instance[, offset=0]) -> byref-object\nReturn a pointer lookalike to a C instance, only usable\nas function argument", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "call_cdeclfunction", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "call_function", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dlclose", 
  "doc": "dlclose a library", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dlopen", 
  "doc": "dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "dlsym", 
  "doc": "find symbol in shared library", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_errno", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pointer", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resize", 
  "doc": "Resize the memory buffer of a ctypes instance", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_errno", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sizeof", 
  "doc": "sizeof(C type) -> integer\nsizeof(C instance) -> integer\nReturn the size in bytes of a C instance", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "func", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "func_si", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "baudrate", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "beep", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "can_change_color", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cbreak", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "color_content", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "color_pair", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "curs_set", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "def_prog_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "def_shell_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "delay_output", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "doupdate", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "echo", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "erasechar", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "_curses", 
  "file": "/usr/lib/python3.2/lib-dynload/_curses.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "filter", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "flash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "flushinp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getmouse", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsyx", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "halfdelay", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_colors", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_ic", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_il", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "has_key", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "init_color", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "init_pair", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "initscr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "intrflush", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "is_term_resized", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isendwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "keyname", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "killchar", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "longname", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "meta", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mouseinterval", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mousemask", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "napms", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "newpad", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "newwin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nl", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nocbreak", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "noecho", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "nonl", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "noqiflush", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "noraw", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pair_content", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "pair_number", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "putp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "qiflush", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "raw", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reset_prog_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reset_shell_mode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resetty", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resize_term", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "resizeterm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "savetty", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setsyx", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setupterm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "start_color", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "termattrs", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "termname", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tigetflag", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tigetnum", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tigetstr", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tparm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "typeahead", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unctrl", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ungetch", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ungetmouse", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "use_default_colors", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "use_env", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bottom_panel", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "_curses_panel", 
  "file": "/usr/lib/python3.2/lib-dynload/_curses_panel.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "new_panel", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "top_panel", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "update_panels", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode_basestring_ascii", 
  "doc": "encode_basestring_ascii(string) -> string\n\nReturn an ASCII-only JSON representation of a Python string", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "make_encoder", 
  "doc": "_iterencode(obj, _current_indent_level) -> iterable", 
  "module": "_json", 
  "file": "/usr/lib/python3.2/lib-dynload/_json.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "make_scanner", 
  "doc": "JSON scanner object", 
  "module": "_json", 
  "file": "/usr/lib/python3.2/lib-dynload/_json.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "scanstring", 
  "doc": "scanstring(string, end, strict=True) -> (string, end)\n\nScan the string s for a JSON string. End is the index of the\ncharacter in s after the quote that started the JSON string.\nUnescapes all valid JSON string escape sequences and raises ValueError\non attempt to decode an invalid string. If strict is False then literal\ncontrol characters are allowed in the string.\n\nReturns a tuple of the decoded string and the index of the character in s\nafter the end quote.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Profiler", 
  "doc": "Profiler(custom_timer=None, time_unit=None, subcalls=True, builtins=True)\n\nBuilds a profiler object using the specified timer function.\nThe default timer is a fast built-in one based on real time.\nFor custom timer functions returning integers, time_unit can\nbe a float specifying a scale (i.e. how long each integer unit\nis, in seconds).", 
  "module": "_lsprof", 
  "file": "/usr/lib/python3.2/lib-dynload/_lsprof.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "profiler_entry", 
  "doc": null, 
  "module": "_lsprof", 
  "file": "/usr/lib/python3.2/lib-dynload/_lsprof.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "profiler_subentry", 
  "doc": null, 
  "module": "_lsprof", 
  "file": "/usr/lib/python3.2/lib-dynload/_lsprof.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MultibyteIncrementalDecoder", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MultibyteIncrementalEncoder", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MultibyteStreamReader", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MultibyteStreamWriter", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__create_codec", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Connection", 
  "doc": "Connection type whose constructor signature is\n\n    Connection(handle, readable=True, writable=True).\n\nThe constructor does *not* duplicate the handle.", 
  "module": "_multiprocessing", 
  "file": "/usr/lib/python3.2/lib-dynload/_multiprocessing.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SemLock", 
  "doc": "Semaphore/Mutex type", 
  "module": "_multiprocessing", 
  "file": "/usr/lib/python3.2/lib-dynload/_multiprocessing.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "address_of_buffer", 
  "doc": "address_of_buffer(obj) -> int\nReturn address of obj assuming obj supports buffer inteface", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "recvfd", 
  "doc": "recvfd(sockfd) -> fd\nReceive a file descriptor over a unix domain socket\nwhose file decriptor is sockfd", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sendfd", 
  "doc": "sendfd(sockfd, fd) -> None\nSend file descriptor given by fd over the unix domain socket\nwhose file decriptor is sockfd", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Cache", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Connection", 
  "doc": "SQLite database connection object.", 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Cursor", 
  "doc": "SQLite database cursor class.", 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DataError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DatabaseError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Error", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IntegrityError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InterfaceError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "InternalError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NotSupportedError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OperationalError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "OptimizedUnicode", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PrepareProtocol", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ProgrammingError", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Row", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Statement", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Warning", 
  "doc": null, 
  "module": "_sqlite3", 
  "file": "/usr/lib/python3.2/sqlite3/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "adapt", 
  "doc": "adapt(obj, protocol, alternate) -> adapt obj to given protocol. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "complete_statement", 
  "doc": "complete_statement(sql)\n\nChecks if a string contains a complete SQL statement. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "connect", 
  "doc": "connect(database[, timeout, isolation_level, detect_types, factory])\n\nOpens a connection to the SQLite database file *database*. You can use\n\":memory:\" to open a database connection to a database that resides in\nRAM instead of on disk.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "enable_callback_tracebacks", 
  "doc": "enable_callback_tracebacks(flag)\n\nEnable or disable callback functions throwing errors to stderr.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "enable_shared_cache", 
  "doc": "enable_shared_cache(do_enable)\n\nEnable or disable shared cache mode for the calling thread.\nExperimental/Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_adapter", 
  "doc": "register_adapter(type, callable)\n\nRegisters an adapter with pysqlite's adapter registry. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "register_converter", 
  "doc": "register_converter(typename, callable)\n\nRegisters a converter with pysqlite. Non-standard.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_pending_threadfunc", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "_test_structmembersType", 
  "doc": "Type containing all structmember types", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_test_thread_state", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "argparsing", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "code_newempty", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "codec_incrementaldecoder", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "codec_incrementalencoder", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "crash_no_current_thread", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "_testcapi", 
  "file": "/usr/lib/python3.2/lib-dynload/_testcapi.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "exception_print", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_B", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_H", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_I", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_K", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_L", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_Z", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_Z_hash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_b", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_h", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_i", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_k", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_keywords", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_l", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_n", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_s", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_s_hash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_s_star", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_tuple", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_u", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_u_hash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_w_star", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_y", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_y_hash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_y_star", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_z", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_z_hash", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getargs_z_star", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "instancemethod", 
  "doc": "instancemethod(function)\n\nBind a function to a class.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "make_exception_with_doc", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "make_memoryview_from_NULL_pointer", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "profile_int", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "raise_exception", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "raise_memoryerror", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "run_in_subinterp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_L_code", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_Z_code", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_broken_memoryview", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_bug_7414", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_capsule", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_config", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_datetime_capi", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_dict_iteration", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_empty_argparse", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_k_code", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_lazy_hash_inheritance", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_list_api", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_long_and_overflow", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_long_api", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_long_long_and_overflow", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_long_numbits", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_longlong_api", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_null_strings", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_s_code", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_string_from_format", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_string_to_double", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_u_code", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_unicode_compare_with_ascii", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_widechar", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "test_with_docstring", 
  "doc": "This is a pretty normal docstring.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "traceback_print", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_aswidechar", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_aswidecharstring", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_encodedecimal", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "unicode_transformdecimaltoascii", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "add", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "adpcm2lin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "alaw2lin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "avg", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "avgpp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "bias", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cross", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "audioop", 
  "file": "/usr/lib/python3.2/lib-dynload/audioop.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "findfactor", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findfit", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "findmax", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getsample", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lin2adpcm", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lin2alaw", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lin2lin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lin2ulaw", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "max", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maxpp", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "minmax", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "mul", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ratecv", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "reverse", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rms", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tomono", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tostereo", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ulaw2lin", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "BZ2Compressor", 
  "doc": "BZ2Compressor([compresslevel=9]) -> compressor object\n\nCreate a new compressor object. This object may be used to compress\ndata sequentially. If you want to compress data in one shot, use the\ncompress() function instead. The compresslevel parameter, if given,\nmust be a number between 1 and 9.", 
  "module": "bz2", 
  "file": "/usr/lib/python3.2/lib-dynload/bz2.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BZ2Decompressor", 
  "doc": "BZ2Decompressor() -> decompressor object\n\nCreate a new decompressor object. This object may be used to decompress\ndata sequentially. If you want to decompress data in one shot, use the\ndecompress() function instead.", 
  "module": "bz2", 
  "file": "/usr/lib/python3.2/lib-dynload/bz2.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "BZ2File", 
  "doc": "BZ2File(name [, mode='r', buffering=0, compresslevel=9]) -> file object\n\nOpen a bz2 file. The mode can be 'r' or 'w', for reading (default) or\nwriting. When opened for writing, the file will be created if it doesn't\nexist, and truncated otherwise. If the buffering argument is given, 0 means\nunbuffered, and larger numbers specify the buffer size. If compresslevel\nis given, must be a number between 1 and 9.\nData read is always returned in bytes; data written ought to be bytes.", 
  "module": "bz2", 
  "file": "/usr/lib/python3.2/lib-dynload/bz2.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "compress", 
  "doc": "compress(data [, compresslevel=9]) -> string\n\nCompress data in one shot. If you want to compress data sequentially,\nuse an instance of BZ2Compressor instead. The compresslevel parameter, if\ngiven, must be a number between 1 and 9.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "decompress", 
  "doc": "decompress(data) -> decompressed data\n\nDecompress data in one shot. If you want to decompress data sequentially,\nuse an instance of BZ2Decompressor instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "acos", 
  "doc": "acos(x)\n\nReturn the arc cosine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "acosh", 
  "doc": "acosh(x)\n\nReturn the hyperbolic arccosine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "asin", 
  "doc": "asin(x)\n\nReturn the arc sine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "asinh", 
  "doc": "asinh(x)\n\nReturn the hyperbolic arc sine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "atan", 
  "doc": "atan(x)\n\nReturn the arc tangent of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "atanh", 
  "doc": "atanh(x)\n\nReturn the hyperbolic arc tangent of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cos", 
  "doc": "cos(x)\n\nReturn the cosine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cosh", 
  "doc": "cosh(x)\n\nReturn the hyperbolic cosine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "exp", 
  "doc": "exp(x)\n\nReturn the exponential value e**x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isfinite", 
  "doc": "isfinite(z) -> bool\nReturn True if both the real and imaginary parts of z are finite, else False.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isinf", 
  "doc": "isinf(z) -> bool\nChecks if the real or imaginary part of z is infinite.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnan", 
  "doc": "isnan(z) -> bool\nChecks if the real or imaginary part of z not a number (NaN)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "log", 
  "doc": "log(x[, base]) -> the logarithm of x to the given base.\nIf the base not specified, returns the natural logarithm (base e) of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "log10", 
  "doc": "log10(x)\n\nReturn the base-10 logarithm of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "phase", 
  "doc": "phase(z) -> float\n\nReturn argument, also known as the phase angle, of a complex.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "polar", 
  "doc": "polar(z) -> r: float, phi: float\n\nConvert a complex from rectangular coordinates to polar coordinates. r is\nthe distance from 0 and phi the phase angle.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rect", 
  "doc": "rect(r, phi) -> z: complex\n\nConvert from polar coordinates to rectangular coordinates.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sin", 
  "doc": "sin(x)\n\nReturn the sine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sinh", 
  "doc": "sinh(x)\n\nReturn the hyperbolic sine of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sqrt", 
  "doc": "sqrt(x)\n\nReturn the square root of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tan", 
  "doc": "tan(x)\n\nReturn the tangent of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tanh", 
  "doc": "tanh(x)\n\nReturn the hyperbolic tangent of x.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "crypt", 
  "doc": "crypt(word, salt) -> string\nword will usually be a user's password. salt is a 2-character string\nwhich will be used to select one of 4096 variations of DES. The characters\nin salt must be either \".\", \"/\", or an alphanumeric character. Returns\nthe hashed password as a string, which will be composed of characters from\nthe same alphabet as the salt.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "fpectl", 
  "file": "/usr/lib/python3.2/lib-dynload/fpectl.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "turnoff_sigfpe", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "turnon_sigfpe", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "mmap", 
  "file": "/usr/lib/python3.2/lib-dynload/mmap.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "mmap", 
  "doc": "Windows: mmap(fileno, length[, tagname[, access[, offset]]])\n\nMaps length bytes from the file specified by the file handle fileno,\nand returns a mmap object.  If length is larger than the current size\nof the file, the file is extended to contain length bytes.  If length\nis 0, the maximum length of the map is the current size of the file,\nexcept that if the file is empty Windows raises an exception (you cannot\ncreate an empty mapping on Windows).\n\nUnix: mmap(fileno, length[, flags[, prot[, access[, offset]]]])\n\nMaps length bytes from the file specified by the file descriptor fileno,\nand returns a mmap object.  If length is 0, the maximum length of the map\nwill be the current size of the file when mmap is called.\nflags specifies the nature of the mapping. MAP_PRIVATE creates a\nprivate copy-on-write mapping, so changes to the contents of the mmap\nobject will be private to this process, and MAP_SHARED creates a mapping\nthat's shared with all other processes mapping the same areas of the file.\nThe default value is MAP_SHARED.\n\nTo map anonymous memory, pass -1 as the fileno (both versions).", 
  "module": "mmap", 
  "file": "/usr/lib/python3.2/lib-dynload/mmap.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "cat", 
  "doc": "cat(map, domain = defaultdomain)\nReturns the entire map as a dictionary. Optionally domain can be\nspecified but it defaults to the system default domain.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "nis", 
  "file": "/usr/lib/python3.2/lib-dynload/nis.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "get_default_domain", 
  "doc": "get_default_domain() -> str\nCorresponds to the C library yp_get_default_domain() call, returning\nthe default NIS domain.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maps", 
  "doc": "maps(domain = defaultdomain)\nReturns an array of all available NIS maps within a domain. If domain\nis not specified it defaults to the system default domain.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "match", 
  "doc": "match(key, map, domain = defaultdomain)\nCorresponds to the C library yp_match() call, returning the value of\nkey in the given map. Optionally domain can be specified but it\ndefaults to the system default domain.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "OSSAudioError", 
  "doc": null, 
  "module": "ossaudiodev", 
  "file": "/usr/lib/python3.2/lib-dynload/ossaudiodev.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "ossaudiodev", 
  "file": "/usr/lib/python3.2/lib-dynload/ossaudiodev.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "open", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "openmixer", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ParserError", 
  "doc": null, 
  "module": "parser", 
  "file": "/usr/lib/python3.2/lib-dynload/parser.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "STType", 
  "doc": "Intermediate representation of a Python parse tree.", 
  "module": "parser", 
  "file": "/usr/lib/python3.2/lib-dynload/parser.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_pickler", 
  "doc": "Returns the pickle magic to allow ST objects to be pickled.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "compilest", 
  "doc": "Compiles an ST object into a code object.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expr", 
  "doc": "Creates an ST object from an expression.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isexpr", 
  "doc": "Determines if an ST object was created from an expression.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "issuite", 
  "doc": "Determines if an ST object was created from a suite.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "sequence2st", 
  "doc": "Creates an ST object from a tree representation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "st2list", 
  "doc": "Creates a list-tree representation of an ST.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "st2tuple", 
  "doc": "Creates a tuple-tree representation of an ST.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "suite", 
  "doc": "Creates an ST object from a suite.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tuple2st", 
  "doc": "Creates an ST object from a tree representation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "add_history", 
  "doc": "add_history(string) -> None\nadd a line to the history buffer", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "clear_history", 
  "doc": "clear_history() -> None\nClear the current readline history.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_begidx", 
  "doc": "get_begidx() -> int\nget the beginning index of the readline tab-completion scope", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_completer", 
  "doc": "get_completer() -> function\n\nReturns current completer function.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_completer_delims", 
  "doc": "get_completer_delims() -> string\nget the readline word delimiters for tab-completion", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_completion_type", 
  "doc": "get_completion_type() -> int\nGet the type of completion being attempted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_current_history_length", 
  "doc": "get_current_history_length() -> integer\nreturn the current (not the maximum) length of history.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_endidx", 
  "doc": "get_endidx() -> int\nget the ending index of the readline tab-completion scope", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_history_item", 
  "doc": "get_history_item() -> string\nreturn the current contents of history item at index.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_history_length", 
  "doc": "get_history_length() -> int\nreturn the maximum number of items that will be written to\nthe history file.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_line_buffer", 
  "doc": "get_line_buffer() -> string\nreturn the current contents of the line buffer.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "insert_text", 
  "doc": "insert_text(string) -> None\nInsert text into the command line.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_and_bind", 
  "doc": "parse_and_bind(string) -> None\nParse and execute single line of a readline init file.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_history_file", 
  "doc": "read_history_file([filename]) -> None\nLoad a readline history file.\nThe default filename is ~/.history.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "read_init_file", 
  "doc": "read_init_file([filename]) -> None\nParse a readline initialization file.\nThe default filename is the last filename used.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "redisplay", 
  "doc": "redisplay() -> None\nChange what's displayed on the screen to reflect the current\ncontents of the line buffer.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "remove_history_item", 
  "doc": "remove_history_item(pos) -> None\nremove history item given by its position", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace_history_item", 
  "doc": "replace_history_item(pos, line) -> None\nreplaces history item given by its position with contents of line", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_completer", 
  "doc": "set_completer([function]) -> None\nSet or remove the completer function.\nThe function is called as function(text, state),\nfor state in 0, 1, 2, ..., until it returns a non-string.\nIt should return the next possible completion starting with 'text'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_completer_delims", 
  "doc": "set_completer_delims(string) -> None\nset the readline word delimiters for tab-completion", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_completion_display_matches_hook", 
  "doc": "set_completion_display_matches_hook([function]) -> None\nSet or remove the completion display function.\nThe function is called as\n  function(substitution, [matches], longest_match_length)\nonce each time matches need to be displayed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_history_length", 
  "doc": "set_history_length(length) -> None\nset the maximal number of items which will be written to\nthe history file. A negative length is used to inhibit\nhistory truncation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_pre_input_hook", 
  "doc": "set_pre_input_hook([function]) -> None\nSet or remove the pre_input_hook function.\nThe function is called with no arguments after the first prompt\nhas been printed and just before readline starts reading input\ncharacters.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_startup_hook", 
  "doc": "set_startup_hook([function]) -> None\nSet or remove the startup_hook function.\nThe function is called with no arguments just\nbefore readline prints the first prompt.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "write_history_file", 
  "doc": "write_history_file([filename]) -> None\nSave a readline history file.\nThe default filename is ~/.history.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "resource", 
  "file": "/usr/lib/python3.2/lib-dynload/resource.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "getpagesize", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getrlimit", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "getrusage", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setrlimit", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "struct_rusage", 
  "doc": "struct_rusage: Result from getrusage.\n\nThis object may be accessed either as a tuple of\n    (utime,stime,maxrss,ixrss,idrss,isrss,minflt,majflt,\n    nswap,inblock,oublock,msgsnd,msgrcv,nsignals,nvcsw,nivcsw)\nor via the attributes ru_utime, ru_stime, ru_maxrss, and so on.", 
  "module": "resource", 
  "file": "/usr/lib/python3.2/lib-dynload/resource.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "error", 
  "doc": null, 
  "module": "termios", 
  "file": "/usr/lib/python3.2/lib-dynload/termios.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "tcdrain", 
  "doc": "tcdrain(fd) -> None\n\nWait until all output written to file descriptor fd has been transmitted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcflow", 
  "doc": "tcflow(fd, action) -> None\n\nSuspend or resume input or output on file descriptor fd.\nThe action argument can be termios.TCOOFF to suspend output,\ntermios.TCOON to restart output, termios.TCIOFF to suspend input,\nor termios.TCION to restart input.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcflush", 
  "doc": "tcflush(fd, queue) -> None\n\nDiscard queued data on file descriptor fd.\nThe queue selector specifies which queue: termios.TCIFLUSH for the input\nqueue, termios.TCOFLUSH for the output queue, or termios.TCIOFLUSH for\nboth queues. ", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcgetattr", 
  "doc": "tcgetattr(fd) -> list_of_attrs\n\nGet the tty attributes for file descriptor fd, as follows:\n[iflag, oflag, cflag, lflag, ispeed, ospeed, cc] where cc is a list\nof the tty special characters (each a string of length 1, except the items\nwith indices VMIN and VTIME, which are integers when these fields are\ndefined).  The interpretation of the flags and the speeds as well as the\nindexing in the cc array must be done using the symbolic constants defined\nin this module.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcsendbreak", 
  "doc": "tcsendbreak(fd, duration) -> None\n\nSend a break on file descriptor fd.\nA zero duration sends a break for 0.25-0.5 seconds; a nonzero duration\nhas a system dependent meaning.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "tcsetattr", 
  "doc": "tcsetattr(fd, when, attributes) -> None\n\nSet the tty attributes for file descriptor fd.\nThe attributes to be set are taken from the attributes argument, which\nis a list like the one returned by tcgetattr(). The when argument\ndetermines when the attributes are changed: termios.TCSANOW to\nchange immediately, termios.TCSADRAIN to change after transmitting all\nqueued output, or termios.TCSAFLUSH to change after transmitting all\nqueued output and discarding all queued input. ", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Array", 
  "doc": "An array of similar items, implemented as a subtype of list.\n\nAs currently implemented, an Array behaves just like a list, but\nwith the addition of a ``signature`` property set by the constructor;\nconversion of its items to D-Bus types is only done when it's sent in\na Message. This might change in future so validation is done earlier.\n\nConstructor::\n\n    dbus.Array([iterable][, signature][, variant_level])\n\n``variant_level`` must be non-negative; the default is 0.\n\n``signature`` is the D-Bus signature string for a single element of the\narray, or None. If not None it must represent a single complete type, the\ntype of a single array item; the signature of the whole Array may be\nobtained by prepending ``a`` to the given signature.\n\nIf None (the default), when the Array is sent over\nD-Bus, the item signature will be guessed from the first element.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an array, this is represented in Python by an\n    Array with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Boolean", 
  "doc": "A boolean, represented as a subtype of `int` (not `bool`, because `bool`\ncannot be subclassed).\n\nConstructor::\n\n    dbus.Boolean(value[, variant_level]) -> Boolean\n\n``value`` is converted to 0 or 1 as if by ``int(bool(value))``.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a boolean, this is represented in Python by a\n    Boolean with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Byte", 
  "doc": "An unsigned byte: a subtype of int, with range restricted to [0, 255].\n\nA Byte b may be converted to a str of length 1 via str(b) == chr(b).\n\nMost of the time you don't want to use this class - it mainly exists\nfor symmetry with the other D-Bus types. See `dbus.ByteArray` for a\nbetter way to handle arrays of Byte.\n\nConstructor::\n\n   dbus.Byte(integer or str of length 1[, variant_level])\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a byte, this is represented in Python by a\n    Byte with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ByteArray", 
  "doc": "ByteArray is a subtype of str which can be used when you want an\nefficient immutable representation of a D-Bus byte array (signature 'ay').\n\nBy default, when byte arrays are converted from D-Bus to Python, they\ncome out as a `dbus.Array` of `dbus.Byte`. This is just for symmetry with\nthe other D-Bus types - in practice, what you usually want is the byte\narray represented as a string, using this class. To get this, pass the\n``byte_arrays=True`` keyword argument to any of these methods:\n\n* any D-Bus method proxy, or ``connect_to_signal``, on the objects returned\n  by `Bus.get_object`\n* any D-Bus method on a `dbus.Interface`\n* `dbus.Interface.connect_to_signal`\n* `Bus.add_signal_receiver`\n\nImport via::\n\n   from dbus import ByteArray\n\nConstructor::\n\n   ByteArray(str)", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Connection", 
  "doc": "A D-Bus connection.\n\n::\n\n   Connection(address, mainloop=None) -> Connection", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Dictionary", 
  "doc": "An mapping whose keys are similar and whose values are similar,\nimplemented as a subtype of dict.\n\nAs currently implemented, a Dictionary behaves just like a dict, but\nwith the addition of a ``signature`` property set by the constructor;\nconversion of its items to D-Bus types is only done when it's sent in\na Message. This may change in future so validation is done earlier.\n\nConstructor::\n\n    Dictionary(mapping_or_iterable=(), signature=None, variant_level=0)\n\n``variant_level`` must be non-negative; the default is 0.\n\n``signature`` is either a string or None. If a string, it must consist\nof exactly two complete type signatures, representing the 'key' type\n(which must be a primitive type, i.e. one of \"bdginoqstuxy\")\nand the 'value' type. The signature of the whole Dictionary will be\n``a{xx}`` where ``xx`` is replaced by the given signature.\n\nIf it is None (the default), when the Dictionary is sent over\nD-Bus, the key and value signatures will be guessed from an arbitrary\nelement of the Dictionary.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an array of DICT_ENTRY, this is represented in\n    Python by a Dictionary with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Double", 
  "doc": "A double-precision floating point number (a subtype of float).", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ErrorMessage", 
  "doc": "An error message.\n\nConstructor::\n\n   dbus.lowlevel.ErrorMessage(reply_to: Message, error_name: str,\n                              error_message: str or None)", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int16", 
  "doc": "A signed 16-bit integer between -0x8000 and +0x7FFF, represented as\na subtype of `int`.\n\nConstructor::\n\n    dbus.Int16(value: int[, variant_level: int]) -> Int16\n\nvalue must be within the allowed range, or OverflowError will be\nraised.\n\n    variant_level must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an int16, this is represented in Python by an\n    Int16 with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int32", 
  "doc": "A signed 32-bit integer between -0x8000 0000 and +0x7FFF FFFF, represented as\na subtype of `int`.\n\nConstructor::\n\n    dbus.Int32(value: int[, variant_level: int]) -> Int32\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an int32, this is represented in Python by an\n    Int32 with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int64", 
  "doc": "A signed 64-bit integer between -0x8000 0000 0000 0000 and\n+0x7FFF FFFF FFFF FFFF, represented as a subtype of `long`.\n\nNote that this may be changed in future to be a subtype of `int` on\n64-bit platforms; applications should not rely on either behaviour.\n\nThis type only works on platforms where the C compiler has suitable\n64-bit types, such as C99 ``long long``.\n\nConstructor::\n\n    dbus.Int64(value: long[, variant_level: int]) -> Int64\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an int64, this is represented in Python by an\n    Int64 with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Message", 
  "doc": "A message to be sent or received over a D-Bus Connection.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MethodCallMessage", 
  "doc": "A method-call message.\n\nConstructor::\n\n    dbus.lowlevel.MethodCallMessage(destination: str or None, path: str,\n                                    interface: str or None, method: str)\n\n``destination`` is the destination bus name, or None to send the\nmessage directly to the peer (usually the bus daemon).\n\n``path`` is the object-path of the object whose method is to be called.\n\n``interface`` is the interface qualifying the method name, or None to omit\nthe interface from the message header.\n\n``method`` is the method name (member name).", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MethodReturnMessage", 
  "doc": "A method-return message.\n\nConstructor::\n\n    dbus.lowlevel.MethodReturnMessage(method_call: MethodCallMessage)", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NativeMainLoop", 
  "doc": "Object representing D-Bus main loop integration done in native code.\nCannot be instantiated directly.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ObjectPath", 
  "doc": "A D-Bus object path, such as '/com/example/MyApp/Documents/abc'.\n\nObjectPath is a subtype of str, and object-paths behave like strings.\n\nConstructor::\n\n    dbus.ObjectPath(path: str, variant_level: int) -> ObjectPath\n\npath must be an ASCII string following the syntax of object paths.\nvariant_level must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an object path, this is represented in Python by an\n    ObjectPath with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PendingCall", 
  "doc": "Object representing a pending D-Bus call, returned by\nConnection.send_message_with_reply(). Cannot be instantiated directly.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SignalMessage", 
  "doc": "A signal message.\n\nConstructor::\n\n   dbus.lowlevel.SignalMessage(path: str, interface: str, method: str)", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Signature", 
  "doc": "A string subclass whose values are restricted to valid D-Bus\nsignatures. When iterated over, instead of individual characters it\nproduces Signature instances representing single complete types.\n\nConstructor::\n\n    ``Signature(value: str or unicode[, variant_level: int]) -> Signature``\n\n``value`` must be a valid D-Bus signature (zero or more single complete\ntypes).\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a signature, this is represented in Python by a\n    Signature with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "String", 
  "doc": "A string represented using Unicode - a subtype of `unicode`.\n\nAll strings on D-Bus are required to be valid Unicode; in the \"wire\nprotocol\" they're transported as UTF-8.\n\nBy default, when strings are converted from D-Bus to Python, they\ncome out as this class. If you prefer to get UTF-8 strings (as instances\nof a subtype of `str`) or you want to avoid the conversion overhead of\ngoing from UTF-8 to Python's internal Unicode representation, see the\ndocumentation for `dbus.UTF8String`.\n\nConstructor::\n\n    String(value: str or unicode[, variant_level: int]) -> String\n\nvariant_level must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a string, this is represented in Python by a\n    String or UTF8String with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Struct", 
  "doc": "An structure containing items of possibly distinct types.\n\nConstructor::\n\n    dbus.Struct(iterable, signature=None, variant_level=0) -> Struct\n\nD-Bus structs may not be empty, so the iterable argument is required and\nmay not be an empty iterable.\n\n``signature`` is either None, or a string representing the contents of the\nstruct as one or more complete type signatures. The overall signature of\nthe struct will be the given signature enclosed in parentheses, ``()``.\n\nIf the signature is None (default) it will be guessed\nfrom the types of the items during construction.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a struct, this is represented in Python by a\n    Struct with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UInt16", 
  "doc": "An unsigned 16-bit integer between 0 and 0xFFFF, represented as\na subtype of `int`.\n\nConstructor::\n\n    dbus.UInt16(value: int[, variant_level: int]) -> UInt16\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a uint16, this is represented in Python by a\n    UInt16 with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UInt32", 
  "doc": "An unsigned 32-bit integer between 0 and 0xFFFF FFFF, represented as a\nsubtype of `long`.\n\nNote that this may be changed in future to be a subtype of `int` on\n64-bit platforms; applications should not rely on either behaviour.\n\nConstructor::\n\n    dbus.UInt32(value: long[, variant_level: int]) -> UInt32\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a uint32, this is represented in Python by a\n    UInt32 with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UInt64", 
  "doc": "An unsigned 64-bit integer between 0 and 0xFFFF FFFF FFFF FFFF,\nrepresented as a subtype of `long`.\n\nThis type only exists on platforms where the C compiler has suitable\n64-bit types, such as C99 ``unsigned long long``.\n\nConstructor::\n\n    dbus.UInt64(value: long[, variant_level: int]) -> UInt64\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a uint64, this is represented in Python by a\n    UInt64 with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnixFd", 
  "doc": "An Unix Fd.\n\nConstructor::\n\n    dbus.UnixFd(value: int or file object[, variant_level: int]) -> UnixFd\n\n``value`` must be the integer value of a file descriptor, or an object that\nimplements the fileno() method. Otherwise, `ValueError` will be\nraised.\n\nUnixFd keeps a dup() (duplicate) of the supplied file descriptor. The\ncaller remains responsible for closing the original fd.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an Unix Fd, this is represented in Python by an\n    Unix Fd with variant_level==2.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_BytesBase", 
  "doc": "Base class for bytes subclasses with a ``variant_level`` attribute.\nDo not rely on the existence of this class outside dbus-python.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_FloatBase", 
  "doc": "Base class for float subclasses with a ``variant_level`` attribute.\nDo not rely on the existence of this class outside dbus-python.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_LibDBusConnection", 
  "doc": "A reference to a ``DBusConnection`` from ``libdbus``, which might not\nhave been attached to a `dbus.connection.Connection` yet.\n\nCannot be instantiated from Python. The only use of this object is to\npass it to the ``dbus.connection.Connection`` constructor instead of an\naddress.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_LongBase", 
  "doc": "Base class for ``long`` subclasses with a ``variant_level`` attribute.\nDo not rely on the existence of this class outside dbus-python.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_Server", 
  "doc": "A D-Bus server.\n\n::\n\n   Server(address, connection_subtype, mainloop=None, auth_mechanisms=None)\n     -> Server", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_SignatureIter", 
  "doc": null, 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "_StrBase", 
  "doc": "Base class for str subclasses with a ``variant_level`` attribute.\nDo not rely on the existence of this class outside dbus-python.", 
  "module": "_dbus_bindings", 
  "file": "/usr/lib/python3/dist-packages/_dbus_bindings.cpython-32mu.so", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "get_default_main_loop", 
  "doc": "get_default_main_loop() -> object\n\nReturn the global default dbus-python main loop wrapper, which is used\nwhen no main loop wrapper is passed to the Connection constructor.\n\nIf None, there is no default and you should always pass the mainloop\nparameter to the constructor - if you don't, then asynchronous calls,\nconnecting to signals and exporting objects will raise an exception.\nThere is no default until set_default_main_loop is called.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "set_default_main_loop", 
  "doc": "set_default_main_loop(object)\n\nChange the global default dbus-python main loop wrapper, which is used\nwhen no main loop wrapper is passed to the Connection constructor.\n\nIf None, return to the initial situation: there is no default, and you\nmust always pass the mainloop parameter to the constructor.\n\nTwo types of main loop wrapper are planned in dbus-python.\nNative main-loop wrappers are instances of `dbus.mainloop.NativeMainLoop`\nsupplied by extension modules like `dbus.mainloop.glib`: they have no\nPython API, but connect themselves to ``libdbus`` using native code.\nPython main-loop wrappers are not yet implemented. They will be objects\nsupporting the interface defined by `dbus.mainloop.MainLoop`, with an\nAPI entirely based on Python methods.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_bus_name", 
  "doc": "validate_bus_name(name, allow_unique=True, allow_well_known=True)\n\nRaise ValueError if the argument is not a valid bus name.\n\nBy default both unique and well-known names are accepted.\n\n:Parameters:\n   `name` : str\n       The name to be validated\n   `allow_unique` : bool\n       If False, unique names of the form :1.123 will be rejected\n   `allow_well_known` : bool\n       If False, well-known names of the form com.example.Foo\n       will be rejected\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_error_name", 
  "doc": "validate_error_name(name)\n\nRaise ValueError if the given string is not a valid error name.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_interface_name", 
  "doc": "validate_interface_name(name)\n\nRaise ValueError if the given string is not a valid interface name.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_member_name", 
  "doc": "validate_member_name(name)\n\nRaise ValueError if the argument is not a valid member (signal or method) name.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_object_path", 
  "doc": "validate_object_path(name)\n\nRaise ValueError if the given string is not a valid object path.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "DBusGMainLoop", 
  "doc": "DBusGMainLoop([set_as_default=False]) -> NativeMainLoop\n\nReturn a NativeMainLoop object which can be used to\nrepresent the default GLib main context in dbus-python.\n\nIf the keyword argument set_as_default is given and is true, set the new\nmain loop as the default for all new Connection or Bus instances.\n\nNon-default main contexts are not currently supported.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "gthreads_init", 
  "doc": "gthreads_init()", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "setup_with_g_main", 
  "doc": "setup_with_g_main(conn: dbus.Connection)\n\nDeprecated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Context", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FontFace", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "FontOptions", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Gradient", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ImageSurface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "LinearGradient", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Matrix", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PDFSurface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "PSSurface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Pattern", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "RadialGradient", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SVGSurface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ScaledFont", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SolidPattern", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Surface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SurfacePattern", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ToyFontFace", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "XCBSurface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "XlibSurface", 
  "doc": null, 
  "module": "cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_cairo", 
  "file": "/usr/lib/python3/dist-packages/cairo/_cairo.cpython-32mu.so"
 }, 
 {
  "name": "cairo_version", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "cairo_version_string", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Array", 
  "doc": "An array of similar items, implemented as a subtype of list.\n\nAs currently implemented, an Array behaves just like a list, but\nwith the addition of a ``signature`` property set by the constructor;\nconversion of its items to D-Bus types is only done when it's sent in\na Message. This might change in future so validation is done earlier.\n\nConstructor::\n\n    dbus.Array([iterable][, signature][, variant_level])\n\n``variant_level`` must be non-negative; the default is 0.\n\n``signature`` is the D-Bus signature string for a single element of the\narray, or None. If not None it must represent a single complete type, the\ntype of a single array item; the signature of the whole Array may be\nobtained by prepending ``a`` to the given signature.\n\nIf None (the default), when the Array is sent over\nD-Bus, the item signature will be guessed from the first element.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an array, this is represented in Python by an\n    Array with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Boolean", 
  "doc": "A boolean, represented as a subtype of `int` (not `bool`, because `bool`\ncannot be subclassed).\n\nConstructor::\n\n    dbus.Boolean(value[, variant_level]) -> Boolean\n\n``value`` is converted to 0 or 1 as if by ``int(bool(value))``.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a boolean, this is represented in Python by a\n    Boolean with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Bus", 
  "doc": "A connection to one of three possible standard buses, the SESSION,\nSYSTEM, or STARTER bus. This class manages shared connections to those\nbuses.\n\nIf you're trying to subclass `Bus`, you may be better off subclassing\n`BusConnection`, which doesn't have all this magic.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/_dbus.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Byte", 
  "doc": "An unsigned byte: a subtype of int, with range restricted to [0, 255].\n\nA Byte b may be converted to a str of length 1 via str(b) == chr(b).\n\nMost of the time you don't want to use this class - it mainly exists\nfor symmetry with the other D-Bus types. See `dbus.ByteArray` for a\nbetter way to handle arrays of Byte.\n\nConstructor::\n\n   dbus.Byte(integer or str of length 1[, variant_level])\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a byte, this is represented in Python by a\n    Byte with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ByteArray", 
  "doc": "ByteArray is a subtype of str which can be used when you want an\nefficient immutable representation of a D-Bus byte array (signature 'ay').\n\nBy default, when byte arrays are converted from D-Bus to Python, they\ncome out as a `dbus.Array` of `dbus.Byte`. This is just for symmetry with\nthe other D-Bus types - in practice, what you usually want is the byte\narray represented as a string, using this class. To get this, pass the\n``byte_arrays=True`` keyword argument to any of these methods:\n\n* any D-Bus method proxy, or ``connect_to_signal``, on the objects returned\n  by `Bus.get_object`\n* any D-Bus method on a `dbus.Interface`\n* `dbus.Interface.connect_to_signal`\n* `Bus.add_signal_receiver`\n\nImport via::\n\n   from dbus import ByteArray\n\nConstructor::\n\n   ByteArray(str)", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DBusException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Dictionary", 
  "doc": "An mapping whose keys are similar and whose values are similar,\nimplemented as a subtype of dict.\n\nAs currently implemented, a Dictionary behaves just like a dict, but\nwith the addition of a ``signature`` property set by the constructor;\nconversion of its items to D-Bus types is only done when it's sent in\na Message. This may change in future so validation is done earlier.\n\nConstructor::\n\n    Dictionary(mapping_or_iterable=(), signature=None, variant_level=0)\n\n``variant_level`` must be non-negative; the default is 0.\n\n``signature`` is either a string or None. If a string, it must consist\nof exactly two complete type signatures, representing the 'key' type\n(which must be a primitive type, i.e. one of \"bdginoqstuxy\")\nand the 'value' type. The signature of the whole Dictionary will be\n``a{xx}`` where ``xx`` is replaced by the given signature.\n\nIf it is None (the default), when the Dictionary is sent over\nD-Bus, the key and value signatures will be guessed from an arbitrary\nelement of the Dictionary.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an array of DICT_ENTRY, this is represented in\n    Python by a Dictionary with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Double", 
  "doc": "A double-precision floating point number (a subtype of float).", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int16", 
  "doc": "A signed 16-bit integer between -0x8000 and +0x7FFF, represented as\na subtype of `int`.\n\nConstructor::\n\n    dbus.Int16(value: int[, variant_level: int]) -> Int16\n\nvalue must be within the allowed range, or OverflowError will be\nraised.\n\n    variant_level must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an int16, this is represented in Python by an\n    Int16 with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int32", 
  "doc": "A signed 32-bit integer between -0x8000 0000 and +0x7FFF FFFF, represented as\na subtype of `int`.\n\nConstructor::\n\n    dbus.Int32(value: int[, variant_level: int]) -> Int32\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an int32, this is represented in Python by an\n    Int32 with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Int64", 
  "doc": "A signed 64-bit integer between -0x8000 0000 0000 0000 and\n+0x7FFF FFFF FFFF FFFF, represented as a subtype of `long`.\n\nNote that this may be changed in future to be a subtype of `int` on\n64-bit platforms; applications should not rely on either behaviour.\n\nThis type only works on platforms where the C compiler has suitable\n64-bit types, such as C99 ``long long``.\n\nConstructor::\n\n    dbus.Int64(value: long[, variant_level: int]) -> Int64\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an int64, this is represented in Python by an\n    Int64 with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Interface", 
  "doc": "An interface into a remote object.\n\nAn Interface can be used to wrap ProxyObjects\nso that calls can be routed to their correct\nD-Bus interface.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/proxies.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "IntrospectionParserException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MissingErrorHandlerException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "MissingReplyHandlerException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "NameExistsException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ObjectPath", 
  "doc": "A D-Bus object path, such as '/com/example/MyApp/Documents/abc'.\n\nObjectPath is a subtype of str, and object-paths behave like strings.\n\nConstructor::\n\n    dbus.ObjectPath(path: str, variant_level: int) -> ObjectPath\n\npath must be an ASCII string following the syntax of object paths.\nvariant_level must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing an object path, this is represented in Python by an\n    ObjectPath with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SessionBus", 
  "doc": "The session (current login) message bus.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/_dbus.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Signature", 
  "doc": "A string subclass whose values are restricted to valid D-Bus\nsignatures. When iterated over, instead of individual characters it\nproduces Signature instances representing single complete types.\n\nConstructor::\n\n    ``Signature(value: str or unicode[, variant_level: int]) -> Signature``\n\n``value`` must be a valid D-Bus signature (zero or more single complete\ntypes).\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a signature, this is represented in Python by a\n    Signature with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "StarterBus", 
  "doc": "The bus that activated this process (only valid if\nthis process was launched by DBus activation).", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/_dbus.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "String", 
  "doc": "A string represented using Unicode - a subtype of `unicode`.\n\nAll strings on D-Bus are required to be valid Unicode; in the \"wire\nprotocol\" they're transported as UTF-8.\n\nBy default, when strings are converted from D-Bus to Python, they\ncome out as this class. If you prefer to get UTF-8 strings (as instances\nof a subtype of `str`) or you want to avoid the conversion overhead of\ngoing from UTF-8 to Python's internal Unicode representation, see the\ndocumentation for `dbus.UTF8String`.\n\nConstructor::\n\n    String(value: str or unicode[, variant_level: int]) -> String\n\nvariant_level must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a string, this is represented in Python by a\n    String or UTF8String with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "Struct", 
  "doc": "An structure containing items of possibly distinct types.\n\nConstructor::\n\n    dbus.Struct(iterable, signature=None, variant_level=0) -> Struct\n\nD-Bus structs may not be empty, so the iterable argument is required and\nmay not be an empty iterable.\n\n``signature`` is either None, or a string representing the contents of the\nstruct as one or more complete type signatures. The overall signature of\nthe struct will be the given signature enclosed in parentheses, ``()``.\n\nIf the signature is None (default) it will be guessed\nfrom the types of the items during construction.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a struct, this is represented in Python by a\n    Struct with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "SystemBus", 
  "doc": "The system-wide message bus.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/_dbus.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UInt16", 
  "doc": "An unsigned 16-bit integer between 0 and 0xFFFF, represented as\na subtype of `int`.\n\nConstructor::\n\n    dbus.UInt16(value: int[, variant_level: int]) -> UInt16\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a uint16, this is represented in Python by a\n    UInt16 with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UInt32", 
  "doc": "An unsigned 32-bit integer between 0 and 0xFFFF FFFF, represented as a\nsubtype of `long`.\n\nNote that this may be changed in future to be a subtype of `int` on\n64-bit platforms; applications should not rely on either behaviour.\n\nConstructor::\n\n    dbus.UInt32(value: long[, variant_level: int]) -> UInt32\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a uint32, this is represented in Python by a\n    UInt32 with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UInt64", 
  "doc": "An unsigned 64-bit integer between 0 and 0xFFFF FFFF FFFF FFFF,\nrepresented as a subtype of `long`.\n\nThis type only exists on platforms where the C compiler has suitable\n64-bit types, such as C99 ``unsigned long long``.\n\nConstructor::\n\n    dbus.UInt64(value: long[, variant_level: int]) -> UInt64\n\n``value`` must be within the allowed range, or `OverflowError` will be\nraised.\n\n``variant_level`` must be non-negative; the default is 0.\n\n:IVariables:\n  `variant_level` : int\n    Indicates how many nested Variant containers this object\n    is contained in: if a message's wire format has a variant containing a\n    variant containing a uint64, this is represented in Python by a\n    UInt64 with variant_level==2.", 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "UnknownMethodException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "ValidationException", 
  "doc": null, 
  "module": "dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_compat", 
  "file": "/usr/lib/python3/dist-packages/dbus/_compat.py"
 }, 
 {
  "doc": "Implementation for dbus.Bus. Not to be imported directly.", 
  "line": 0, 
  "type": "module", 
  "name": "_dbus", 
  "file": "/usr/lib/python3/dist-packages/dbus/_dbus.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_expat_introspect_parser", 
  "file": "/usr/lib/python3/dist-packages/dbus/_expat_introspect_parser.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_version", 
  "file": "/usr/lib/python3/dist-packages/dbus/_version.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "bus", 
  "file": "/usr/lib/python3/dist-packages/dbus/bus.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "connection", 
  "file": "/usr/lib/python3/dist-packages/dbus/connection.py"
 }, 
 {
  "doc": "D-Bus exceptions.", 
  "line": 0, 
  "type": "module", 
  "name": "exceptions", 
  "file": "/usr/lib/python3/dist-packages/dbus/exceptions.py"
 }, 
 {
  "name": "get_default_main_loop", 
  "doc": "get_default_main_loop() -> object\n\nReturn the global default dbus-python main loop wrapper, which is used\nwhen no main loop wrapper is passed to the Connection constructor.\n\nIf None, there is no default and you should always pass the mainloop\nparameter to the constructor - if you don't, then asynchronous calls,\nconnecting to signals and exporting objects will raise an exception.\nThere is no default until set_default_main_loop is called.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Low-level interface to D-Bus.", 
  "line": 0, 
  "type": "module", 
  "name": "lowlevel", 
  "file": "/usr/lib/python3/dist-packages/dbus/lowlevel.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "proxies", 
  "file": "/usr/lib/python3/dist-packages/dbus/proxies.py"
 }, 
 {
  "name": "set_default_main_loop", 
  "doc": "set_default_main_loop(object)\n\nChange the global default dbus-python main loop wrapper, which is used\nwhen no main loop wrapper is passed to the Connection constructor.\n\nIf None, return to the initial situation: there is no default, and you\nmust always pass the mainloop parameter to the constructor.\n\nTwo types of main loop wrapper are planned in dbus-python.\nNative main-loop wrappers are instances of `dbus.mainloop.NativeMainLoop`\nsupplied by extension modules like `dbus.mainloop.glib`: they have no\nPython API, but connect themselves to ``libdbus`` using native code.\nPython main-loop wrappers are not yet implemented. They will be objects\nsupporting the interface defined by `dbus.mainloop.MainLoop`, with an\nAPI entirely based on Python methods.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "types", 
  "file": "/usr/lib/python3/dist-packages/dbus/types.py"
 }, 
 {
  "name": "validate_bus_name", 
  "doc": "validate_bus_name(name, allow_unique=True, allow_well_known=True)\n\nRaise ValueError if the argument is not a valid bus name.\n\nBy default both unique and well-known names are accepted.\n\n:Parameters:\n   `name` : str\n       The name to be validated\n   `allow_unique` : bool\n       If False, unique names of the form :1.123 will be rejected\n   `allow_well_known` : bool\n       If False, well-known names of the form com.example.Foo\n       will be rejected\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_error_name", 
  "doc": "validate_error_name(name)\n\nRaise ValueError if the given string is not a valid error name.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_interface_name", 
  "doc": "validate_interface_name(name)\n\nRaise ValueError if the given string is not a valid interface name.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_member_name", 
  "doc": "validate_member_name(name)\n\nRaise ValueError if the argument is not a valid member (signal or method) name.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "validate_object_path", 
  "doc": "validate_object_path(name)\n\nRaise ValueError if the given string is not a valid object path.\n\n:Since: 0.80", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "Debconf", 
  "doc": null, 
  "module": "debconf", 
  "file": "/usr/lib/python3/dist-packages/debconf.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DebconfCommunicator", 
  "doc": null, 
  "module": "debconf", 
  "file": "/usr/lib/python3/dist-packages/debconf.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "DebconfError", 
  "doc": null, 
  "module": "debconf", 
  "file": "/usr/lib/python3/dist-packages/debconf.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": "This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.", 
  "line": 0, 
  "type": "module", 
  "name": "errno", 
  "file": null
 }, 
 {
  "doc": "This module performs file control and I/O control on file \ndescriptors.  It is an interface to the fcntl() and ioctl() Unix\nroutines.  File descriptors can be obtained with the fileno() method of\na file or socket object.", 
  "line": 0, 
  "type": "module", 
  "name": "fcntl", 
  "file": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "name": "runFrontEnd", 
  "doc": null, 
  "module": "debconf", 
  "file": "/usr/lib/python3/dist-packages/debconf.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "subprocess - Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.  This module\nintends to replace several other, older modules and functions, like:\n\nos.system\nos.spawn*\n\nInformation about how the subprocess module can be used to replace these\nmodules and functions can be found below.\n\n\n\nUsing the subprocess module\n===========================\nThis module defines one class called Popen:\n\nclass Popen(args, bufsize=0, executable=None,\n            stdin=None, stdout=None, stderr=None,\n            preexec_fn=None, close_fds=True, shell=False,\n            cwd=None, env=None, universal_newlines=False,\n            startupinfo=None, creationflags=0,\n            restore_signals=True, start_new_session=False, pass_fds=()):\n\n\nArguments are:\n\nargs should be a string, or a sequence of program arguments.  The\nprogram to execute is normally the first item in the args sequence or\nstring, but can be explicitly set by using the executable argument.\n\nOn POSIX, with shell=False (default): In this case, the Popen class\nuses os.execvp() to execute the child program.  args should normally\nbe a sequence.  A string will be treated as a sequence with the string\nas the only item (the program to execute).\n\nOn POSIX, with shell=True: If args is a string, it specifies the\ncommand string to execute through the shell.  If args is a sequence,\nthe first item specifies the command string, and any additional items\nwill be treated as additional shell arguments.\n\nOn Windows: the Popen class uses CreateProcess() to execute the child\nprogram, which operates on strings.  If args is a sequence, it will be\nconverted to a string using the list2cmdline method.  Please note that\nnot all MS Windows applications interpret the command line the same\nway: The list2cmdline is designed for applications using the same\nrules as the MS C runtime.\n\nbufsize, if given, has the same meaning as the corresponding argument\nto the built-in open() function: 0 means unbuffered, 1 means line\nbuffered, any other positive value means use a buffer of\n(approximately) that size.  A negative bufsize means to use the system\ndefault, which usually means fully buffered.  The default value for\nbufsize is 0 (unbuffered).\n\nstdin, stdout and stderr specify the executed programs' standard\ninput, standard output and standard error file handles, respectively.\nValid values are PIPE, an existing file descriptor (a positive\ninteger), an existing file object, and None.  PIPE indicates that a\nnew pipe to the child should be created.  With None, no redirection\nwill occur; the child's file handles will be inherited from the\nparent.  Additionally, stderr can be STDOUT, which indicates that the\nstderr data from the applications should be captured into the same\nfile handle as for stdout.\n\nOn POSIX, if preexec_fn is set to a callable object, this object will be\ncalled in the child process just before the child is executed.  The use\nof preexec_fn is not thread safe, using it in the presence of threads\ncould lead to a deadlock in the child process before the new executable\nis executed.\n\nIf close_fds is true, all file descriptors except 0, 1 and 2 will be\nclosed before the child process is executed.  The default for close_fds\nvaries by platform:  Always true on POSIX.  True when stdin/stdout/stderr\nare None on Windows, false otherwise.\n\npass_fds is an optional sequence of file descriptors to keep open between the\nparent and child.  Providing any pass_fds implicitly sets close_fds to true.\n\nif shell is true, the specified command will be executed through the\nshell.\n\nIf cwd is not None, the current directory will be changed to cwd\nbefore the child is executed.\n\nOn POSIX, if restore_signals is True all signals that Python sets to\nSIG_IGN are restored to SIG_DFL in the child process before the exec.\nCurrently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals.  This\nparameter does nothing on Windows.\n\nOn POSIX, if start_new_session is True, the setsid() system call will be made\nin the child process prior to executing the command.\n\nIf env is not None, it defines the environment variables for the new\nprocess.\n\nIf universal_newlines is true, the file objects stdout and stderr are\nopened as a text files, but lines may be terminated by any of '\\n',\nthe Unix end-of-line convention, '\\r', the old Macintosh convention or\n'\\r\\n', the Windows convention.  All of these external representations\nare seen as '\\n' by the Python program.  Note: This feature is only\navailable if Python is built with universal newline support (the\ndefault).  Also, the newlines attribute of the file objects stdout,\nstdin and stderr are not updated by the communicate() method.\n\nThe startupinfo and creationflags, if given, will be passed to the\nunderlying CreateProcess() function.  They can specify things such as\nappearance of the main window and priority for the new process.\n(Windows only)\n\n\nThis module also defines some shortcut functions:\n\ncall(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> retcode = subprocess.call([\"ls\", \"-l\"])\n\ncheck_call(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete.  If the\n    exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> subprocess.check_call([\"ls\", \"-l\"])\n    0\n\ngetstatusoutput(cmd):\n    Return (status, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple\n    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the\n    returned output will contain output or error messages. A trailing newline\n    is stripped from the output. The exit status for the command can be\n    interpreted according to the rules for the C function wait().  Example:\n\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (256, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (256, 'sh: /bin/junk: not found')\n\ngetoutput(cmd):\n    Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n\ncheck_output(*popenargs, **kwargs):\n    Run command with arguments and return its output as a byte string.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> output = subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n\n\nExceptions\n----------\nExceptions raised in the child process, before the new program has\nstarted to execute, will be re-raised in the parent.  Additionally,\nthe exception object will have one extra attribute called\n'child_traceback', which is a string containing traceback information\nfrom the childs point of view.\n\nThe most common exception raised is OSError.  This occurs, for\nexample, when trying to execute a non-existent file.  Applications\nshould prepare for OSErrors.\n\nA ValueError will be raised if Popen is called with invalid arguments.\n\ncheck_call() and check_output() will raise CalledProcessError, if the\ncalled process returns a non-zero return code.\n\n\nSecurity\n--------\nUnlike some other popen functions, this implementation will never call\n/bin/sh implicitly.  This means that all characters, including shell\nmetacharacters, can safely be passed to child processes.\n\n\nPopen objects\n=============\nInstances of the Popen class have the following methods:\n\npoll()\n    Check if child process has terminated.  Returns returncode\n    attribute.\n\nwait()\n    Wait for child process to terminate.  Returns returncode attribute.\n\ncommunicate(input=None)\n    Interact with process: Send data to stdin.  Read data from stdout\n    and stderr, until end-of-file is reached.  Wait for process to\n    terminate.  The optional input argument should be a string to be\n    sent to the child process, or None, if no data should be sent to\n    the child.\n\n    communicate() returns a tuple (stdout, stderr).\n\n    Note: The data read is buffered in memory, so do not use this\n    method if the data size is large or unlimited.\n\nThe following attributes are also available:\n\nstdin\n    If the stdin argument is PIPE, this attribute is a file object\n    that provides input to the child process.  Otherwise, it is None.\n\nstdout\n    If the stdout argument is PIPE, this attribute is a file object\n    that provides output from the child process.  Otherwise, it is\n    None.\n\nstderr\n    If the stderr argument is PIPE, this attribute is file object that\n    provides error output from the child process.  Otherwise, it is\n    None.\n\npid\n    The process ID of the child process.\n\nreturncode\n    The child return code.  A None value indicates that the process\n    hasn't terminated yet.  A negative value -N indicates that the\n    child was terminated by signal N (POSIX only).\n\n\nReplacing older functions with the subprocess module\n====================================================\nIn this section, \"a ==> b\" means that b can be used as a replacement\nfor a.\n\nNote: All functions in this section fail (more or less) silently if\nthe executed program cannot be found; this module raises an OSError\nexception.\n\nIn the following examples, we assume that the subprocess module is\nimported with \"from subprocess import *\".\n\n\nReplacing /bin/sh shell backquote\n---------------------------------\noutput=`mycmd myarg`\n==>\noutput = Popen([\"mycmd\", \"myarg\"], stdout=PIPE).communicate()[0]\n\n\nReplacing shell pipe line\n-------------------------\noutput=`dmesg | grep hda`\n==>\np1 = Popen([\"dmesg\"], stdout=PIPE)\np2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\n\n\nReplacing os.system()\n---------------------\nsts = os.system(\"mycmd\" + \" myarg\")\n==>\np = Popen(\"mycmd\" + \" myarg\", shell=True)\npid, sts = os.waitpid(p.pid, 0)\n\nNote:\n\n* Calling the program through the shell is usually not required.\n\n* It's easier to look at the returncode attribute than the\n  exitstatus.\n\nA more real-world example would look like this:\n\ntry:\n    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n    if retcode < 0:\n        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n    else:\n        print(\"Child returned\", retcode, file=sys.stderr)\nexcept OSError as e:\n    print(\"Execution failed:\", e, file=sys.stderr)\n\n\nReplacing os.spawn*\n-------------------\nP_NOWAIT example:\n\npid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\npid = Popen([\"/bin/mycmd\", \"myarg\"]).pid\n\n\nP_WAIT example:\n\nretcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\nretcode = call([\"/bin/mycmd\", \"myarg\"])\n\n\nVector example:\n\nos.spawnvp(os.P_NOWAIT, path, args)\n==>\nPopen([path] + args[1:])\n\n\nEnvironment example:\n\nos.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n==>\nPopen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})", 
  "line": 0, 
  "type": "module", 
  "name": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "Repository", 
  "doc": null, 
  "module": "gi", 
  "file": "/usr/lib/python3/dist-packages/gi/__init__.py", 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_gi", 
  "file": "/usr/lib/python3/dist-packages/gi/_gi.cpython-32mu.so"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_glib", 
  "file": "/usr/lib/python3/dist-packages/gi/_glib/__init__.py"
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "_gobject", 
  "file": "/usr/lib/python3/dist-packages/gi/_gobject/__init__.py"
 }, 
 {
  "name": "get_required_version", 
  "doc": null, 
  "module": "gi", 
  "file": "/usr/lib/python3/dist-packages/gi/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": null, 
  "line": 0, 
  "type": "module", 
  "name": "gi", 
  "file": "/usr/lib/python3/dist-packages/gi/__init__.py"
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "require_version", 
  "doc": null, 
  "module": "gi", 
  "file": "/usr/lib/python3/dist-packages/gi/__init__.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "check_modules_installed", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_distro_information", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "get_lsb_information", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "guess_debian_release", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "guess_release_from_apt", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lookup_codename", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt', 'os2' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).", 
  "line": 0, 
  "type": "module", 
  "name": "os", 
  "file": "/usr/lib/python3.2/os.py"
 }, 
 {
  "name": "parse_apt_policy", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "parse_policy_line", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "doc": "Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v].\n    \\S       Matches any non-whitespace character; equiv. to [^ \\t\\n\\r\\f\\v].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match    Match a regular expression pattern to the beginning of a string.\n    search   Search a string for the presence of a pattern.\n    sub      Substitute occurrences of a pattern found in a string.\n    subn     Same as sub, but also return the number of substitutions made.\n    split    Split a string by the occurrences of a pattern.\n    findall  Find all occurrences of a pattern in a string.\n    finditer Return an iterator yielding a match object for each match.\n    compile  Compile a pattern into a RegexObject.\n    purge    Clear the regular expression cache.\n    escape   Backslash all non-alphanumerics in a string.\n\nSome of the functions in this module takes flags as optional parameters:\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.", 
  "line": 0, 
  "type": "module", 
  "name": "re", 
  "file": "/usr/lib/python3.2/re.py"
 }, 
 {
  "doc": "subprocess - Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.  This module\nintends to replace several other, older modules and functions, like:\n\nos.system\nos.spawn*\n\nInformation about how the subprocess module can be used to replace these\nmodules and functions can be found below.\n\n\n\nUsing the subprocess module\n===========================\nThis module defines one class called Popen:\n\nclass Popen(args, bufsize=0, executable=None,\n            stdin=None, stdout=None, stderr=None,\n            preexec_fn=None, close_fds=True, shell=False,\n            cwd=None, env=None, universal_newlines=False,\n            startupinfo=None, creationflags=0,\n            restore_signals=True, start_new_session=False, pass_fds=()):\n\n\nArguments are:\n\nargs should be a string, or a sequence of program arguments.  The\nprogram to execute is normally the first item in the args sequence or\nstring, but can be explicitly set by using the executable argument.\n\nOn POSIX, with shell=False (default): In this case, the Popen class\nuses os.execvp() to execute the child program.  args should normally\nbe a sequence.  A string will be treated as a sequence with the string\nas the only item (the program to execute).\n\nOn POSIX, with shell=True: If args is a string, it specifies the\ncommand string to execute through the shell.  If args is a sequence,\nthe first item specifies the command string, and any additional items\nwill be treated as additional shell arguments.\n\nOn Windows: the Popen class uses CreateProcess() to execute the child\nprogram, which operates on strings.  If args is a sequence, it will be\nconverted to a string using the list2cmdline method.  Please note that\nnot all MS Windows applications interpret the command line the same\nway: The list2cmdline is designed for applications using the same\nrules as the MS C runtime.\n\nbufsize, if given, has the same meaning as the corresponding argument\nto the built-in open() function: 0 means unbuffered, 1 means line\nbuffered, any other positive value means use a buffer of\n(approximately) that size.  A negative bufsize means to use the system\ndefault, which usually means fully buffered.  The default value for\nbufsize is 0 (unbuffered).\n\nstdin, stdout and stderr specify the executed programs' standard\ninput, standard output and standard error file handles, respectively.\nValid values are PIPE, an existing file descriptor (a positive\ninteger), an existing file object, and None.  PIPE indicates that a\nnew pipe to the child should be created.  With None, no redirection\nwill occur; the child's file handles will be inherited from the\nparent.  Additionally, stderr can be STDOUT, which indicates that the\nstderr data from the applications should be captured into the same\nfile handle as for stdout.\n\nOn POSIX, if preexec_fn is set to a callable object, this object will be\ncalled in the child process just before the child is executed.  The use\nof preexec_fn is not thread safe, using it in the presence of threads\ncould lead to a deadlock in the child process before the new executable\nis executed.\n\nIf close_fds is true, all file descriptors except 0, 1 and 2 will be\nclosed before the child process is executed.  The default for close_fds\nvaries by platform:  Always true on POSIX.  True when stdin/stdout/stderr\nare None on Windows, false otherwise.\n\npass_fds is an optional sequence of file descriptors to keep open between the\nparent and child.  Providing any pass_fds implicitly sets close_fds to true.\n\nif shell is true, the specified command will be executed through the\nshell.\n\nIf cwd is not None, the current directory will be changed to cwd\nbefore the child is executed.\n\nOn POSIX, if restore_signals is True all signals that Python sets to\nSIG_IGN are restored to SIG_DFL in the child process before the exec.\nCurrently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals.  This\nparameter does nothing on Windows.\n\nOn POSIX, if start_new_session is True, the setsid() system call will be made\nin the child process prior to executing the command.\n\nIf env is not None, it defines the environment variables for the new\nprocess.\n\nIf universal_newlines is true, the file objects stdout and stderr are\nopened as a text files, but lines may be terminated by any of '\\n',\nthe Unix end-of-line convention, '\\r', the old Macintosh convention or\n'\\r\\n', the Windows convention.  All of these external representations\nare seen as '\\n' by the Python program.  Note: This feature is only\navailable if Python is built with universal newline support (the\ndefault).  Also, the newlines attribute of the file objects stdout,\nstdin and stderr are not updated by the communicate() method.\n\nThe startupinfo and creationflags, if given, will be passed to the\nunderlying CreateProcess() function.  They can specify things such as\nappearance of the main window and priority for the new process.\n(Windows only)\n\n\nThis module also defines some shortcut functions:\n\ncall(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> retcode = subprocess.call([\"ls\", \"-l\"])\n\ncheck_call(*popenargs, **kwargs):\n    Run command with arguments.  Wait for command to complete.  If the\n    exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> subprocess.check_call([\"ls\", \"-l\"])\n    0\n\ngetstatusoutput(cmd):\n    Return (status, output) of executing cmd in a shell.\n\n    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple\n    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the\n    returned output will contain output or error messages. A trailing newline\n    is stripped from the output. The exit status for the command can be\n    interpreted according to the rules for the C function wait().  Example:\n\n    >>> subprocess.getstatusoutput('ls /bin/ls')\n    (0, '/bin/ls')\n    >>> subprocess.getstatusoutput('cat /bin/junk')\n    (256, 'cat: /bin/junk: No such file or directory')\n    >>> subprocess.getstatusoutput('/bin/junk')\n    (256, 'sh: /bin/junk: not found')\n\ngetoutput(cmd):\n    Return output (stdout or stderr) of executing cmd in a shell.\n\n    Like getstatusoutput(), except the exit status is ignored and the return\n    value is a string containing the command's output.  Example:\n\n    >>> subprocess.getoutput('ls /bin/ls')\n    '/bin/ls'\n\ncheck_output(*popenargs, **kwargs):\n    Run command with arguments and return its output as a byte string.\n\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    >>> output = subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n\n\nExceptions\n----------\nExceptions raised in the child process, before the new program has\nstarted to execute, will be re-raised in the parent.  Additionally,\nthe exception object will have one extra attribute called\n'child_traceback', which is a string containing traceback information\nfrom the childs point of view.\n\nThe most common exception raised is OSError.  This occurs, for\nexample, when trying to execute a non-existent file.  Applications\nshould prepare for OSErrors.\n\nA ValueError will be raised if Popen is called with invalid arguments.\n\ncheck_call() and check_output() will raise CalledProcessError, if the\ncalled process returns a non-zero return code.\n\n\nSecurity\n--------\nUnlike some other popen functions, this implementation will never call\n/bin/sh implicitly.  This means that all characters, including shell\nmetacharacters, can safely be passed to child processes.\n\n\nPopen objects\n=============\nInstances of the Popen class have the following methods:\n\npoll()\n    Check if child process has terminated.  Returns returncode\n    attribute.\n\nwait()\n    Wait for child process to terminate.  Returns returncode attribute.\n\ncommunicate(input=None)\n    Interact with process: Send data to stdin.  Read data from stdout\n    and stderr, until end-of-file is reached.  Wait for process to\n    terminate.  The optional input argument should be a string to be\n    sent to the child process, or None, if no data should be sent to\n    the child.\n\n    communicate() returns a tuple (stdout, stderr).\n\n    Note: The data read is buffered in memory, so do not use this\n    method if the data size is large or unlimited.\n\nThe following attributes are also available:\n\nstdin\n    If the stdin argument is PIPE, this attribute is a file object\n    that provides input to the child process.  Otherwise, it is None.\n\nstdout\n    If the stdout argument is PIPE, this attribute is a file object\n    that provides output from the child process.  Otherwise, it is\n    None.\n\nstderr\n    If the stderr argument is PIPE, this attribute is file object that\n    provides error output from the child process.  Otherwise, it is\n    None.\n\npid\n    The process ID of the child process.\n\nreturncode\n    The child return code.  A None value indicates that the process\n    hasn't terminated yet.  A negative value -N indicates that the\n    child was terminated by signal N (POSIX only).\n\n\nReplacing older functions with the subprocess module\n====================================================\nIn this section, \"a ==> b\" means that b can be used as a replacement\nfor a.\n\nNote: All functions in this section fail (more or less) silently if\nthe executed program cannot be found; this module raises an OSError\nexception.\n\nIn the following examples, we assume that the subprocess module is\nimported with \"from subprocess import *\".\n\n\nReplacing /bin/sh shell backquote\n---------------------------------\noutput=`mycmd myarg`\n==>\noutput = Popen([\"mycmd\", \"myarg\"], stdout=PIPE).communicate()[0]\n\n\nReplacing shell pipe line\n-------------------------\noutput=`dmesg | grep hda`\n==>\np1 = Popen([\"dmesg\"], stdout=PIPE)\np2 = Popen([\"grep\", \"hda\"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\n\n\nReplacing os.system()\n---------------------\nsts = os.system(\"mycmd\" + \" myarg\")\n==>\np = Popen(\"mycmd\" + \" myarg\", shell=True)\npid, sts = os.waitpid(p.pid, 0)\n\nNote:\n\n* Calling the program through the shell is usually not required.\n\n* It's easier to look at the returncode attribute than the\n  exitstatus.\n\nA more real-world example would look like this:\n\ntry:\n    retcode = call(\"mycmd\" + \" myarg\", shell=True)\n    if retcode < 0:\n        print(\"Child was terminated by signal\", -retcode, file=sys.stderr)\n    else:\n        print(\"Child returned\", retcode, file=sys.stderr)\nexcept OSError as e:\n    print(\"Execution failed:\", e, file=sys.stderr)\n\n\nReplacing os.spawn*\n-------------------\nP_NOWAIT example:\n\npid = os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\npid = Popen([\"/bin/mycmd\", \"myarg\"]).pid\n\n\nP_WAIT example:\n\nretcode = os.spawnlp(os.P_WAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\")\n==>\nretcode = call([\"/bin/mycmd\", \"myarg\"])\n\n\nVector example:\n\nos.spawnvp(os.P_NOWAIT, path, args)\n==>\nPopen([path] + args[1:])\n\n\nEnvironment example:\n\nos.spawnlpe(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", \"myarg\", env)\n==>\nPopen([\"/bin/mycmd\", \"myarg\"], env={\"PATH\": \"/usr/bin\"})", 
  "line": 0, 
  "type": "module", 
  "name": "subprocess", 
  "file": "/usr/lib/python3.2/subprocess.py"
 }, 
 {
  "doc": "This module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n\nDynamic objects:\n\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\n\nstdin -- standard input file object; used by input()\nstdout -- standard output file object; used by print()\nstderr -- standard error object; used for error messages\n  By assigning other file objects (or objects that behave like files)\n  to these, it is possible to redirect all of the interpreter's I/O.\n\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback -- traceback of last uncaught exception\n  These three are only available in an interactive session after a\n  traceback has been printed.\n\nStatic objects:\n\nfloat_info -- a dict with information about the float implementation.\nint_info -- a struct sequence with information about the int implementation.\nmaxsize -- the largest supported length of containers.\nmaxunicode -- the largest supported character\nbuiltin_module_names -- tuple of module names built into this interpreter\nsubversion -- subversion information of the build as tuple\nversion -- the version of this interpreter as a string\nversion_info -- version information as a named tuple\nhexversion -- version information encoded as a single integer\ncopyright -- copyright notice pertaining to this interpreter\nplatform -- platform identifier\nexecutable -- absolute path of the executable binary of the Python interpreter\nprefix -- prefix used to find the Python library\nexec_prefix -- prefix used to find the machine-specific Python library\nfloat_repr_style -- string indicating the style of repr() output for floats\n__stdin__ -- the original stdin; don't touch!\n__stdout__ -- the original stdout; don't touch!\n__stderr__ -- the original stderr; don't touch!\n__displayhook__ -- the original displayhook; don't touch!\n__excepthook__ -- the original excepthook; don't touch!\n\nFunctions:\n\ndisplayhook() -- print an object to the screen, and save it in builtins._\nexcepthook() -- print an exception and its traceback to sys.stderr\nexc_info() -- return thread-safe information about the current exception\nexit() -- exit the interpreter by raising SystemExit\ngetdlopenflags() -- returns flags to be used for dlopen() calls\ngetprofile() -- get the global profiling function\ngetrefcount() -- return the reference count for an object (plus one :-)\ngetrecursionlimit() -- return the max recursion depth for the interpreter\ngetsizeof() -- return the size of an object in bytes\ngettrace() -- get the global debug tracing function\nsetcheckinterval() -- control how often the interpreter checks for events\nsetdlopenflags() -- set the flags to be used for dlopen() calls\nsetprofile() -- set the global profiling function\nsetrecursionlimit() -- set the max recursion depth for the interpreter\nsettrace() -- set the global debug tracing function", 
  "line": 0, 
  "type": "module", 
  "name": "sys", 
  "file": null
 }, 
 {
  "name": "test", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "valid_lsb_versions", 
  "doc": null, 
  "module": "lsb_release", 
  "file": "/usr/lib/python3/dist-packages/lsb_release.py", 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__class__", 
  "doc": "str(string[, encoding[, errors]]) -> str\n\nCreate a new string object from the given encoded string.\nencoding defaults to the current default string encoding.\nerrors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "class", 
  "class": null
 }, 
 {
  "name": "__format__", 
  "doc": "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__getnewargs__", 
  "doc": null, 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__new__", 
  "doc": "T.__new__(S, ...) -> a new object with type S, a subtype of T", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__reduce_ex__", 
  "doc": "helper for pickle", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__sizeof__", 
  "doc": "S.__sizeof__() -> size of S in memory, in bytes", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "__subclasshook__", 
  "doc": "Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "capitalize", 
  "doc": "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "center", 
  "doc": "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "count", 
  "doc": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "encode", 
  "doc": "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "endswith", 
  "doc": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "expandtabs", 
  "doc": "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "find", 
  "doc": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format", 
  "doc": "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "format_map", 
  "doc": "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "index", 
  "doc": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalnum", 
  "doc": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isalpha", 
  "doc": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdecimal", 
  "doc": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isdigit", 
  "doc": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isidentifier", 
  "doc": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "islower", 
  "doc": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isnumeric", 
  "doc": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isprintable", 
  "doc": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isspace", 
  "doc": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "istitle", 
  "doc": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "isupper", 
  "doc": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "join", 
  "doc": "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "ljust", 
  "doc": "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lower", 
  "doc": "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "lstrip", 
  "doc": "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "maketrans", 
  "doc": "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "partition", 
  "doc": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "replace", 
  "doc": "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rfind", 
  "doc": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rindex", 
  "doc": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rjust", 
  "doc": "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rpartition", 
  "doc": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rsplit", 
  "doc": "S.rsplit([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "rstrip", 
  "doc": "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "split", 
  "doc": "S.split([sep[, maxsplit]]) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "splitlines", 
  "doc": "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "startswith", 
  "doc": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "strip", 
  "doc": "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "swapcase", 
  "doc": "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "title", 
  "doc": "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "translate", 
  "doc": "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "upper", 
  "doc": "S.upper() -> str\n\nReturn a copy of S converted to uppercase.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }, 
 {
  "name": "zfill", 
  "doc": "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.", 
  "module": null, 
  "file": null, 
  "line": 0, 
  "type": "function", 
  "class": null
 }
]
